{
  "version": 3,
  "sources": ["../src/ddls/data/DDLSEdge.ts", "../src/ddls/data/DDLSFace.ts", "../src/ddls/data/math/DDLSPoint2D.ts", "../src/ddls/data/DDLSVertex.ts", "../src/ddls/data/DDLSConstants.ts", "../src/ddls/data/math/DDLSRandGenerator.ts", "../src/ddls/iterators/IteratorFromVertexToHoldingFaces.ts", "../src/ddls/iterators/IteratorFromFaceToInnerEdges.ts", "../src/ddls/data/math/DDLSGeom2D.ts", "../src/ddls/ai/DDLSAStar.ts", "../src/ddls/data/math/DDLSMatrix2D.ts", "../src/ddls/data/DDLSObject.ts", "../src/ddls/ai/DDLSEntityAI.ts", "../src/ddls/ai/DDLSFunnel.ts", "../src/ddls/ai/DDLSPathFinder.ts", "../src/ddls/data/graph/DDLSGraphEdge.ts", "../src/ddls/data/graph/DDLSGraphNode.ts", "../src/ddls/data/graph/DDLSGraph.ts", "../src/ddls/data/DDLSConstraintSegment.ts", "../src/ddls/data/DDLSConstraintShape.ts", "../src/ddls/iterators/IteratorFromVertexToOutgoingEdges.ts", "../src/ddls/data/DDLSMesh.ts", "../src/ddls/factories/DDLSRectMeshFactory.ts", "../src/ddls/iterators/IteratorFromMeshToVertices.ts", "../src/ddls/iterators/IteratorFromVertexToIncomingEdges.ts", "../src/ddls/utils/DDLSUtils.ts", "../src/ddls/utils/Polygon.ts", "../src/ddls/view/DDLSSimpleView.ts", "../src/grids/graphs/GraphNode.ts", "../src/grids/graphs/GraphLink.ts", "../src/grids/graphs/Graph.ts", "../src/grids/graphs/GraphOptions.ts", "../src/grids/searchs/NodeSearchState.ts", "../src/grids/searchs/SearchStatePool.ts", "../src/grids/DefaultSettings.ts", "../src/grids/NodeHeap.ts", "../src/grids/AStar.ts"],
  "sourcesContent": ["import { DDLSConstraintSegment } from \"./DDLSConstraintSegment\";\r\nimport { DDLSFace } from \"./DDLSFace\";\r\nimport { DDLSVertex } from \"./DDLSVertex\";\r\n\r\n\r\n\r\nexport class DDLSEdge\r\n{\r\n\t\r\n\tprivate static INC:number = 0;\r\n\tprivate _id:number;\r\n\t\r\n\t// root datas\r\n\tprivate _isReal:boolean;\r\n\tprivate _isConstrained:boolean;\r\n\tprivate _originVertex:DDLSVertex;\r\n\tprivate _oppositeEdge:DDLSEdge;\r\n\tprivate _nextLeftEdge:DDLSEdge;\r\n\tprivate _leftFace:DDLSFace;\r\n\t\r\n\tprivate _fromConstraintSegments:DDLSConstraintSegment[];\r\n\t\r\n\tpublic colorDebug:number = -1;\r\n\t\r\n\tconstructor()\r\n\t{\r\n\t\tthis._id = DDLSEdge.INC;\r\n\t\tDDLSEdge.INC++;\r\n\t\t\r\n\t\tthis._fromConstraintSegments = [];\r\n\t}\r\n\t\r\n\tpublic get id():number\r\n\t{\r\n\t\treturn this._id;\r\n\t}\r\n\t\r\n\tpublic get isReal():boolean\r\n\t{\r\n\t\treturn this._isReal;\r\n\t}\r\n\t\r\n\tpublic get isConstrained():boolean\r\n\t{\r\n\t\treturn this._isConstrained;\r\n\t}\r\n\t\r\n\tpublic setDatas( originVertex:DDLSVertex\r\n\t\t\t\t\t\t\t, oppositeEdge:DDLSEdge\r\n\t\t\t\t\t\t\t, nextLeftEdge:DDLSEdge\r\n\t\t\t\t\t\t\t, leftFace:DDLSFace\r\n\t\t\t\t\t\t\t, isReal:boolean=true\r\n\t\t\t\t\t\t\t, isConstrained:boolean=false):void\r\n\t{\r\n\t\tthis._isConstrained = isConstrained;\r\n\t\tthis._isReal = isReal;\r\n\t\tthis._originVertex = originVertex;\r\n\t\tthis._oppositeEdge = oppositeEdge;\r\n\t\tthis._nextLeftEdge = nextLeftEdge;\r\n\t\tthis._leftFace = leftFace;\r\n\t}\r\n\t\r\n\tpublic addFromConstraintSegment(segment:DDLSConstraintSegment):void\r\n\t{\r\n\t\tif ( this._fromConstraintSegments.indexOf(segment) == -1 )\r\n\t\t\tthis._fromConstraintSegments.push(segment);\r\n\t}\r\n\t\r\n\tpublic removeFromConstraintSegment(segment:DDLSConstraintSegment):void\r\n\t{\r\n\t\tvar index:number = this._fromConstraintSegments.indexOf(segment);\r\n\t\tif ( index != -1 )\r\n\t\t\tthis._fromConstraintSegments.splice(index, 1);\r\n\t}\r\n\t\r\n\tpublic set originVertex(value:DDLSVertex)\r\n\t{\r\n\t\tthis._originVertex = value;\r\n\t}\r\n\t\r\n\tpublic set nextLeftEdge(value:DDLSEdge)\r\n\t{\r\n\t\tthis._nextLeftEdge = value;\r\n\t}\r\n\t\r\n\tpublic set leftFace(value:DDLSFace)\r\n\t{\r\n\t\tthis._leftFace = value;\r\n\t}\r\n\t\r\n\tpublic set isConstrained(value:boolean)\r\n\t{\r\n\t\tthis._isConstrained = value;\r\n\t}\r\n\t\r\n\tpublic get fromConstraintSegments():DDLSConstraintSegment[]\r\n\t{\r\n\t\treturn this._fromConstraintSegments;\r\n\t}\r\n\t\r\n\tpublic set fromConstraintSegments(value:DDLSConstraintSegment[])\r\n\t{\r\n\t\tthis._fromConstraintSegments = value;\r\n\t}\r\n\t\r\n\tpublic dispose():void\r\n\t{\r\n\t\tthis._originVertex = null;\r\n\t\tthis._oppositeEdge = null;\r\n\t\tthis._nextLeftEdge = null;\r\n\t\tthis._leftFace = null;\r\n\t\tthis._fromConstraintSegments = null;\r\n\t}\r\n\t\r\n\tpublic get originVertex()\t\t:DDLSVertex\t{\treturn this._originVertex;\t\t\t\t\t\t\t\t\t\t\t}\r\n\tpublic get destinationVertex()\t:DDLSVertex\t{\treturn this._oppositeEdge.originVertex;\t\t\t\t\t\t\t\t}\r\n\tpublic get oppositeEdge()\t\t:DDLSEdge\t\t{\treturn this._oppositeEdge;\t\t\t\t\t\t\t\t\t\t\t}\r\n\tpublic get nextLeftEdge()\t\t:DDLSEdge\t\t{\treturn this._nextLeftEdge;\t\t\t\t\t\t\t\t\t\t\t}\r\n\tpublic get prevLeftEdge()\t\t:DDLSEdge\t\t{\treturn this._nextLeftEdge.nextLeftEdge;\t\t\t\t\t\t\t\t}\r\n\tpublic get nextRightEdge()\t\t:DDLSEdge\t\t{\treturn this._oppositeEdge.nextLeftEdge.nextLeftEdge.oppositeEdge;\t}\r\n\tpublic get prevRightEdge()\t\t:DDLSEdge\t\t{\treturn this._oppositeEdge.nextLeftEdge.oppositeEdge;\t\t\t\t\t}\r\n\tpublic get rotLeftEdge()\t\t:DDLSEdge\t\t{\treturn this._nextLeftEdge.nextLeftEdge.oppositeEdge;\t\t\t\t\t}\r\n\tpublic get rotRightEdge()\t\t:DDLSEdge\t\t{\treturn this._oppositeEdge.nextLeftEdge;\t\t\t\t\t\t\t\t}\r\n\tpublic get leftFace()\t\t\t:DDLSFace\t\t{\treturn this._leftFace;\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\tpublic get rightFace()\t\t\t:DDLSFace\t\t{\treturn this._oppositeEdge.leftFace;\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\tpublic toString():string\r\n\t{\r\n\t\treturn \"edge \" + this.originVertex.id + \" - \" + this.destinationVertex.id;\r\n\t}\r\n}", "import { DDLSEdge } from \"./DDLSEdge\";\r\n\r\nexport class DDLSFace {\r\n\r\n\tprivate static INC: number = 0;\r\n\tprivate _id: number;\r\n\r\n\tprivate _isReal: boolean;\r\n\tprivate _edge: DDLSEdge;\r\n\r\n\tpublic colorDebug: number = -1;\r\n\r\n\tconstructor() {\r\n\t\tthis._id = DDLSFace.INC;\r\n\t\tDDLSFace.INC++;\r\n\t}\r\n\r\n\tpublic get id(): number {\r\n\t\treturn this._id;\r\n\t}\r\n\r\n\tpublic get isReal(): boolean {\r\n\t\treturn this._isReal;\r\n\t}\r\n\r\n\tpublic setDatas(edge: DDLSEdge, isReal: boolean = true): void {\r\n\t\tthis._isReal = isReal;\r\n\t\tthis._edge = edge;\r\n\t}\r\n\r\n\tpublic dispose(): void {\r\n\t\tthis._edge = null;\r\n\t}\r\n\r\n\tpublic get edge(): DDLSEdge {\r\n\t\treturn this._edge;\r\n\t}\r\n\r\n}", "import { DDLSMatrix2D } from \"./DDLSMatrix2D\";\r\n\r\n\r\nexport class DDLSPoint2D\r\n{\r\n    private static INC:number = 0;\r\n    private _id:number;\r\n\r\n    private _x:number;\r\n    private _y:number;\r\n    \r\n    constructor(x:number=0,y:number=0)\r\n    {\r\n        this._id = DDLSPoint2D.INC;\r\n        DDLSPoint2D.INC++;\r\n\r\n        this.setTo(x,y);\r\n    }\r\n\r\n    public get id():number\r\n    {\r\n        return this._id;\r\n    }\r\n    \r\n    public transform(matrix:DDLSMatrix2D):void\r\n    {\r\n        matrix.tranform(this);\r\n    }\r\n\r\n    public setTo(x:number,y:number):void{\r\n        this._x = x;\r\n        this._y = y;\r\n    }\r\n\r\n    public clone():DDLSPoint2D\r\n    {\r\n        return new DDLSPoint2D(this._x,this._y);\r\n    }\r\n\r\n    public substract(p:DDLSPoint2D):void{\r\n        this._x -= p.x;\r\n        this._y -= p.y;\r\n    }\r\n\r\n    public get length():number\r\n    {\r\n        return Math.sqrt(this._x*this._x + this._y*this._y);\r\n    }\r\n\r\n    public get x() : number \r\n    {\r\n        return this._x;\r\n    }\r\n    \r\n    public set x(value:number)\r\n    {\r\n        this._x = value;\r\n    }\r\n\r\n    public get y() : number \r\n    {\r\n        return this._y;\r\n    }\r\n    \r\n    public set y(value:number)\r\n    {\r\n        this._y = value;\r\n    }\r\n\r\n    public normalize():void{\r\n        let norm:number = this.length;\r\n        this.x /= norm;\r\n        this.y /= norm;\r\n    }\r\n\r\n    public scale(s:number):void{\r\n        this.x *= s;\r\n        this.y *= s;\r\n    }\r\n\r\n    public distanceTo(p:DDLSPoint2D):number\r\n    {\r\n        var diffX:number = this.x - p.x;\r\n        var diffY:number = this.y - p.y;\r\n        return Math.sqrt(diffX*diffX + diffY*diffY);\r\n    }\r\n    \r\n    public distanceSquaredTo(p:DDLSPoint2D):number\r\n    {\r\n        var diffX:number = this.x - p.x;\r\n        var diffY:number = this.y - p.y;\r\n        return diffX*diffX + diffY*diffY;\r\n    }\r\n}", "import { DDLSConstraintSegment } from \"./DDLSConstraintSegment\";\r\nimport { DDLSEdge } from \"./DDLSEdge\";\r\nimport { DDLSPoint2D } from \"./math/DDLSPoint2D\";\r\n\r\n\r\nexport class DDLSVertex\r\n{\r\n    \r\n    private static INC:number = 0;\r\n    private _id:number;\r\n    \r\n    private _pos:DDLSPoint2D;\r\n    \r\n    private _isReal:boolean;\r\n    private _edge:DDLSEdge;\r\n    \r\n    private _fromConstraintSegments:DDLSConstraintSegment[];\r\n    \r\n    public colorDebug:number = - 1;\r\n    \r\n    constructor()\r\n    {\r\n        this._id = DDLSVertex.INC;\r\n        DDLSVertex.INC++;\r\n        \r\n        this._pos = new DDLSPoint2D();\r\n        \r\n        this._fromConstraintSegments = [];\r\n    }\r\n    \r\n    public get id():number\r\n    {\r\n        return this._id;\r\n    }\r\n    \r\n    public get isReal():boolean\r\n    {\r\n        return this._isReal;\r\n    }\r\n    \r\n    public get pos():DDLSPoint2D\r\n    {\r\n        return this._pos;\r\n    }\r\n    \r\n    public get fromConstraintSegments():DDLSConstraintSegment[]\r\n    {\r\n        return this._fromConstraintSegments;\r\n    }\r\n    \r\n    public set fromConstraintSegments(value:DDLSConstraintSegment[])\r\n    {\r\n        this._fromConstraintSegments = value;\r\n    }\r\n    \r\n    public setDatas(edge:DDLSEdge, isReal:boolean=true):void\r\n    {\r\n        this._isReal = isReal;\r\n        this._edge = edge;\r\n    }\r\n    \r\n    public addFromConstraintSegment(segment:DDLSConstraintSegment):void\r\n    {\r\n        if ( this._fromConstraintSegments.indexOf(segment) == -1 )\r\n            this._fromConstraintSegments.push(segment);\r\n    }\r\n    \r\n    public removeFromConstraintSegment(segment:DDLSConstraintSegment):void\r\n    {\r\n        var index:number = this._fromConstraintSegments.indexOf(segment);\r\n        if ( index != -1 )\r\n            this._fromConstraintSegments.splice(index, 1);\r\n    }\r\n    \r\n    public dispose():void\r\n    {\r\n        this._pos = null;\r\n        this._edge = null;\r\n        this._fromConstraintSegments = null;\r\n    }\r\n    \r\n    public get edge():DDLSEdge\r\n    {\r\n        return this._edge;\r\n    }\r\n    \r\n    public set edge(value:DDLSEdge)\r\n    {\r\n        this._edge = value;\r\n    }\r\n    \r\n    public toString():string\r\n    {\r\n        return \"ver_id \" + this._id;\r\n    }\r\n    \r\n}\r\n", "export class DDLSConstants\r\n{\r\n\tpublic static EPSILON:number = 0.01;\r\n\tpublic static EPSILON_SQUARED:number = 0.0001;\r\n}", "\r\nexport class DDLSRandGenerator\r\n{\r\n\t\r\n\tprivate _originalSeed:number;\r\n\tprivate _currSeed:number;\r\n\tprivate _rangeMin:number;\r\n\tprivate _rangeMax:number;\r\n\t\r\n\tprivate _numIter:number;\r\n\tprivate _tempString:string;\r\n\t\r\n\tconstructor(seed:number=1234, rangeMin:number=0, rangeMax:number=1)\r\n\t{\r\n\t\tthis._originalSeed = this._currSeed = this.seed;\r\n\t\tthis._rangeMin = this.rangeMin;\r\n\t\tthis._rangeMax = this.rangeMax;\r\n\t\t\r\n\t\tthis._numIter = 0;\r\n\t}\r\n\t\r\n\tpublic set seed(value:number)\t\t{\tthis._originalSeed = this._currSeed = value;\t\t}\r\n\tpublic set rangeMin(value:number)\t{\tthis._rangeMin = value;\t}\r\n\tpublic set rangeMax(value:number)\t{\tthis._rangeMax = value;\t}\r\n\t\r\n\tpublic get seed():number\t\t\t\t\t{\t\treturn this._originalSeed;\t}\r\n\tpublic get rangeMin():number\t\t\t\t{\t\treturn this._rangeMin;\t\t}\r\n\tpublic get rangeMax():number\t\t\t\t{\t\treturn this._rangeMax;\t\t}\r\n\t\r\n\tpublic reset():void\r\n\t{\r\n\t\tthis._currSeed = this._originalSeed;\r\n\t\tthis._numIter = 0;\r\n\t}\r\n\t\r\n\tpublic next():number\r\n\t{\r\n\t\tthis._tempString = \"\";\r\n\t\tthis._tempString +=this._currSeed*this._currSeed;\r\n\t\t\r\n\t\twhile (this._tempString.length < 8)\r\n\t\t{\r\n\t\t\tthis._tempString = \"0\" + this._tempString;\r\n\t\t}\r\n\t\t\r\n\t\tthis._currSeed = Number(this._tempString.substr( 1 , 5 ));\r\n\t\t\r\n\t\tvar res:number = Math.round(this._rangeMin + (this._currSeed / 99999)*(this._rangeMax - this._rangeMin));\r\n\t\t\r\n\t\tif (this._currSeed == 0)\r\n\t\t\tthis._currSeed = this._originalSeed+this._numIter;\r\n\t\t\r\n\t\tthis._numIter++;\r\n\t\t\r\n\t\tif (this._numIter == 200)\r\n\t\t\tthis.reset();\r\n\t\t\r\n\t\treturn res;\r\n\t}\r\n\r\n}", "import { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSFace } from \"../data/DDLSFace\";\r\nimport { DDLSVertex } from \"../data/DDLSVertex\";\r\n\r\n\r\nexport class IteratorFromVertexToHoldingFaces\r\n{\r\n\t\r\n\tprivate _fromVertex:DDLSVertex;\r\n\tprivate _nextEdge:DDLSEdge;\r\n\t\r\n\tconstructor()\r\n\t{\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic set fromVertex( value:DDLSVertex )\r\n\t{\r\n\t\tthis._fromVertex = value;\r\n\t\tthis._nextEdge = this._fromVertex.edge;\r\n\t}\r\n\t\r\n\t\r\n\tprivate _resultFace:DDLSFace;\r\n\tpublic next():DDLSFace\r\n\t{\r\n\t\tif (this._nextEdge)\r\n\t\t{\r\n\t\t\tdo\r\n\t\t\t{\r\n\t\t\t\tthis._resultFace = this._nextEdge.leftFace;\r\n\t\t\t\tthis._nextEdge = this._nextEdge.rotLeftEdge;\r\n\t\t\t\tif ( this._nextEdge == this._fromVertex.edge )\r\n\t\t\t\t{\r\n\t\t\t\t\tthis._nextEdge = null;\r\n\t\t\t\t\tif (! this._resultFace.isReal)\r\n\t\t\t\t\t\tthis._resultFace = null;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile ( ! this._resultFace.isReal )\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis._resultFace = null;\r\n\t\t}\r\n\t\t\r\n\t\treturn this._resultFace;\r\n\t}\r\n\t\r\n}", "import { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSFace } from \"../data/DDLSFace\";\r\n\r\n\r\n\r\nexport class IteratorFromFaceToInnerEdges\r\n{\r\n\t\r\n\tprivate _fromFace:DDLSFace;\r\n\tprivate _nextEdge:DDLSEdge;\r\n\t\r\n\tconstructor()\r\n\t{\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic set fromFace( value:DDLSFace )\r\n\t{\r\n\t\tthis._fromFace = value;\r\n\t\tthis._nextEdge = this._fromFace.edge;\r\n\t}\r\n\t\r\n\tprivate _resultEdge:DDLSEdge;\r\n\tpublic next():DDLSEdge\r\n\t{\r\n\t\tif (this._nextEdge)\r\n\t\t{\r\n\t\t\tthis._resultEdge = this._nextEdge;\r\n\t\t\tthis._nextEdge = this._nextEdge.nextLeftEdge;\r\n\t\t\t\r\n\t\t\tif ( this._nextEdge == this._fromFace.edge )\r\n\t\t\t\tthis._nextEdge = null;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis._resultEdge = null;\r\n\t\t}\r\n\t\t\r\n\t\treturn this._resultEdge;\r\n\t}\r\n}", "import { DDLSEdge } from \"../DDLSEdge\";\r\nimport { DDLSFace } from \"../DDLSFace\";\r\nimport { DDLSMesh } from \"../DDLSMesh\";\r\nimport { DDLSVertex } from \"../DDLSVertex\";\r\nimport { DDLSConstants } from \"../DDLSConstants\";\r\nimport { DDLSRandGenerator } from \"./DDLSRandGenerator\";\r\nimport { DDLSPoint2D } from \"./DDLSPoint2D\";\r\nimport { IteratorFromVertexToHoldingFaces } from \"../../iterators/IteratorFromVertexToHoldingFaces\";\r\nimport { IteratorFromFaceToInnerEdges } from \"../../iterators/IteratorFromFaceToInnerEdges\";\r\n\r\n\r\n\r\n\t\r\nexport class DDLSGeom2D {\r\n\r\n\r\n\tprivate static _randGen: DDLSRandGenerator;\r\n\r\n\t// return one the following, in priority order:\r\n\t// - an existant vertex (if (x, y) lies on this vertex)\r\n\t// or \r\n\t// - an existant edge (if (x, y) lies on this edge )\r\n\t// or\r\n\t// - an existant face (if (x, y) lies on this face )\r\n\t// or\r\n\t// - null if outside mesh\r\n\t// YOU SHOULD USE THIS FUNCTION ONLY FOR COORDINATES INSIDE SAFE AREA\r\n\tprivate static __samples: DDLSVertex[] = [];\r\n\tpublic static locatePosition(x: number, y: number, mesh: DDLSMesh): Object {\r\n\t\t// jump and walk algorithm\r\n\t\tvar closedVertex: DDLSVertex;\r\n\t\tif (!DDLSGeom2D._randGen)\r\n\t\t\tDDLSGeom2D._randGen = new DDLSRandGenerator();\r\n\t\tDDLSGeom2D._randGen.seed = x * 10 + 4 * y;\r\n\r\n\t\tvar i: number;\r\n\r\n\t\tthis.__samples.splice(0, this.__samples.length);\r\n\t\tvar numSamples: number = Math.pow(mesh.__vertices.length, 1 / 3);\r\n\t\tDDLSGeom2D._randGen.rangeMin = 0;\r\n\t\tDDLSGeom2D._randGen.rangeMax = mesh.__vertices.length - 1;\r\n\t\tfor (i = 0; i < numSamples; i++)\r\n\t\t\tthis.__samples.push(mesh.__vertices[DDLSGeom2D._randGen.next()]);\r\n\r\n\r\n\r\n\t\tvar currVertex: DDLSVertex;\r\n\t\tvar currVertexPos: DDLSPoint2D;\r\n\t\tvar distSquared: number;\r\n\t\tvar minDistSquared: number = Number.MAX_VALUE;\r\n\t\tfor (i = 0; i < numSamples; i++) {\r\n\t\t\tcurrVertex = this.__samples[i];\r\n\t\t\tcurrVertexPos = currVertex.pos;\r\n\t\t\tdistSquared = (currVertexPos.x - x) * (currVertexPos.x - x) + (currVertexPos.y - y) * (currVertexPos.y - y);\r\n\t\t\tif (distSquared < minDistSquared) {\r\n\t\t\t\tminDistSquared = distSquared;\r\n\t\t\t\tclosedVertex = currVertex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar currFace: DDLSFace;\r\n\t\tvar iterFace: IteratorFromVertexToHoldingFaces = new IteratorFromVertexToHoldingFaces();\r\n\t\titerFace.fromVertex = closedVertex;\r\n\t\tcurrFace = iterFace.next();\r\n\r\n\t\tvar faceVisited: any = {};\r\n\t\tvar currEdge: DDLSEdge;\r\n\t\tvar iterEdge: IteratorFromFaceToInnerEdges = new IteratorFromFaceToInnerEdges();\r\n\t\tvar objectContainer: Object;\r\n\t\tvar relativPos: number;\r\n\t\tvar numIter: number = 0;\r\n\t\twhile (faceVisited[currFace.id] || !(objectContainer = this.isInFace(x, y, currFace))) {\r\n\t\t\tfaceVisited[currFace.id] = true;\r\n\r\n\t\t\tnumIter++;\r\n\t\t\tif (numIter == 50) {\r\n\t\t\t\tconsole.warn(\"WALK TAKE MORE THAN 50 LOOP\",\"DDLS\");\r\n\t\t\t\t//objectContainer = null;\r\n\t\t\t\t//break;\r\n\t\t\t\t//throw new Error(\"WALK TAKE MORE THAN 50 LOOP\");\r\n\t\t\t}\r\n\t\t\tif (numIter == 1000) {\r\n\t\t\t\tconsole.warn(\"WALK TAKE MORE THAN 1000 LOOP -> WE ESCAPE\",\"DDLS\");\r\n\t\t\t\tobjectContainer = null;\r\n\t\t\t\tbreak;\r\n\t\t\t\t//throw new Error(\"WALK TAKE MORE THAN 50 LOOP\");\r\n\t\t\t}\r\n\t\t\titerEdge.fromFace = currFace;\r\n\t\t\tdo {\r\n\t\t\t\tcurrEdge = iterEdge.next();\r\n\t\t\t\tif (currEdge == null) {\r\n\t\t\t\t\tconsole.log(\"KILL PATH\",\"DDLS\");\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\trelativPos = this.getRelativePosition(x, y, currEdge);\r\n\t\t\t}\r\n\t\t\twhile (relativPos == 1 || relativPos == 0)\r\n\r\n\t\t\tcurrFace = currEdge.rightFace;\r\n\t\t}\r\n\r\n\t\treturn objectContainer;\r\n\t}\r\n\r\n\t/**\r\n\t *  \u5706\u5F62\u662F\u5426\u4E0E\u4EFB\u4F55\u7EA6\u675F\u4EA4\u53C9\r\n\t * @param x\r\n\t * @param y\r\n\t * @param radius\r\n\t * @param mesh\r\n\t * @return\r\n\t */\r\n\tpublic static isCircleIntersectingAnyConstraint(x: number, y: number, radius: number, mesh: DDLSMesh): boolean {\r\n\t\tif (x <= 0 || x >= mesh.width || y <= 0 || y >= mesh.height)\r\n\t\t\treturn true;\r\n\r\n\t\tvar loc = DDLSGeom2D.locatePosition(x, y, mesh);\r\n\t\tvar face: DDLSFace;\r\n\t\tif (loc instanceof DDLSVertex)\r\n\t\t\tface = (<DDLSVertex>loc).edge.leftFace;\r\n\t\telse if (loc instanceof DDLSEdge)\r\n\t\t\tface = (<DDLSEdge>loc).leftFace;\r\n\t\telse\r\n\t\t\tface = <DDLSFace>loc;\r\n\r\n\t\t// if a vertex is in the circle, a contrainst must intersect the circle\r\n\t\t// because a vertex always belongs to a contrained edge\r\n\t\tvar radiusSquared: number = radius * radius;\r\n\t\tvar pos: DDLSPoint2D;\r\n\t\tvar distSquared: number;\r\n\t\tpos = face.edge.originVertex.pos;\r\n\t\tdistSquared = (pos.x - x) * (pos.x - x) + (pos.y - y) * (pos.y - y);\r\n\t\tif (distSquared <= radiusSquared) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tpos = face.edge.nextLeftEdge.originVertex.pos;\r\n\t\tdistSquared = (pos.x - x) * (pos.x - x) + (pos.y - y) * (pos.y - y);\r\n\t\tif (distSquared <= radiusSquared) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tpos = face.edge.nextLeftEdge.nextLeftEdge.originVertex.pos;\r\n\t\tdistSquared = (pos.x - x) * (pos.x - x) + (pos.y - y) * (pos.y - y);\r\n\t\tif (distSquared <= radiusSquared) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// check if edge intersects\r\n\t\tvar edgesToCheck: DDLSEdge[] = [];\r\n\t\tedgesToCheck.push(face.edge);\r\n\t\tedgesToCheck.push(face.edge.nextLeftEdge);\r\n\t\tedgesToCheck.push(face.edge.nextLeftEdge.nextLeftEdge);\r\n\r\n\t\tvar edge: DDLSEdge;\r\n\t\tvar pos1: DDLSPoint2D;\r\n\t\tvar pos2: DDLSPoint2D;\r\n\t\tvar checkedEdges: any = {};\r\n\t\tvar intersecting: boolean;\r\n\t\twhile (edgesToCheck.length > 0) {\r\n\t\t\tedge = edgesToCheck.pop();\r\n\t\t\tcheckedEdges[edge.id] = true;\r\n\t\t\tpos1 = edge.originVertex.pos;\r\n\t\t\tpos2 = edge.destinationVertex.pos;\r\n\t\t\tintersecting = this.intersectionsSegmentCircle(pos1.x, pos1.y, pos2.x, pos2.y, x, y, radius);\r\n\t\t\tif (intersecting) {\r\n\t\t\t\tif (edge.isConstrained)\r\n\t\t\t\t\treturn true;\r\n\t\t\t\telse {\r\n\t\t\t\t\tedge = edge.oppositeEdge.nextLeftEdge;\r\n\t\t\t\t\tif (!checkedEdges[edge.id] && !checkedEdges[edge.oppositeEdge.id]\r\n\t\t\t\t\t\t&& edgesToCheck.indexOf(edge) == -1 && edgesToCheck.indexOf(edge.oppositeEdge) == -1) {\r\n\t\t\t\t\t\tedgesToCheck.push(edge);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tedge = edge.nextLeftEdge;\r\n\t\t\t\t\tif (!checkedEdges[edge.id] && !checkedEdges[edge.oppositeEdge.id]\r\n\t\t\t\t\t\t&& edgesToCheck.indexOf(edge) == -1 && edgesToCheck.indexOf(edge.oppositeEdge) == -1) {\r\n\t\t\t\t\t\tedgesToCheck.push(edge);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// return the relative direction from (x1,y1), to (x3,y3) through (x2, y2)\r\n\t// the function returns:\r\n\t// 0 if the path is a straight line\r\n\t// 1 if the path goes to the left\r\n\t// -1 if the path goes to the right\r\n\tpublic static getDirection(x1: number, y1: number\r\n\t\t, x2: number, y2: number\r\n\t\t, x3: number, y3: number): number {\r\n\r\n\t\t// dot product with the orthogonal vector pointing left vector of eUp:\r\n\t\tvar dot: number = (x3 - x1) * (y2 - y1) + (y3 - y1) * (- x2 + x1);\r\n\r\n\t\t// check sign\r\n\t\treturn (dot == 0) ? 0 : ((dot > 0) ? 1 : -1);\r\n\t}\r\n\r\n\t// second version of getDirection. More accurate and safer version\r\n\t// return the relative direction from (x1,y1), to (x3,y3) through (x2, y2)\r\n\t// the function returns:\r\n\t// 0 if the path is a straight line\r\n\t// 1 if the path goes to the left\r\n\t// -1 if the path goes to the right\r\n\tpublic static getDirection2(x1: number, y1: number\r\n\t\t, x2: number, y2: number\r\n\t\t, x3: number, y3: number): number {\r\n\t\t// dot product with the orthogonal vector pointing left vector of eUp:\r\n\t\tvar dot: number = (x3 - x1) * (y2 - y1) + (y3 - y1) * (- x2 + x1);\r\n\r\n\t\t// check sign\r\n\t\tif (dot == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\telse if (dot > 0) {\r\n\t\t\tif (this.distanceSquaredPointToLine(x3, y3, x1, y1, x2, y2) <= DDLSConstants.EPSILON_SQUARED)\r\n\t\t\t\treturn 0;\r\n\t\t\telse\r\n\t\t\t\treturn 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this.distanceSquaredPointToLine(x3, y3, x1, y1, x2, y2) <= DDLSConstants.EPSILON_SQUARED)\r\n\t\t\t\treturn 0;\r\n\t\t\telse\r\n\t\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\r\n\t// eUp <an> seen infinite line splits the 2D space in 2 parts (left and right),\r\n\t// the function returns:\r\n\t//   0 if the (x, y) lies on the line\r\n\t//   1 if the (x, y) lies at left\r\n\t//   -1 if the (x, y) lies at right\r\n\tpublic static getRelativePosition(x: number, y: number, eUp: DDLSEdge): number {\r\n\t\treturn this.getDirection(eUp.originVertex.pos.x, eUp.originVertex.pos.y\r\n\t\t\t, eUp.destinationVertex.pos.x, eUp.destinationVertex.pos.y\r\n\t\t\t, x, y);\r\n\r\n\t\t/*\r\n\t\tparametric expression of pointing up edge eUp\r\n\t\tx(t1) = vOrigin.x + t1*(vDestination.x - vOrigin.x)\r\n\t\ty(t1) = vOrigin.y + t1*(vDestination.y - vOrigin.y)\r\n\t\t\r\n\t\tand orthogonal edge pointing right to eUp \r\n\t\tx(t2) = vOrigin.x + t2*(vDestination.y - vOrigin.y)\r\n\t\ty(t2) = vOrigin.y - t2*(vDestination.x - vOrigin.x)\r\n\t\t\r\n\t\t(x, y) position can be <a> expressed linear combination of the 2 previous segments\r\n\t\tx = vOrigin.x + t2*(vDestination.y - vOrigin.y) + t1*(vDestination.x - vOrigin.x)\r\n\t\ty = vOrigin.y + t1*(vDestination.y - vOrigin.y) - t2*(vDestination.x - vOrigin.x)\r\n\t\t\r\n\t\t---> the sign of t2 will inform us if vToCheck lies at right or left of eUp\r\n\t\t*/\r\n\r\n\t\t// set alias letters\r\n\t\t/*\r\n\t\tvar a:number = x;\r\n\t\tvar b:number = y;\r\n\t\tvar c:number = vOrigin.pos.x;\r\n\t\tvar d:number = vOrigin.pos.y;\r\n\t\tvar e:number = vDestination.pos.x;\r\n\t\tvar f:number = vDestination.pos.y;\r\n\t\t*/\r\n\r\n\t\t/*\r\n\t\tsystem to solve:\r\n\t\ta = c + t2 (f - d) + t1 (e - c)\r\n\t\tb = d + t1 (f - d) - t2 (e - c)\r\n\t\t*/\r\n\r\n\t\t// giving to wolfram: Solve[{a = c + t2 (f - d) + t1 (e - c) , b = d + t1 (f - d) - t2 (e - c)}, {t1, t2}]\r\n\t\t// we get:\r\n\t\t/*\r\n\t\tvar t2:number = (-a*d + a*f + b*c - b*e - c*f + d*e) / (c*c - 2*c*e + d*d - 2*d*f + e*e + f*f);\r\n\t\t\r\n\t\tvar result:number;\r\n\t\tif ( t2 == 0 )\r\n\t\t\tresult = 0;\r\n\t\telse if ( t2 < 0 )\r\n\t\t\tresult = -1;\r\n\t\telse\r\n\t\t\tresult = 1;\r\n\t\t\r\n\t\treturn result;\r\n\t\t*/\r\n\t}\r\n\r\n\tpublic static getRelativePosition2(x: number, y: number, eUp: DDLSEdge): number {\r\n\t\treturn this.getDirection2(eUp.originVertex.pos.x, eUp.originVertex.pos.y\r\n\t\t\t, eUp.destinationVertex.pos.x, eUp.destinationVertex.pos.y\r\n\t\t\t, x, y);\r\n\t}\r\n\r\n\t// the function checks by priority:\r\n\t// - if the (x, y) lies on a vertex of the polygon, it will return this vertex\r\n\t// - if the (x, y) lies on a edge of the polygon, it will return this edge\r\n\t// - if the (x, y) lies inside the polygon, it will return the polygon\r\n\t// - if the (x, y) lies outside the polygon, it will return null\r\n\tpublic static isInFace(x: number, y: number, polygon: DDLSFace): Object {\r\n\t\t// remember polygons are triangle only,\r\n\t\t// and we suppose we have not degenerated flat polygons !\r\n\r\n\t\tvar result: Object;\r\n\r\n\t\tvar e1_2: DDLSEdge = polygon.edge;\r\n\t\tvar e2_3: DDLSEdge = e1_2.nextLeftEdge;\r\n\t\tvar e3_1: DDLSEdge = e2_3.nextLeftEdge;\r\n\t\tif (this.getRelativePosition(x, y, e1_2) >= 0 && this.getRelativePosition(x, y, e2_3) >= 0 && this.getRelativePosition(x, y, e3_1) >= 0) {\r\n\t\t\tvar v1: DDLSVertex = e1_2.originVertex;\r\n\t\t\tvar v2: DDLSVertex = e2_3.originVertex;\r\n\t\t\tvar v3: DDLSVertex = e3_1.originVertex;\r\n\r\n\t\t\tvar x1: number = v1.pos.x;\r\n\t\t\tvar y1: number = v1.pos.y;\r\n\t\t\tvar x2: number = v2.pos.x;\r\n\t\t\tvar y2: number = v2.pos.y;\r\n\t\t\tvar x3: number = v3.pos.x;\r\n\t\t\tvar y3: number = v3.pos.y;\r\n\r\n\t\t\tvar v_v1squaredLength: number = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\r\n\t\t\tvar v_v2squaredLength: number = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\r\n\t\t\tvar v_v3squaredLength: number = (x3 - x) * (x3 - x) + (y3 - y) * (y3 - y);\r\n\t\t\tvar v1_v2squaredLength: number = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n\t\t\tvar v2_v3squaredLength: number = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);\r\n\t\t\tvar v3_v1squaredLength: number = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);\r\n\r\n\t\t\tvar dot_v_v1v2: number = (x - x1) * (x2 - x1) + (y - y1) * (y2 - y1);\r\n\t\t\tvar dot_v_v2v3: number = (x - x2) * (x3 - x2) + (y - y2) * (y3 - y2);\r\n\t\t\tvar dot_v_v3v1: number = (x - x3) * (x1 - x3) + (y - y3) * (y1 - y3);\r\n\r\n\t\t\tvar v_e1_2squaredLength: number = v_v1squaredLength - dot_v_v1v2 * dot_v_v1v2 / v1_v2squaredLength;\r\n\t\t\tvar v_e2_3squaredLength: number = v_v2squaredLength - dot_v_v2v3 * dot_v_v2v3 / v2_v3squaredLength;\r\n\t\t\tvar v_e3_1squaredLength: number = v_v3squaredLength - dot_v_v3v1 * dot_v_v3v1 / v3_v1squaredLength;\r\n\r\n\t\t\tvar closeTo_e1_2: boolean = v_e1_2squaredLength <= DDLSConstants.EPSILON_SQUARED;\r\n\t\t\tvar closeTo_e2_3: boolean = v_e2_3squaredLength <= DDLSConstants.EPSILON_SQUARED;\r\n\t\t\tvar closeTo_e3_1: boolean = v_e3_1squaredLength <= DDLSConstants.EPSILON_SQUARED;\r\n\r\n\t\t\tif (closeTo_e1_2) {\r\n\t\t\t\tif (closeTo_e3_1)\r\n\t\t\t\t\tresult = v1;\r\n\t\t\t\telse if (closeTo_e2_3)\r\n\t\t\t\t\tresult = v2;\r\n\t\t\t\telse\r\n\t\t\t\t\tresult = e1_2;\r\n\t\t\t}\r\n\t\t\telse if (closeTo_e2_3) {\r\n\t\t\t\tif (closeTo_e3_1)\r\n\t\t\t\t\tresult = v3;\r\n\t\t\t\telse\r\n\t\t\t\t\tresult = e2_3;\r\n\t\t\t}\r\n\t\t\telse if (closeTo_e3_1)\r\n\t\t\t\tresult = e3_1;\r\n\t\t\telse\r\n\t\t\t\tresult = polygon;\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t\t// we will use barycentric coordinates\r\n\t\t// see http://en.wikipedia.org/wiki/Barycentric_coordinate_system\r\n\t\t/*\r\n\t\tvar e1_2:QEEdge = polygon.edge;\r\n\t\tvar e2_3:QEEdge = e1_2.nextLeftEdge;\r\n\t\tvar e3_1:QEEdge = e2_3.nextLeftEdge;\r\n\t\t\r\n\t\tvar v1:QEVertex = e1_2.originVertex;\r\n\t\tvar v2:QEVertex = e2_3.originVertex;\r\n\t\tvar v3:QEVertex = e3_1.originVertex;\r\n\t\t\r\n\t\tvar x1:number = v1.pos.x;\r\n\t\tvar y1:number = v1.pos.y;\r\n\t\tvar x2:number = v2.pos.x;\r\n\t\tvar y2:number = v2.pos.y;\r\n\t\tvar x3:number = v3.pos.x;\r\n\t\tvar y3:number = v3.pos.y;\r\n\t\t\r\n\t\tvar coef1:number = ((y2 - y3)*(x - x3) + (x3 - x2)*(y - y3)) / ((y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3));\r\n\t\tvar coef2:number = ((y3 - y1)*(x - x3) + (x1 - x3)*(y - y3)) / ((y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3));\r\n\t\tvar coef3:number = 1 - coef1 - coef2;\r\n\t\t\r\n\t\tconsole.log(\"isInFace:\", coef1, coef2, coef3);\r\n\t\t\r\n\t\tvar result:Object;\r\n\t\tif ( 0 <= coef1 && coef1 <= 1 && 0 <= coef2 && coef2 <= 1 && 0 <= coef3 && coef3 <= 1 )\r\n\t\t{\r\n\t\t\tvar v_v1squaredLength:number = (x1 - x)*(x1 - x) + (y1 - y)*(y1 - y);\r\n\t\t\tvar v_v2squaredLength:number = (x2 - x)*(x2 - x) + (y2 - y)*(y2 - y);\r\n\t\t\tvar v_v3squaredLength:number = (x3 - x)*(x3 - x) + (y3 - y)*(y3 - y);\r\n\t\t\tvar v1_v2squaredLength:number = (x2 - x1)*(x2 - x1) + (y2 - y1)*(y2 - y1);\r\n\t\t\tvar v2_v3squaredLength:number = (x3 - x2)*(x3 - x2) + (y3 - y2)*(y3 - y2);\r\n\t\t\tvar v3_v1squaredLength:number = (x1 - x3)*(x1 - x3) + (y1 - y3)*(y1 - y3);\r\n\t\t\t\r\n\t\t\tvar dot_v_v1v2:number = (x - x1)*(x2 - x1) + (y - y1)*(y2 - y1);\r\n\t\t\tvar dot_v_v2v3:number = (x - x2)*(x3 - x2) + (y - y2)*(y3 - y2);\r\n\t\t\tvar dot_v_v3v1:number = (x - x3)*(x1 - x3) + (y - y3)*(y1 - y3);\r\n\t\t\t\t\r\n\t\t\tvar v_e1_2squaredLength:number = v_v1squaredLength - dot_v_v1v2 * dot_v_v1v2 / v1_v2squaredLength;\r\n\t\t\tvar v_e2_3squaredLength:number = v_v2squaredLength - dot_v_v2v3 * dot_v_v2v3 / v2_v3squaredLength;\r\n\t\t\tvar v_e3_1squaredLength:number = v_v3squaredLength - dot_v_v3v1 * dot_v_v3v1 / v3_v1squaredLength;\r\n\t\t\t\r\n\t\t\tvar closeTo_e1_2:boolean = v_e1_2squaredLength <= QEConstants.EPSILON_SQUARED;\r\n\t\t\tvar closeTo_e2_3:boolean = v_e2_3squaredLength <= QEConstants.EPSILON_SQUARED;\r\n\t\t\tvar closeTo_e3_1:boolean = v_e3_1squaredLength <= QEConstants.EPSILON_SQUARED;\r\n\t\t\t\r\n\t\t\tif ( closeTo_e1_2 )\r\n\t\t\t{\r\n\t\t\t\tif ( closeTo_e3_1 )\r\n\t\t\t\t\tresult = v1;\r\n\t\t\t\telse if ( closeTo_e2_3 )\r\n\t\t\t\t\tresult = v2;\r\n\t\t\t\telse\r\n\t\t\t\t\tresult = e1_2;\r\n\t\t\t}\r\n\t\t\telse if ( closeTo_e2_3 )\r\n\t\t\t{\r\n\t\t\t\tif ( closeTo_e3_1 )\r\n\t\t\t\t\tresult = v3;\r\n\t\t\t\telse\r\n\t\t\t\t\tresult = e2_3;\r\n\t\t\t}\r\n\t\t\telse if ( closeTo_e3_1 )\r\n\t\t\t\tresult = e3_1;\r\n\t\t\telse\r\n\t\t\t\tresult = polygon;\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t\t\r\n\t\t*/\r\n\r\n\r\n\t\t/*\r\n\t\tparametric expression of eLeft:\r\n\t\tx(t1) = vCorner.x + t1*(vLeft.x - vCorner.x)\r\n\t\tx(t1) = vCorner.y + t1*(vLeft.y - vCorner.y)\r\n\t\t\r\n\t\tfor eRight:\r\n\t\tx(t2) = vCorner.x + t2*(vRight.x - vCorner.x)\r\n\t\tx(t2) = vCorner.y + t2*(vRight.y - vCorner.y)\r\n\t\t\r\n\t\t(x, y) position can be <a> expressed linear combination of the 2 previous segments\r\n\t\t\r\n\t\tx = vCorner.x + t1*(vLeft.x - vCorner.x) + t2*(vRight.x - vCorner.x)\r\n\t\ty = vCorner.y + t1*(vLeft.y - vCorner.y) + t2*(vRight.y - vCorner.y)\r\n\t\t\r\n\t\tvalues of t1, t2 and s=t1+t2 will inform us if vToCheck lies in the polygon\r\n\t\t*/\r\n\t\t/*\r\n\t\t// set alias letters\r\n\t\tvar a:number = x;\r\n\t\tvar b:number = y;\r\n\t\tvar c:number = vCorner.pos.x;\r\n\t\tvar d:number = vCorner.pos.y;\r\n\t\tvar e:number = vLeft.pos.x;\r\n\t\tvar f:number = vLeft.pos.y;\r\n\t\tvar g:number = vRight.pos.x;\r\n\t\tvar h:number = vRight.pos.y;\r\n\t\t\r\n\t\t/*\r\n\t\tsystem to solve:\r\n\t\ta = c + t1 (e - c) + t2 (g - c)\r\n\t\tb = d + t1 (f - d) + t2 (h - d)\r\n\t\t*/\r\n\t\t/*\r\n\t\t// giving to wolfram: Solve[{a = c + t1 (e - c) + t2 (g - c) , b = d + t1 (f - d) + t2 (h - d)}, {t1, t2}]\r\n\t\t// we get:\r\n\t\tvar denominator:number = (c*(f - h) + d*(g - e) + e*h - f*g);\r\n\t\tvar t1:number = (a*(h - d) + b*(c - g) - c*h + d*g) / denominator;\r\n\t\tvar t2:number = (a*(f - d) + b*(c - e) - c*f + d*e) / -denominator;\r\n\t\t// then we deduce:\r\n\t\tvar s:number = t1 + t2;\r\n\t\t\r\n\t\tvar result:Object;\r\n\t\t// if inside triangle:\r\n\t\tif (0 <= t1 && t1 <=1 && 0 <= t2 && t2 <=1 && 0 <= s && s <=1)\r\n\t\t{\r\n\t\t\tif (t2*((g - c)*(g - c) + (h - d)*(h - d)) <= QEConstants.EPSILON_SQUARED)\r\n\t\t\t// if near vCorner:\r\n\t\t\tif (((c - a)*(c - a) + (d - b)*(d - b)) <= QEConstants.EPSILON_SQUARED)\r\n\t\t\t\tresult = vCorner;\r\n\t\t\t// if near vLeft:\r\n\t\t\telse if (((e - a)*(e - a) + (f - b)*(f - b)) <= QEConstants.EPSILON_SQUARED)\r\n\t\t\t\tresult = vLeft;\r\n\t\t\t// if near vRight:\r\n\t\t\telse if (((g - a)*(g - a) + (h - b)*(h - b)) <= QEConstants.EPSILON_SQUARED)\r\n\t\t\t\tresult = vRight;\r\n\t\t\telse\r\n\t\t\t\tresult = polygon;\r\n\t\t}\r\n\t\telse\r\n\t\t\tresult = null;\r\n\t\t\r\n\t\treturn result;*/\r\n\t}\r\n\r\n\t// return:\r\n\t// - true if the segment is totally or partially in the triangle\r\n\t// - false if the segment is totally outside the triangle\r\n\tpublic static clipSegmentByTriangle(s1x: number, s1y: number, s2x: number, s2y: number\r\n\t\t, t1x: number, t1y: number, t2x: number, t2y: number, t3x: number, t3y: number\r\n\t\t, pResult1: DDLSPoint2D = null, pResult2: DDLSPoint2D = null): boolean {\r\n\t\tvar side1_1: number;\r\n\t\tvar side1_2: number;\r\n\t\tside1_1 = this.getDirection(t1x, t1y, t2x, t2y, s1x, s1y);\r\n\t\tside1_2 = this.getDirection(t1x, t1y, t2x, t2y, s2x, s2y);\r\n\t\t// if both segment points are on right side\r\n\t\tif (side1_1 <= 0 && side1_2 <= 0)\r\n\t\t\treturn false;\r\n\r\n\t\tvar side2_1: number;\r\n\t\tvar side2_2: number;\r\n\t\tside2_1 = this.getDirection(t2x, t2y, t3x, t3y, s1x, s1y);\r\n\t\tside2_2 = this.getDirection(t2x, t2y, t3x, t3y, s2x, s2y);\r\n\t\t// if both segment points are on right side\r\n\t\tif (side2_1 <= 0 && side2_2 <= 0)\r\n\t\t\treturn false;\r\n\r\n\t\tvar side3_1: number;\r\n\t\tvar side3_2: number;\r\n\t\tside3_1 = this.getDirection(t3x, t3y, t1x, t1y, s1x, s1y);\r\n\t\tside3_2 = this.getDirection(t3x, t3y, t1x, t1y, s2x, s2y);\r\n\t\t// if both segment points are on right side\r\n\t\tif (side3_1 <= 0 && side3_2 <= 0)\r\n\t\t\treturn false;\r\n\r\n\t\t// both segment points are in triangle\r\n\t\tif ((side1_1 >= 0 && side2_1 >= 0 && side3_1 >= 0) && (side1_2 >= 0 && side2_2 >= 0 && side3_2 >= 0)) {\r\n\t\t\tpResult1.x = s1x;\r\n\t\t\tpResult1.y = s1y;\r\n\t\t\tpResult2.x = s2x;\r\n\t\t\tpResult2.y = s2y;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tvar n: number = 0;\r\n\t\t// check intersection between segment and 1st side triangle\r\n\t\tif (this.intersections2segments(s1x, s1y, s2x, s2y, t1x, t1y, t2x, t2y, pResult1, null)) {\r\n\t\t\tn++;\r\n\t\t}\r\n\r\n\t\t// if no intersection with 1st side triangle\r\n\t\tif (n == 0) {\r\n\t\t\t// check intersection between segment and 1st side triangle\r\n\t\t\tif (this.intersections2segments(s1x, s1y, s2x, s2y, t2x, t2y, t3x, t3y, pResult1, null)) {\r\n\t\t\t\tn++;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this.intersections2segments(s1x, s1y, s2x, s2y, t2x, t2y, t3x, t3y, pResult2, null)) {\r\n\t\t\t\t// we check if the segment is not on t2 triangle point\r\n\t\t\t\tif (-DDLSConstants.EPSILON > pResult1.x - pResult2.x\r\n\t\t\t\t\t|| pResult1.x - pResult2.x > DDLSConstants.EPSILON\r\n\t\t\t\t\t|| -DDLSConstants.EPSILON > pResult1.y - pResult2.y\r\n\t\t\t\t\t|| pResult1.y - pResult2.y > DDLSConstants.EPSILON) {\r\n\t\t\t\t\tn++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if intersection neither 1st nor 2nd side triangle\r\n\t\tif (n == 0) {\r\n\t\t\tif (this.intersections2segments(s1x, s1y, s2x, s2y, t3x, t3y, t1x, t1y, pResult1, null)) {\r\n\t\t\t\tn++;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (n == 1) {\r\n\t\t\tif (this.intersections2segments(s1x, s1y, s2x, s2y, t3x, t3y, t1x, t1y, pResult2, null)) {\r\n\t\t\t\tif (-DDLSConstants.EPSILON > pResult1.x - pResult2.x\r\n\t\t\t\t\t|| pResult1.x - pResult2.x > DDLSConstants.EPSILON\r\n\t\t\t\t\t|| -DDLSConstants.EPSILON > pResult1.y - pResult2.y\r\n\t\t\t\t\t|| pResult1.y - pResult2.y > DDLSConstants.EPSILON) {\r\n\t\t\t\t\tn++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if one intersection, we identify the segment point in the triangle\r\n\t\tif (n == 1) {\r\n\t\t\tif (side1_1 >= 0 && side2_1 >= 0 && side3_1 >= 0) {\r\n\t\t\t\tpResult2.x = s1x;\r\n\t\t\t\tpResult2.y = s1y;\r\n\t\t\t}\r\n\t\t\telse if (side1_2 >= 0 && side2_2 >= 0 && side3_2 >= 0) {\r\n\t\t\t\tpResult2.x = s2x;\r\n\t\t\t\tpResult2.y = s2y;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// 1 intersection and none point in triangle : degenerate case\r\n\t\t\t\tn = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (n > 0)\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\t// test if the segment intersects or lies inside the triangle\r\n\tpublic static isSegmentIntersectingTriangle(s1x: number, s1y: number, s2x: number, s2y: number\r\n\t\t, t1x: number, t1y: number, t2x: number, t2y: number, t3x: number, t3y: number): boolean {\r\n\t\t// check sides\r\n\r\n\t\tvar side1_1: number;\r\n\t\tvar side1_2: number;\r\n\t\tside1_1 = this.getDirection(t1x, t1y, t2x, t2y, s1x, s1y);\r\n\t\tside1_2 = this.getDirection(t1x, t1y, t2x, t2y, s2x, s2y);\r\n\t\t// if both segment points are on right side\r\n\t\tif (side1_1 <= 0 && side1_2 <= 0)\r\n\t\t\treturn false;\r\n\r\n\t\tvar side2_1: number;\r\n\t\tvar side2_2: number;\r\n\t\tside2_1 = this.getDirection(t2x, t2y, t3x, t3y, s1x, s1y);\r\n\t\tside2_2 = this.getDirection(t2x, t2y, t3x, t3y, s2x, s2y);\r\n\t\t// if both segment points are on right side\r\n\t\tif (side2_1 <= 0 && side2_2 <= 0)\r\n\t\t\treturn false;\r\n\r\n\t\tvar side3_1: number;\r\n\t\tvar side3_2: number;\r\n\t\tside3_1 = this.getDirection(t3x, t3y, t1x, t1y, s1x, s1y);\r\n\t\tside3_2 = this.getDirection(t3x, t3y, t1x, t1y, s2x, s2y);\r\n\t\t// if both segment points are on right side\r\n\t\tif (side3_1 <= 0 && side3_2 <= 0)\r\n\t\t\treturn false;\r\n\r\n\t\t// if 1st segment point is inside triangle\r\n\t\tif (side1_1 == 1 && side2_1 == 1 && side3_1 == 1)\r\n\t\t\treturn true;\r\n\r\n\t\t// if 2st segment point is inside triangle\r\n\t\tif (side1_1 == 1 && side2_1 == 1 && side3_1 == 1)\r\n\t\t\treturn true;\r\n\r\n\t\tvar side1: number;\r\n\t\tvar side2: number;\r\n\t\t// if both segment points are on different sides of the 1st triangle side\r\n\t\tif ((side1_1 == 1 && side1_2 <= 0) || (side1_1 <= 0 && side1_2 == 1)) {\r\n\t\t\tside1 = this.getDirection(s1x, s1y, s2x, s2y, t1x, t1y);\r\n\t\t\tside2 = this.getDirection(s1x, s1y, s2x, s2y, t2x, t2y);\r\n\t\t\tif (side1 == 1 && side2 <= 0 || side1 <= 0 && side2 == 1) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// if both segment points are on different sides of the 2nd triangle side\r\n\t\tif ((side2_1 == 1 && side2_2 <= 0) || (side2_1 <= 0 && side2_2 == 1)) {\r\n\t\t\tside1 = this.getDirection(s1x, s1y, s2x, s2y, t2x, t2y);\r\n\t\t\tside2 = this.getDirection(s1x, s1y, s2x, s2y, t3x, t3y);\r\n\t\t\tif (side1 == 1 && side2 <= 0 || side1 <= 0 && side2 == 1) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// if both segment points are on different sides of the 3rd triangle side\r\n\t\tif ((side3_1 == 1 && side3_2 <= 0) || (side3_1 <= 0 && side3_2 == 1)) {\r\n\t\t\tside1 = this.getDirection(s1x, s1y, s2x, s2y, t3x, t3y);\r\n\t\t\tside2 = this.getDirection(s1x, s1y, s2x, s2y, t1x, t1y);\r\n\t\t\tif (side1 == 1 && side2 <= 0 || side1 <= 0 && side2 == 1) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate static __circumcenter: DDLSPoint2D = new DDLSPoint2D();\r\n\tpublic static isDelaunay(edge: DDLSEdge): boolean {\r\n\t\tvar vLeft: DDLSVertex = edge.originVertex;\r\n\t\tvar vRight: DDLSVertex = edge.destinationVertex;\r\n\t\tvar vCorner: DDLSVertex = edge.nextLeftEdge.destinationVertex;\r\n\t\tvar vOpposite: DDLSVertex = edge.nextRightEdge.destinationVertex;\r\n\t\t/*\r\n\t\t// middle points\r\n\t\tvar vMidLeft:Point = new Point();\r\n\t\tvMidLeft.x = (vCorner.pos.x + vLeft.pos.x) / 2;\r\n\t\tvMidLeft.y = (vCorner.pos.y + vLeft.pos.y) / 2;\r\n\t\t\r\n\t\tvar vMidRight:Point = new Point();\r\n\t\tvMidRight.x = (vCorner.pos.x + vRight.pos.x) / 2;\r\n\t\tvMidRight.y = (vCorner.pos.y + vRight.pos.y) / 2;\r\n\t\t*/\r\n\t\t/*\r\n\t\t- parametric expression of orthogonal segments\r\n\t\tsegOrthoLeftX(t1) = vMidLeft.x + t1 * (vLeft.y - vCorner.y)\r\n\t\tsegOrthoLeftY(t1) = vMidLeft.y - t1 * (vLeft.x - vCorner.x)\r\n\t\t\r\n\t\tsegOrthoRightX(t2) = vMidRight.x + t2 * (vRight.y - vCorner.y)\r\n\t\tsegOrthoRightY(t2) = vMidRight.y - t2 * (vRight.x - vCorner.x)\r\n\t\t\r\n\t\t- the center of circle passing by vLeft, vRight, vCorner will lead to:\r\n\t\tsegOrthoLeftX(t1) = segOrthoRightX(t2)\r\n\t\tsegOrthoLeftY(t1) = segOrthoRightY(t2)\r\n\t\t*/\r\n\t\t/*\r\n\t\t// set alias letters\r\n\t\tvar a:number = vMidLeft.x;\r\n\t\tvar b:number = vLeft.pos.y;\r\n\t\tvar c:number = vCorner.pos.y;\r\n\t\tvar d:number = vMidRight.x;\r\n\t\tvar e:number = vRight.pos.y;\r\n\t\tvar f:number = vCorner.pos.y;\r\n\t\tvar g:number = vMidLeft.y;\r\n\t\tvar h:number = vLeft.pos.x;\r\n\t\tvar i:number = vCorner.pos.x;\r\n\t\tvar j:number = vMidRight.y;\r\n\t\tvar k:number = vRight.pos.x;\r\n\t\tvar l:number = vCorner.pos.x;\r\n\t\t*/\r\n\t\t/*\r\n\t\tsystem to solve:\r\n\t\ta + t1 (b - c) = d + t2 (e - f)\r\n\t\tg - t1 (h - i) = j - t2 (k - l)\r\n\t\t*/\r\n\r\n\t\t//giving to wolfram: Solve[{a + t1 (b - c) = d + t2 (e - f) , g - t1 (h - i) = j - t2 (k - l)}, {t1, t2}]\r\n\t\t//we get:\r\n\t\t//var t1:number = (-(a-d)*(k-l) + e*(j-g) + f*(g-j)) / ((b-c)*(k-l) + e*(i-h) + f*(h-i));\r\n\t\t/*\r\n\t\t__barycenter.x = a + t1 * (b - c);\r\n\t\t__barycenter.y = g - t1 * (h - i);\r\n\t\t*/\r\n\t\tthis.getCircumcenter(vCorner.pos.x, vCorner.pos.y, vLeft.pos.x, vLeft.pos.y, vRight.pos.x, vRight.pos.y, this.__circumcenter);\r\n\r\n\t\t// check if the opposite vertex lies outside the circle\r\n\t\tvar squaredRadius: number = (vCorner.pos.x - this.__circumcenter.x) * (vCorner.pos.x - this.__circumcenter.x) + (vCorner.pos.y - this.__circumcenter.y) * (vCorner.pos.y - this.__circumcenter.y);\r\n\t\tvar squaredDistance: number = (vOpposite.pos.x - this.__circumcenter.x) * (vOpposite.pos.x - this.__circumcenter.x) + (vOpposite.pos.y - this.__circumcenter.y) * (vOpposite.pos.y - this.__circumcenter.y);\r\n\r\n\t\treturn squaredDistance >= squaredRadius;\r\n\t}\r\n\r\n\tpublic static getCircumcenter(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, result: DDLSPoint2D = null): DDLSPoint2D {\r\n\t\tif (!result) {\r\n\t\t\tresult = new DDLSPoint2D();\r\n\t\t}\r\n\r\n\t\t// middle points\r\n\t\tvar m1: number = (x1 + x2) / 2;\r\n\t\tvar m2: number = (y1 + y2) / 2;\r\n\t\tvar m3: number = (x1 + x3) / 2;\r\n\t\tvar m4: number = (y1 + y3) / 2;\r\n\t\t/*\r\n\t\t- parametric expression of orthogonal segments\r\n\t\tsegOrtho1X(t1) = m1 + t1 * (y2 - y1)\r\n\t\tsegOrtho1Y(t1) = m2 - t1 * (x2 - x1)\r\n\t\t\r\n\t\tsegOrtho2X(t2) = m3 + t2 * (y3 - y1)\r\n\t\tsegOrtho2Y(t2) = m4 - t2 * (x3 - x1)\r\n\t\t\r\n\t\t- the center of circle passing by vLeft, vRight, vCorner will lead to:\r\n\t\tsegOrtho1X(t1) = segOrtho2X(t2)\r\n\t\tsegOrtho1Y(t1) = segOrtho2Y(t2)\r\n\t\t\r\n\t\tsystem to solve:\r\n\t\tm1 + t1 (y2 - y1) = m3 + t2 (y3 - y1)\r\n\t\tm2 - t1 (x2 - x1) = m4 - t2 (x3 - x1)\r\n\t\t\r\n\t\tgiving to wolfram: Solve[{m1 + t1 (y2 - y1) = m3 + t2 (y3 - y1) , m2 - t1 (x2 - x1) = m4 - t2 (x3 - x1)}, {t1, t2}]\r\n\t\twe get:any*/\r\n\t\tvar t1: number = (m1 * (x1 - x3) + (m2 - m4) * (y1 - y3) + m3 * (x3 - x1)) / (x1 * (y3 - y2) + x2 * (y1 - y3) + x3 * (y2 - y1));\r\n\r\n\t\tresult.x = m1 + t1 * (y2 - y1);\r\n\t\tresult.y = m2 - t1 * (x2 - x1);\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic static intersections2segments(s1p1x: number, s1p1y: number, s1p2x: number, s1p2y: number\r\n\t\t, s2p1x: number, s2p1y: number, s2p2x: number, s2p2y: number\r\n\t\t, posIntersection: DDLSPoint2D = null, paramIntersection: number[] = null\r\n\t\t, infiniteLineMode: boolean = false): boolean {\r\n\t\tvar t1: number;\r\n\t\tvar t2: number;\r\n\r\n\t\tvar result: boolean;\r\n\t\tvar divisor: number = (s1p1x - s1p2x) * (s2p1y - s2p2y) + (s1p2y - s1p1y) * (s2p1x - s2p2x);\r\n\t\tif (divisor == 0) {\r\n\t\t\tresult = false; // parallel case, no intersection\r\n\t\t}\r\n\t\telse {\r\n\t\t\tresult = true;\r\n\r\n\t\t\tif (!infiniteLineMode || posIntersection || paramIntersection) {\r\n\t\t\t\t// if we consider <finite> edges segments, we must check t1 and t2 values\r\n\t\t\t\tt1 = (s1p1x * (s2p1y - s2p2y) + s1p1y * (s2p2x - s2p1x) + s2p1x * s2p2y - s2p1y * s2p2x) / divisor;\r\n\t\t\t\tt2 = (s1p1x * (s2p1y - s1p2y) + s1p1y * (s1p2x - s2p1x) - s1p2x * s2p1y + s1p2y * s2p1x) / divisor;\r\n\t\t\t\tif (!infiniteLineMode && !(0 <= t1 && t1 <= 1 && 0 <= t2 && t2 <= 1))\r\n\t\t\t\t\tresult = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (result) {\r\n\t\t\tif (posIntersection) {\r\n\t\t\t\tposIntersection.x = s1p1x + t1 * (s1p2x - s1p1x);\r\n\t\t\t\tposIntersection.y = s1p1y + t1 * (s1p2y - s1p1y);\r\n\t\t\t}\r\n\t\t\tif (paramIntersection) {\r\n\t\t\t\tparamIntersection.push(t1, t2);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic static intersections2edges(edge1: DDLSEdge, edge2: DDLSEdge\r\n\t\t, posIntersection: DDLSPoint2D = null, paramIntersection: number[] = null\r\n\t\t, infiniteLineMode: boolean = false): boolean {\r\n\t\treturn this.intersections2segments(edge1.originVertex.pos.x, edge1.originVertex.pos.y\r\n\t\t\t, edge1.destinationVertex.pos.x, edge1.destinationVertex.pos.y\r\n\t\t\t, edge2.originVertex.pos.x, edge2.originVertex.pos.y\r\n\t\t\t, edge2.destinationVertex.pos.x, edge2.destinationVertex.pos.y\r\n\t\t\t, posIntersection, paramIntersection, infiniteLineMode);\r\n\t}\r\n\r\n\t// a edge is convex if the polygon formed by the 2 faces at left and right of this edge is convex\r\n\tpublic static isConvex(edge: DDLSEdge): boolean {\r\n\t\tvar result: boolean = true;\r\n\r\n\t\tvar eLeft: DDLSEdge;\r\n\t\tvar vRight: DDLSVertex;\r\n\r\n\t\teLeft = edge.nextLeftEdge.oppositeEdge;\r\n\t\tvRight = edge.nextRightEdge.destinationVertex;\r\n\t\tif (this.getRelativePosition(vRight.pos.x, vRight.pos.y, eLeft) != -1) {\r\n\t\t\tresult = false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\teLeft = edge.prevRightEdge;\r\n\t\t\tvRight = edge.prevLeftEdge.originVertex;\r\n\t\t\tif (this.getRelativePosition(vRight.pos.x, vRight.pos.y, eLeft) != -1) {\r\n\t\t\t\tresult = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result\r\n\t}\r\n\r\n\tpublic static projectOrthogonaly(vertexPos: DDLSPoint2D, edge: DDLSEdge): void {\r\n\t\t// parametric expression of edge\r\n\t\t// x(t1) = edge.originVertex.pos.x + t1*(edge.destinationVertex.pos.x - edge.originVertex.pos.x)\r\n\t\t// y(t1) = edge.originVertex.pos.y + t1*(edge.destinationVertex.pos.y - edge.originVertex.pos.y)\r\n\r\n\t\t// parametric expression of the segment orthogonal to edge and lying by vertex\r\n\t\t// x(t2) = vertexPos.x + t2*(edge.destinationVertex.pos.y - edge.originVertex.pos.y)\r\n\t\t// y(t2) = vertexPos.y - t2*(edge.destinationVertex.pos.x - edge.originVertex.pos.x)\r\n\r\n\t\t// the orthogonal projection of vertex on edge will lead to:\r\n\t\t// x(t1) = x(t2)\r\n\t\t// y(t1) = y(t2)\r\n\r\n\t\t// set alias letters\r\n\t\tvar a: number = edge.originVertex.pos.x;\r\n\t\tvar b: number = edge.originVertex.pos.y;\r\n\t\tvar c: number = edge.destinationVertex.pos.x;\r\n\t\tvar d: number = edge.destinationVertex.pos.y;\r\n\t\tvar e: number = vertexPos.x;\r\n\t\tvar f: number = vertexPos.y;\r\n\r\n\t\t// system to solve:\r\n\t\t// a + t1 (c - a) = e + t2 (d - b)\r\n\t\t// b + t1 (d - b) = f - t2 (c - a)\r\n\r\n\t\t// solution:\r\n\t\tvar t1: number = (a * a - a * c - a * e + b * b - b * d - b * f + c * e + d * f) / (a * a - 2 * a * c + b * b - 2 * b * d + c * c + d * d);\r\n\r\n\t\t// set position:\r\n\t\tvertexPos.x = a + t1 * (c - a);\r\n\t\tvertexPos.y = b + t1 * (d - b);\r\n\t}\r\n\r\n\tpublic static projectOrthogonalyOnSegment(px: number, py: number, sp1x: number, sp1y: number, sp2x: number, sp2y: number, result: DDLSPoint2D): void {\r\n\t\t// set alias letters\r\n\t\tvar a: number = sp1x;\r\n\t\tvar b: number = sp1y;\r\n\t\tvar c: number = sp2x;\r\n\t\tvar d: number = sp2y;\r\n\t\tvar e: number = px;\r\n\t\tvar f: number = py;\r\n\r\n\t\t// system to solve:\r\n\t\t// a + t1 (c - a) = e + t2 (d - b)\r\n\t\t// b + t1 (d - b) = f - t2 (c - a)\r\n\r\n\t\t// solution:\r\n\t\tvar t1: number = (a * a - a * c - a * e + b * b - b * d - b * f + c * e + d * f) / (a * a - 2 * a * c + b * b - 2 * b * d + c * c + d * d);\r\n\r\n\t\t// set position:\r\n\t\tresult.x = a + t1 * (c - a);\r\n\t\tresult.y = b + t1 * (d - b);\r\n\t}\r\n\r\n\t// fill the result vector with 4 elements, with the form:\r\n\t// [intersect0.x, intersect0.y, intersect1.x, intersect1.y]\r\n\t// empty if no intersection\r\n\tpublic static intersections2Circles(cx1: number, cy1: number, r1: number, cx2: number, cy2: number, r2: number, result: number[] = null): boolean {\r\n\t\tvar distRadiusSQRD: number = ((cx2 - cx1) * (cx2 - cx1) + (cy2 - cy1) * (cy2 - cy1));\r\n\r\n\t\tif ((cx1 != cx2 || cy1 != cy2)\r\n\t\t\t&& distRadiusSQRD <= ((r1 + r2) * (r1 + r2))\r\n\t\t\t&& distRadiusSQRD >= ((r1 - r2) * (r1 - r2))) {\r\n\t\t\tvar transcendPart: number = Math.sqrt(((r1 + r2) * (r1 + r2) - distRadiusSQRD)\r\n\t\t\t\t* (distRadiusSQRD - (r2 - r1) * (r2 - r1)));\r\n\t\t\tvar xFirstPart: number = (cx1 + cx2) / 2 + (cx2 - cx1) * (r1 * r1 - r2 * r2) / (2 * distRadiusSQRD);\r\n\t\t\tvar yFirstPart: number = (cy1 + cy2) / 2 + (cy2 - cy1) * (r1 * r1 - r2 * r2) / (2 * distRadiusSQRD);\r\n\t\t\tvar xFactor: number = (cy2 - cy1) / (2 * distRadiusSQRD);\r\n\t\t\tvar yFactor: number = (cx2 - cx1) / (2 * distRadiusSQRD);\r\n\r\n\t\t\tif (result) {\r\n\t\t\t\tresult.push(xFirstPart + xFactor * transcendPart\r\n\t\t\t\t\t, yFirstPart - yFactor * transcendPart\r\n\t\t\t\t\t, xFirstPart - xFactor * transcendPart\r\n\t\t\t\t\t, yFirstPart + yFactor * transcendPart);\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\tpublic static intersectionsSegmentCircle(p0x: number, p0y: number\r\n\t\t, p1x: number, p1y: number\r\n\t\t, cx: number, cy: number, r: number\r\n\t\t, result: number[] = null): boolean {\r\n\r\n\t\tvar p0xSQD: number = p0x * p0x;\r\n\t\tvar p0ySQD: number = p0y * p0y;\r\n\t\tvar a: number = p1y * p1y - 2 * p1y * p0y + p0ySQD + p1x * p1x - 2 * p1x * p0x + p0xSQD;\r\n\t\tvar b: number = 2 * p0y * cy - 2 * p0xSQD + 2 * p1y * p0y - 2 * p0ySQD + 2 * p1x * p0x - 2 * p1x * cx + 2 * p0x * cx - 2 * p1y * cy;\r\n\t\tvar c: number = p0ySQD + cy * cy + cx * cx - 2 * p0y * cy - 2 * p0x * cx + p0xSQD - r * r;\r\n\t\tvar delta: number = b * b - 4 * a * c;\r\n\t\tvar deltaSQRT: number;\r\n\r\n\t\tvar t0: number;\r\n\t\tvar t1: number;\r\n\t\tif (delta < 0) {\r\n\t\t\t// no solution\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (delta == 0) {\r\n\t\t\t// unique solution\r\n\t\t\tt0 = - b / (2 * a);\r\n\t\t\tif (t0 < 0 || t0 > 1)\r\n\t\t\t\treturn false;\r\n\t\t\t// we return a 3 elements array, under the form:\r\n\t\t\t//  [intersect0.x, intersect0.y, t0]\r\n\t\t\tif (result)\r\n\t\t\t\tresult.push(p0x + t0 * (p1x - p0x), p0y + t0 * (p1y - p0y), t0);\r\n\r\n\t\t\treturn true\r\n\t\t}\r\n\t\telse // (delta > 0)\r\n\t\t{\r\n\t\t\tdeltaSQRT = Math.sqrt(delta);\r\n\t\t\tt0 = (- b + deltaSQRT) / (2 * a);\r\n\t\t\tt1 = (- b - deltaSQRT) / (2 * a);\r\n\t\t\t// we return a n elements array, under the form:\r\n\t\t\t//  [intersect0.x, intersect0.y, t0\r\n\t\t\t//\t, intersect1.x, intersect1.y, t1]\r\n\t\t\tvar intersecting: boolean = false;\r\n\t\t\tif (0 <= t0 && t0 <= 1) {\r\n\t\t\t\tif (result)\r\n\t\t\t\t\tresult.push(p0x + t0 * (p1x - p0x), p0y + t0 * (p1y - p0y), t0);\r\n\t\t\t\tintersecting = true;\r\n\t\t\t}\r\n\t\t\tif (0 <= t1 && t1 <= 1) {\r\n\t\t\t\tif (result)\r\n\t\t\t\t\tresult.push(p0x + t1 * (p1x - p0x), p0y + t1 * (p1y - p0y), t1);\r\n\t\t\t\tintersecting = true;\r\n\t\t\t}\r\n\r\n\t\t\treturn intersecting;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static intersectionsLineCircle(p0x: number, p0y: number\r\n\t\t, p1x: number, p1y: number\r\n\t\t, cx: number, cy: number, r: number\r\n\t\t, result: number[]): boolean {\r\n\t\tvar p0xSQD: number = p0x * p0x;\r\n\t\tvar p0ySQD: number = p0y * p0y;\r\n\t\tvar a: number = p1y * p1y - 2 * p1y * p0y + p0ySQD + p1x * p1x - 2 * p1x * p0x + p0xSQD;\r\n\t\tvar b: number = 2 * p0y * cy - 2 * p0xSQD + 2 * p1y * p0y - 2 * p0ySQD + 2 * p1x * p0x - 2 * p1x * cx + 2 * p0x * cx - 2 * p1y * cy;\r\n\t\tvar c: number = p0ySQD + cy * cy + cx * cx - 2 * p0y * cy - 2 * p0x * cx + p0xSQD - r * r;\r\n\t\tvar delta: number = b * b - 4 * a * c;\r\n\t\tvar deltaSQRT: number;\r\n\r\n\t\tvar t0: number;\r\n\t\tvar t1: number;\r\n\t\tif (delta < 0) {\r\n\t\t\t// no solution\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (delta == 0) {\r\n\t\t\t// unique solution\r\n\t\t\tt0 = - b / (2 * a);\r\n\t\t\t// we return a 3 elements array, under the form:\r\n\t\t\t//  [intersect0.x, intersect0.y, t0]\r\n\t\t\tresult.push(p0x + t0 * (p1x - p0x), p0y + t0 * (p1y - p0y), t0);\r\n\t\t}\r\n\t\telse if (delta > 0) {\r\n\t\t\tdeltaSQRT = Math.sqrt(delta);\r\n\t\t\tt0 = (- b + deltaSQRT) / (2 * a);\r\n\t\t\tt1 = (- b - deltaSQRT) / (2 * a);\r\n\t\t\t// we return a 6 elements array, under the form:\r\n\t\t\t//  [intersect0.x, intersect0.y, t0\r\n\t\t\t//\t, intersect1.x, intersect1.y, t1]\r\n\t\t\tresult.push(p0x + t0 * (p1x - p0x), p0y + t0 * (p1y - p0y), t0, p0x + t1 * (p1x - p0x), p0y + t1 * (p1y - p0y), t1);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// based on intersections2Circles method\r\n\t// fill the result vector with 4 elements, with the form:\r\n\t// [point_tangent1.x, point_tangent1.y, point_tangent2.x, point_tangent2.y]\r\n\t// empty if no tangent\r\n\tpublic static tangentsPointToCircle(px: number, py: number, cx: number, cy: number, r: number, result: number[]): void {\r\n\t\tvar c2x: number = (px + cx) / 2;\r\n\t\tvar c2y: number = (py + cy) / 2;\r\n\t\tvar r2: number = 0.5 * Math.sqrt((px - cx) * (px - cx) + (py - cy) * (py - cy));\r\n\r\n\t\tthis.intersections2Circles(c2x, c2y, r2, cx, cy, r, result);\r\n\t}\r\n\r\n\t// <!!!> CIRCLES MUST HAVE SAME RADIUS\r\n\tpublic static tangentsCrossCircleToCircle(r: number, c1x: number, c1y: number, c2x: number, c2y: number, result: number[]): boolean {\r\n\t\tvar distance: number = Math.sqrt((c1x - c2x) * (c1x - c2x) + (c1y - c2y) * (c1y - c2y));\r\n\r\n\t\t// new circle\r\n\t\tvar radius: number = distance / 4;\r\n\t\tvar centerX: number = c1x + (c2x - c1x) / 4;\r\n\t\tvar centerY: number = c1y + (c2y - c1y) / 4;\r\n\r\n\t\tif (this.intersections2Circles(c1x, c1y, r, centerX, centerY, radius, result)) {\r\n\t\t\tvar t1x: number = result[0];\r\n\t\t\tvar t1y: number = result[1];\r\n\t\t\tvar t2x: number = result[2];\r\n\t\t\tvar t2y: number = result[3];\r\n\r\n\t\t\tvar midX: number = (c1x + c2x) / 2;\r\n\t\t\tvar midY: number = (c1y + c2y) / 2;\r\n\t\t\tvar dotProd: number = (t1x - midX) * (c2y - c1y) + (t1y - midY) * (- c2x + c1x);\r\n\t\t\tvar tproj: number = dotProd / (distance * distance);\r\n\t\t\tvar projx: number = midX + tproj * (c2y - c1y);\r\n\t\t\tvar projy: number = midY - tproj * (c2x - c1x);\r\n\r\n\r\n\t\t\tvar t4x: number = 2 * projx - t1x;\r\n\t\t\tvar t4y: number = 2 * projy - t1y;\r\n\r\n\t\t\tvar t3x: number = t4x + t2x - t1x;\r\n\t\t\tvar t3y: number = t2y + t4y - t1y;\r\n\r\n\t\t\tresult.push(t3x, t3y, t4x, t4y);\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// no tangent because cicles are intersecting\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t// <!!!> CIRCLES MUST HAVE SAME RADIUS\r\n\tpublic static tangentsParalCircleToCircle(r: number, c1x: number, c1y: number, c2x: number, c2y: number, result: number[]): void {\r\n\t\tvar distance: number = Math.sqrt((c1x - c2x) * (c1x - c2x) + (c1y - c2y) * (c1y - c2y));\r\n\t\tvar t1x: number = c1x + r * (c2y - c1y) / distance;\r\n\t\tvar t1y: number = c1y + r * (- c2x + c1x) / distance;\r\n\t\tvar t2x: number = 2 * c1x - t1x;\r\n\t\tvar t2y: number = 2 * c1y - t1y;\r\n\t\tvar t3x: number = t2x + c2x - c1x;\r\n\t\tvar t3y: number = t2y + c2y - c1y;\r\n\t\tvar t4x: number = t1x + c2x - c1x;\r\n\t\tvar t4y: number = t1y + c2y - c1y\r\n\t\tresult.push(t1x, t1y, t2x, t2y, t3x, t3y, t4x, t4y);\r\n\t}\r\n\r\n\t// squared distance from point p to infinite line (a, b)\r\n\tpublic static distanceSquaredPointToLine(px: number, py: number, ax: number, ay: number, bx: number, by: number): number {\r\n\t\tvar a_b_squaredLength: number = (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\r\n\t\tvar dotProduct: number = (px - ax) * (bx - ax) + (py - ay) * (by - ay);\r\n\t\tvar p_a_squaredLength: number = (ax - px) * (ax - px) + (ay - py) * (ay - py);\r\n\t\treturn p_a_squaredLength - dotProduct * dotProduct / a_b_squaredLength;\r\n\t}\r\n\r\n\t// squared distance from point p to finite segment [a, b]\r\n\tpublic static distanceSquaredPointToSegment(px: number, py: number, ax: number, ay: number, bx: number, by: number): number {\r\n\t\tvar a_b_squaredLength: number = (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\r\n\t\tvar dotProduct: number = ((px - ax) * (bx - ax) + (py - ay) * (by - ay)) / a_b_squaredLength;\r\n\t\tif (dotProduct < 0) {\r\n\t\t\treturn (px - ax) * (px - ax) + (py - ay) * (py - ay);\r\n\t\t}\r\n\t\telse if (dotProduct <= 1) {\r\n\t\t\tvar p_a_squaredLength: number = (ax - px) * (ax - px) + (ay - py) * (ay - py);\r\n\t\t\treturn p_a_squaredLength - dotProduct * dotProduct * a_b_squaredLength;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn (px - bx) * (px - bx) + (py - by) * (py - by);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static distanceSquaredVertexToEdge(vertex: DDLSVertex, edge: DDLSEdge): number {\r\n\t\treturn this.distanceSquaredPointToSegment(vertex.pos.x, vertex.pos.y\r\n\t\t\t, edge.originVertex.pos.x, edge.originVertex.pos.y\r\n\t\t\t, edge.destinationVertex.pos.x, edge.destinationVertex.pos.y);\r\n\t}\r\n\r\n\tpublic static pathLength(path: number[]): number {\r\n\t\tvar sumDistance: number = 0;\r\n\t\tvar fromX: number = path[0];\r\n\t\tvar fromY: number = path[1];\r\n\t\tvar nextX: number;\r\n\t\tvar nextY: number;\r\n\t\tvar x: number;\r\n\t\tvar y: number;\r\n\t\tvar distance: number;\r\n\t\tfor (var i: number = 2; i < path.length; i += 2) {\r\n\t\t\tnextX = path[i];\r\n\t\t\tnextY = path[i + 1];\r\n\t\t\tx = nextX - fromX;\r\n\t\t\ty = nextY - fromY;\r\n\t\t\tdistance = Math.sqrt(x * x + y * y);\r\n\t\t\tsumDistance += distance;\r\n\t\t\tfromX = nextX;\r\n\t\t\tfromY = nextY;\r\n\t\t}\r\n\r\n\t\treturn sumDistance;\r\n\t}\r\n}", "import { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSFace } from \"../data/DDLSFace\";\r\nimport { DDLSMesh } from \"../data/DDLSMesh\";\r\nimport { DDLSVertex } from \"../data/DDLSVertex\";\r\nimport { DDLSGeom2D } from \"../data/math/DDLSGeom2D\";\r\nimport { DDLSPoint2D } from \"../data/math/DDLSPoint2D\";\r\nimport { IteratorFromFaceToInnerEdges } from \"../iterators/IteratorFromFaceToInnerEdges\";\r\n\r\n\r\nexport class DDLSAStar\r\n{\r\n\t\r\n\tprivate _mesh:DDLSMesh;\r\n\t\r\n\t\r\n\tprivate __closedFaces:any;\r\n\tprivate __sortedOpenedFaces:DDLSFace[];\r\n\tprivate __openedFaces:any;\r\n\tprivate __entryEdges:any;\r\n\tprivate __entryX:any;\r\n\tprivate __entryY:any;\r\n\tprivate __scoreF:any;\r\n\tprivate __scoreG:any;\r\n\tprivate __scoreH:any;\r\n\tprivate __predecessor:any;\r\n\t\r\n\tprivate __iterEdge:IteratorFromFaceToInnerEdges;\r\n\t\r\n\tprivate _radius:number;\r\n\tprivate _radiusSquared:number;\r\n\tprivate _diameter:number;\r\n\tprivate _diameterSquared:number;\r\n\t\r\n\tconstructor()\r\n\t{\r\n\t\tthis.__iterEdge = new IteratorFromFaceToInnerEdges();\r\n\t}\r\n\t\r\n\tpublic dispose():void\r\n\t{\r\n\t\tthis._mesh = null;\r\n\t\t\r\n\t\t\tthis.__closedFaces = null;\r\n\t\tthis.__sortedOpenedFaces = null;\r\n\t\tthis.__openedFaces = null;\r\n\t\tthis.__entryEdges = null;\r\n\t\tthis.__entryX = null;\r\n\t\tthis.__entryY = null;\r\n\t\tthis.__scoreF = null;\r\n\t\tthis.__scoreG = null;\r\n\t\tthis.__scoreH = null;\r\n\t\tthis.__predecessor = null;\r\n\t}\r\n\t\r\n\tpublic get radius():number\r\n\t{\r\n\t\treturn this._radius;\r\n\t}\r\n\r\n\tpublic set radius(value:number)\r\n\t{\r\n\t\tthis._radius = value;\r\n\t\tthis._radiusSquared = this._radius*this._radius;\r\n\t\tthis._diameter = this._radius*2;\r\n\t\tthis._diameterSquared = this._diameter*this._diameter;\r\n\t}\r\n\r\n\tpublic set mesh(value:DDLSMesh)\r\n\t{\r\n\t\tthis._mesh = value;\r\n\t}\r\n\t\r\n\tprivate __fromFace:DDLSFace;\r\n\tprivate __toFace:DDLSFace;\r\n\tprivate __curFace:DDLSFace;\r\n\tpublic findPath(fromX:number, fromY:number, toX:number, toY:number\r\n\t\t\t\t\t\t\t, resultListFaces:DDLSFace[]\r\n\t\t\t\t\t\t\t, resultListEdges:DDLSEdge[]):void\r\n\t{\r\n\t\t//console.log(\"findPath\");\r\n\t\tthis.__closedFaces = {};\r\n\t\tthis.__sortedOpenedFaces = [];\r\n\t\tthis.__openedFaces = {};\r\n\t\tthis.__entryEdges = {};\r\n\t\tthis.__entryX = {};\r\n\t\tthis.__entryY = {};\r\n\t\tthis.__scoreF = {};\r\n\t\tthis.__scoreG = {};\r\n\t\tthis.__scoreH = {};\r\n\t\tthis.__predecessor = {};\r\n\t\t\r\n\t\tvar loc:Object;\r\n\t\tvar locEdge:DDLSEdge;\r\n\t\tvar locVertex:DDLSVertex;\r\n\t\tvar distance:number;\r\n\t\tvar p1:DDLSPoint2D;\r\n\t\tvar p2:DDLSPoint2D;\r\n\t\tvar p3:DDLSPoint2D;\r\n\t\t//\r\n\t\tloc = DDLSGeom2D.locatePosition(fromX, fromY, this._mesh);\r\n\t\tlocVertex = loc instanceof DDLSVertex?loc:null;\r\n\t\tif ( locVertex )\r\n\t\t{\r\n\t\t\t// vertex are always in constraint, so we abort\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if ( (locEdge = loc instanceof DDLSEdge?loc:null) )\r\n\t\t{\r\n\t\t\t// if the vertex lies on a constrained edge, we abort\r\n\t\t\tif (locEdge.isConstrained)\r\n\t\t\t\treturn;\r\n\t\t\t\r\n\t\t\tthis.__fromFace = locEdge.leftFace;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.__fromFace = loc instanceof DDLSFace?loc:null;\r\n\t\t}\r\n\t\t//\r\n\t\tloc = DDLSGeom2D.locatePosition(toX, toY, this._mesh);\r\n\t\tlocVertex = loc instanceof DDLSVertex?loc:null;\r\n\t\tif ( locVertex )\r\n\t\t\tthis.__toFace = locVertex.edge.leftFace;\r\n\t\telse if ( (locEdge = loc instanceof DDLSEdge?loc:null) )\r\n\t\t\tthis.__toFace = locEdge.leftFace;\r\n\t\telse\r\n\t\t\tthis.__toFace = loc instanceof DDLSFace?loc:null;\r\n\t\t\r\n\t\t/*this.__fromFace.colorDebug = 0xFF0000;\r\n\t\tthis.__toFace.colorDebug = 0xFF0000;\r\n\t\tconsole.log( \"from face:\", this.__fromFace );\r\n\t\tconsole.log( \"to face:\", this.__toFace );*/\r\n\t\t\r\n\t\tthis.__sortedOpenedFaces.push(this.__fromFace);\r\n\t\tthis.__entryEdges[this.__fromFace.id] = null;\r\n\t\tthis.__entryX[this.__fromFace.id] = fromX;\r\n\t\tthis.__entryY[this.__fromFace.id] = fromY;\r\n\t\tthis.__scoreG[this.__fromFace.id] = 0;\r\n\t\tthis.__scoreH[this.__fromFace.id] = Math.sqrt((toX - fromX)*(toX - fromX) + (toY - fromY)*(toY - fromY));\r\n\t\tthis.__scoreF[this.__fromFace.id] = this.__scoreH[this.__fromFace.id] + this.__scoreG[this.__fromFace.id];\r\n\t\t\r\n\t\tvar innerEdge:DDLSEdge;\r\n\t\tvar neighbourFace:DDLSFace;\r\n\t\tvar f:number;\r\n\t\tvar g:number;\r\n\t\tvar h:number;\r\n\t\tvar fromPoint:DDLSPoint2D = new DDLSPoint2D();\r\n\t\tvar entryPoint:DDLSPoint2D = new DDLSPoint2D();\r\n\t\tvar distancePoint:DDLSPoint2D = new DDLSPoint2D();\r\n\t\tvar fillDatas:boolean;\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\t// no path found\r\n\t\t\tif (this.__sortedOpenedFaces.length == 0)\r\n\t\t\t{\r\n\t\t\t\t//console.log(\"DDLSAStar no path found\");\r\n\t\t\t\tthis.__curFace = null;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// we reached the target face\r\n\t\t\tthis.__curFace = this.__sortedOpenedFaces.pop();\r\n\t\t\tif (this.__curFace == this.__toFace)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// we continue the search\r\n\t\t\tthis.__iterEdge.fromFace = this.__curFace;\r\n\t\t\tinnerEdge = this.__iterEdge.next();\r\n\t\t\twhile ( innerEdge )\r\n\t\t\t{\r\n\t\t\t\tif (innerEdge.isConstrained)\r\n\t\t\t\t{\r\n\t\t\t\t\tinnerEdge = this.__iterEdge.next();\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tneighbourFace = innerEdge.rightFace;\r\n\t\t\t\tif (! this.__closedFaces[neighbourFace.id] )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( this.__curFace != this.__fromFace && this._radius > 0 && ! this.isWalkableByRadius(this.__entryEdges[this.__curFace.id], this.__curFace, innerEdge))\r\n\t\t\t\t\t{\r\n//\t\t\t\t\t\t\tconsole.log(\"- NOT WALKABLE -\");\r\n//\t\t\t\t\t\t\tconsole.log( \"from\", DDLSEdge(this.__entryEdges[this.__curFace]).originVertex.id, DDLSEdge(this.__entryEdges[this.__curFace]).destinationVertex.id );\r\n//\t\t\t\t\t\t\tconsole.log( \"to\", innerEdge.originVertex.id, innerEdge.destinationVertex.id );\r\n//\t\t\t\t\t\t\tconsole.log(\"----------------\");\r\n\t\t\t\t\t\tinnerEdge = this.__iterEdge.next();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfromPoint.x = this.__entryX[this.__curFace.id];\r\n\t\t\t\t\tfromPoint.y = this.__entryY[this.__curFace.id];\r\n\t\t\t\t\tentryPoint.x = (innerEdge.originVertex.pos.x + innerEdge.destinationVertex.pos.x) /2;\r\n\t\t\t\t\tentryPoint.y = (innerEdge.originVertex.pos.y + innerEdge.destinationVertex.pos.y) /2;\r\n\t\t\t\t\tdistancePoint.x = entryPoint.x - toX;\r\n\t\t\t\t\tdistancePoint.y = entryPoint.y - toY;\r\n\t\t\t\t\th = distancePoint.length;\r\n\t\t\t\t\tdistancePoint.x = fromPoint.x - entryPoint.x;\r\n\t\t\t\t\tdistancePoint.y = fromPoint.y - entryPoint.y;\r\n\t\t\t\t\tg = this.__scoreG[this.__curFace.id] + distancePoint.length;\r\n\t\t\t\t\tf = h + g;\r\n\t\t\t\t\tfillDatas = false;\r\n\t\t\t\t\tif (! this.__openedFaces[neighbourFace.id]  )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.__sortedOpenedFaces.push(neighbourFace);\r\n\t\t\t\t\t\tthis.__openedFaces[neighbourFace.id] = true;\r\n\t\t\t\t\t\tfillDatas = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( this.__scoreF[neighbourFace.id] > f )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfillDatas = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (fillDatas)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.__entryEdges[neighbourFace.id] = innerEdge;\r\n\t\t\t\t\t\tthis.__entryX[neighbourFace.id] = entryPoint.x;\r\n\t\t\t\t\t\tthis.__entryY[neighbourFace.id] = entryPoint.y;\r\n\t\t\t\t\t\tthis.__scoreF[neighbourFace.id] = f;\r\n\t\t\t\t\t\tthis.__scoreG[neighbourFace.id] = g;\r\n\t\t\t\t\t\tthis.__scoreH[neighbourFace.id] = h;\r\n\t\t\t\t\t\tthis.__predecessor[neighbourFace.id] = this.__curFace;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tinnerEdge = this.__iterEdge.next();\r\n\t\t\t}\r\n\t\t\t//\r\n\t\t\tthis.__openedFaces[this.__curFace.id] = null;\r\n\t\t\tthis.__closedFaces[this.__curFace.id] = true;\r\n\t\t\tthis.__sortedOpenedFaces.sort(// faces with low distance value are at the end of the array\r\n\t\t\t\t(a:DDLSFace, b:DDLSFace):number =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif (this.__scoreF[a.id] == this.__scoreF[b.id])\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t\telse if (this.__scoreF[a.id] < this.__scoreF[b.id])\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\t// if we didn't find a path\r\n\t\tif (! this.__curFace)\r\n\t\t\treturn;\r\n\t\t\r\n\t\t// else we build the path\r\n\t\tresultListFaces.push(this.__curFace);\r\n\t\t//this.__curFace.colorDebug = 0x0000FF;\r\n\t\twhile (this.__curFace != this.__fromFace)\r\n\t\t{\r\n\t\t\tresultListEdges.unshift(this.__entryEdges[this.__curFace.id]);\r\n\t\t\t//this.__entryEdges[this.__curFace].colorDebug = 0xFFFF00;\r\n\t\t\t//this.__entryEdges[this.__curFace].oppositeEdge.colorDebug = 0xFFFF00;\r\n\t\t\tthis.__curFace = this.__predecessor[this.__curFace.id];\r\n\t\t\t//this.__curFace.colorDebug = 0x0000FF;\r\n\t\t\tresultListFaces.unshift(this.__curFace);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate isWalkableByRadius(fromEdge:DDLSEdge, throughFace:DDLSFace, toEdge:DDLSEdge):boolean\r\n\t{\r\n\t\tvar vA:DDLSVertex; // the vertex on fromEdge not on toEdge\r\n\t\tvar vB:DDLSVertex; // the vertex on toEdge not on fromEdge\r\n\t\tvar vC:DDLSVertex; // the common vertex of the 2 edges (pivot)\r\n\t\t\r\n\t\t// we identify the points\r\n\t\tif ( fromEdge.originVertex == toEdge.originVertex )\r\n\t\t{\r\n\t\t\tvA = fromEdge.destinationVertex;\r\n\t\t\tvB = toEdge.destinationVertex;\r\n\t\t\tvC = fromEdge.originVertex;\r\n\t\t}\r\n\t\telse if (fromEdge.destinationVertex == toEdge.destinationVertex)\r\n\t\t{\r\n\t\t\tvA = fromEdge.originVertex;\r\n\t\t\tvB = toEdge.originVertex;\r\n\t\t\tvC = fromEdge.destinationVertex;\r\n\t\t}\r\n\t\telse if (fromEdge.originVertex == toEdge.destinationVertex)\r\n\t\t{\r\n\t\t\tvA = fromEdge.destinationVertex;\r\n\t\t\tvB = toEdge.originVertex;\r\n\t\t\tvC = fromEdge.originVertex;\r\n\t\t}\r\n\t\telse if (fromEdge.destinationVertex == toEdge.originVertex)\r\n\t\t{\r\n\t\t\tvA = fromEdge.originVertex;\r\n\t\t\tvB = toEdge.destinationVertex;\r\n\t\t\tvC = fromEdge.destinationVertex;\r\n\t\t}\r\n\t\t\r\n\t\tvar dot:number;\r\n\t\tvar result:boolean;\r\n\t\tvar distSquared:number;\r\n\t\t\r\n\t\t// if we have a right or obtuse angle on CAB\r\n\t\tdot = (vC.pos.x - vA.pos.x)*(vB.pos.x - vA.pos.x) + (vC.pos.y - vA.pos.y)*(vB.pos.y - vA.pos.y);\r\n\t\tif (dot <= 0)\r\n\t\t{\r\n\t\t\t// we compare length of AC with this.radius\r\n\t\t\tdistSquared = (vC.pos.x - vA.pos.x)*(vC.pos.x - vA.pos.x) + (vC.pos.y - vA.pos.y)*(vC.pos.y - vA.pos.y);\r\n\t\t\tif (distSquared >= this._diameterSquared)\r\n\t\t\t\treturn true;\r\n\t\t\telse\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// if we have a right or obtuse angle on CBA\r\n\t\tdot = (vC.pos.x - vB.pos.x)*(vA.pos.x - vB.pos.x) + (vC.pos.y - vB.pos.y)*(vA.pos.y - vB.pos.y);\r\n\t\tif (dot <= 0)\r\n\t\t{\r\n\t\t\t// we compare length of BC with this.radius\r\n\t\t\tdistSquared = (vC.pos.x - vB.pos.x)*(vC.pos.x - vB.pos.x) + (vC.pos.y - vB.pos.y)*(vC.pos.y - vB.pos.y);\r\n\t\t\tif (distSquared >= this._diameterSquared)\r\n\t\t\t\treturn true;\r\n\t\t\telse\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// we identify the adjacent edge (facing pivot vertex)\r\n\t\tvar adjEdge:DDLSEdge;\r\n\t\tif (throughFace.edge != fromEdge && throughFace.edge.oppositeEdge != fromEdge\r\n\t\t\t&& throughFace.edge != toEdge && throughFace.edge.oppositeEdge != toEdge)\r\n\t\t\tadjEdge = throughFace.edge;\r\n\t\telse if (throughFace.edge.nextLeftEdge != fromEdge && throughFace.edge.nextLeftEdge.oppositeEdge != fromEdge\r\n\t\t\t\t&& throughFace.edge.nextLeftEdge != toEdge && throughFace.edge.nextLeftEdge.oppositeEdge != toEdge)\r\n\t\t\tadjEdge = throughFace.edge.nextLeftEdge;\r\n\t\telse\r\n\t\t\tadjEdge = throughFace.edge.prevLeftEdge;\r\n\t\t\r\n\t\t// if the adjacent edge is constrained, we check the distance of orthognaly projected\r\n\t\tif (adjEdge.isConstrained)\r\n\t\t{\r\n\t\t\tvar proj:DDLSPoint2D = new DDLSPoint2D(vC.pos.x, vC.pos.y);\r\n\t\t\tDDLSGeom2D.projectOrthogonaly(proj, adjEdge);\r\n\t\t\tdistSquared = (proj.x - vC.pos.x)*(proj.x - vC.pos.x) + (proj.y - vC.pos.y)*(proj.y - vC.pos.y);\r\n\t\t\tif (distSquared >= this._diameterSquared)\r\n\t\t\t\treturn true;\r\n\t\t\telse\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\telse // if the adjacent is not constrained\r\n\t\t{\r\n\t\t\tvar distSquaredA:number = (vC.pos.x - vA.pos.x)*(vC.pos.x - vA.pos.x) + (vC.pos.y - vA.pos.y)*(vC.pos.y - vA.pos.y);\r\n\t\t\tvar distSquaredB:number = (vC.pos.x - vB.pos.x)*(vC.pos.x - vB.pos.x) + (vC.pos.y - vB.pos.y)*(vC.pos.y - vB.pos.y);\r\n\t\t\tif (distSquaredA < this._diameterSquared || distSquaredB < this._diameterSquared)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar vFaceToCheck:DDLSFace[] = [];\r\n\t\t\t\tvar vFaceIsFromEdge:DDLSEdge[] = [];\r\n\t\t\t\tvar facesDone:any = {};\r\n\t\t\t\tvFaceIsFromEdge.push(adjEdge);\r\n\t\t\t\tif (adjEdge.leftFace == throughFace)\r\n\t\t\t\t{\r\n\t\t\t\t\tvFaceToCheck.push(adjEdge.rightFace);\r\n\t\t\t\t\tfacesDone[adjEdge.rightFace.id] = true;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tvFaceToCheck.push(adjEdge.leftFace);\r\n\t\t\t\t\tfacesDone[adjEdge.leftFace.id] = true;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar currFace:DDLSFace;\r\n\t\t\t\tvar faceFromEdge:DDLSEdge;\r\n\t\t\t\tvar currEdgeA:DDLSEdge;\r\n\t\t\t\tvar nextFaceA:DDLSFace;\r\n\t\t\t\tvar currEdgeB:DDLSEdge;\r\n\t\t\t\tvar nextFaceB:DDLSFace;\r\n\t\t\t\twhile (vFaceToCheck.length > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tcurrFace = vFaceToCheck.shift();\r\n\t\t\t\t\tfaceFromEdge = vFaceIsFromEdge.shift();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// we identify the 2 edges to evaluate\r\n\t\t\t\t\tif (currFace.edge == faceFromEdge || currFace.edge == faceFromEdge.oppositeEdge)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurrEdgeA = currFace.edge.nextLeftEdge;\r\n\t\t\t\t\t\tcurrEdgeB = currFace.edge.nextLeftEdge.nextLeftEdge;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (currFace.edge.nextLeftEdge == faceFromEdge || currFace.edge.nextLeftEdge == faceFromEdge.oppositeEdge)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurrEdgeA = currFace.edge;\r\n\t\t\t\t\t\tcurrEdgeB = currFace.edge.nextLeftEdge.nextLeftEdge;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurrEdgeA = currFace.edge;\r\n\t\t\t\t\t\tcurrEdgeB = currFace.edge.nextLeftEdge;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// we identify the faces related to the 2 edges\r\n\t\t\t\t\tif (currEdgeA.leftFace == currFace)\r\n\t\t\t\t\t\tnextFaceA = currEdgeA.rightFace;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnextFaceA = currEdgeA.leftFace;\r\n\t\t\t\t\tif (currEdgeB.leftFace == currFace)\r\n\t\t\t\t\t\tnextFaceB = currEdgeB.rightFace;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnextFaceB = currEdgeB.leftFace;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t// we check if the next face is not already in pipe\r\n\t\t\t\t\t// and if the edge A is close to pivot vertex\r\n\t\t\t\t\tif ( ! facesDone[nextFaceA.id] && DDLSGeom2D.distanceSquaredVertexToEdge(vC, currEdgeA) < this._diameterSquared )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// if the edge is constrained\r\n\t\t\t\t\t\tif ( currEdgeA.isConstrained )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// so it is not walkable\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// if the edge is not constrained, we continue the search\r\n\t\t\t\t\t\t\tvFaceToCheck.push(nextFaceA);\r\n\t\t\t\t\t\t\tvFaceIsFromEdge.push(currEdgeA);\r\n\t\t\t\t\t\t\tfacesDone[nextFaceA.id] = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// we check if the next face is not already in pipe\r\n\t\t\t\t\t// and if the edge B is close to pivot vertex\r\n\t\t\t\t\tif ( ! facesDone[nextFaceB.id] && DDLSGeom2D.distanceSquaredVertexToEdge(vC, currEdgeB) < this._diameterSquared )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// if the edge is constrained\r\n\t\t\t\t\t\tif ( currEdgeB.isConstrained )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// so it is not walkable\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// if the edge is not constrained, we continue the search\r\n\t\t\t\t\t\t\tvFaceToCheck.push(nextFaceB);\r\n\t\t\t\t\t\t\tvFaceIsFromEdge.push(currEdgeB);\r\n\t\t\t\t\t\t\tfacesDone[nextFaceB.id] = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// if we didn't previously meet a constrained edge\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n}", "import { DDLSPoint2D } from \"./DDLSPoint2D\";\r\n\r\n\r\nexport class DDLSMatrix2D\r\n{\r\n/*\t\r\n    DDLSPoint2D represents row vector in homogeneous coordinates:\r\n    [x, y, 1]\r\n    \r\n    DDLSMatrix2D represents transform matrix in homogeneous coordinates:\r\n    [this.a, this.b, 0]\r\n    [this.c, this.d, 0]\r\n    [this.e, this.f, 1]\r\n*/\r\n    \r\n    private _a:number;\r\n    private _b:number;\r\n    private _c:number;\r\n    private _d:number;\r\n    private _e:number;\r\n    private _f:number;\r\n    \r\n    constructor(a:number=1, b:number=0, c:number=0, d:number=1, e:number=0, f:number=0)\r\n    {\r\n        this._a = this.a;\r\n        this._b = this.b;\r\n        this._c = this.c;\r\n        this._d = this.d;\r\n        this._e = this.e;\r\n        this._f = this.f;\r\n    }\r\n\r\n    public identity():void\r\n    {\r\n        /*\r\n        [1, 0, 0]\r\n        [0, 1, 0]\r\n        [0, 0, 1]\r\n        */\r\n        \r\n        this._a = 1;\r\n        this._b = 0;\r\n        this._c = 0;\r\n        this._d = 1;\r\n        this._e = 0;\r\n        this._f = 0;\r\n    }\r\n    \r\n    public translate(tx:number, ty:number):void\r\n    {\r\n        /*\r\n        [1,  0,  0]\r\n        [0,  1,  0]\r\n        [tx, ty, 1]\r\n        \r\n        */\r\n        this._e = this._e + tx;\r\n        this._f = this._f + ty;\r\n    }\r\n    \r\n    public scale(sx:number, sy:number):void\r\n    {\r\n        /*\r\n        [sx, 0, 0]\r\n        [0, sy, 0]\r\n        [0,  0, 1]\r\n        */\r\n        this._a = this._a*sx;\r\n        this._b = this._b*sy;\r\n        this._c = this._c*sx;\r\n        this._d = this._d*sy;\r\n        this._e = this._e*sx;\r\n        this._f = this._f*sy;\r\n    }\r\n    \r\n    public rotate(rad:number):void\r\n    {\r\n        /*\r\n                    [ cos, sin, 0]\r\n                    [-sin, cos, 0]\r\n                    [   0,   0, 1]\r\n        \r\n        [this.a, this.b, 0]\r\n        [this.c, this.d, 0]\r\n        [this.e, this.f, 1]\r\n        */\r\n        var cos:number = Math.cos(rad);\r\n        var sin:number = Math.sin(rad);\r\n        var a:number = this._a*cos + this._b*-sin;\r\n        var b:number = this._a*sin + this._b*cos;\r\n        var c:number = this._c*cos + this._d*-sin;\r\n        var d:number = this._c*sin + this._d*cos;\r\n        var e:number = this._e*cos + this._f*-sin;\r\n        var f:number = this._e*sin + this._f*cos;\r\n        this._a = this.a;\r\n        this._b = this.b\r\n        this._c = this.c;\r\n        this._d = this.d;\r\n        this._e = this.e;\r\n        this._f = this.f;\r\n    }\r\n    \r\n    public clone():DDLSMatrix2D\r\n    {\r\n        return new DDLSMatrix2D(this._a, this._b, this._c, this._d, this._e, this._f);\r\n    }\r\n    \r\n    public tranform(point:DDLSPoint2D):void\r\n    {\r\n        /*\r\n                    [this.a, this.b, 0]\r\n                    [this.c, this.d, 0]\r\n                    [this.e, this.f, 1]\r\n        [x, y, 1]\r\n        */\r\n        var x:number = this._a*point.x + this._c*point.y + this.e;\r\n        var y:number = this._b*point.x + this._d*point.y + this.f;\r\n        point.x = x;\r\n        point.y = y;\r\n    }\r\n    \r\n    public transformX(x:number, y:number):number\r\n    {\r\n        return this._a*x + this._c*y + this.e;\r\n    }\r\n    public transformY(x:number, y:number):number\r\n    {\r\n        return this._b*x + this._d*y + this.f;\r\n    }\r\n    \r\n    public concat(matrix:DDLSMatrix2D):void\r\n    {\r\n        var a:number = this._a*matrix.a + this._b*matrix.c;\r\n        var b:number = this._a*matrix.b + this._b*matrix.d;\r\n        var c:number = this._c*matrix.a + this._d*matrix.c;\r\n        var d:number = this._c*matrix.b + this._d*matrix.d;\r\n        var e:number = this._e*matrix.a + this._f*matrix.c + matrix.e;\r\n        var f:number = this._e*matrix.b + this._f*matrix.d + matrix.f;\r\n        this._a = this.a\r\n        this._b = this.b;\r\n        this._c = this.c;\r\n        this._d = this.d;\r\n        this._e = this.e;\r\n        this._f = this.f;\r\n    }\r\n    \r\n    public get a():number\r\n    {\r\n        return this._a;\r\n    }\r\n    \r\n    public set a(value:number)\r\n    {\r\n        this._a = value;\r\n    }\r\n    \r\n    public get b():number\r\n    {\r\n        return this._b;\r\n    }\r\n    \r\n    public set b(value:number)\r\n    {\r\n        this._b = value;\r\n    }\r\n    \r\n    public get c():number\r\n    {\r\n        return this._c;\r\n    }\r\n    \r\n    public set c(value:number)\r\n    {\r\n        this._c = value;\r\n    }\r\n    \r\n    public get d():number\r\n    {\r\n        return this._d;\r\n    }\r\n    \r\n    public set d(value:number)\r\n    {\r\n        this._d = value;\r\n    }\r\n    \r\n    public get e():number\r\n    {\r\n        return this._e;\r\n    }\r\n    \r\n    public set e(value:number)\r\n    {\r\n        this._e = value;\r\n    }\r\n    \r\n    public get f():number\r\n    {\r\n        return this._f;\r\n    }\r\n    \r\n    public set f(value:number)\r\n    {\r\n        this._f = value;\r\n    }\r\n    \r\n}", "import { DDLSConstraintShape } from \"./DDLSConstraintShape\";\r\nimport { DDLSEdge } from \"./DDLSEdge\";\r\nimport { DDLSMatrix2D } from \"./math/DDLSMatrix2D\";\r\n\r\n\r\nexport class DDLSObject\r\n{\r\n\t\r\n\tprivate static INC:number = 0;\r\n\tprivate _id:number;\r\n\t\r\n\tprivate _matrix:DDLSMatrix2D;\r\n\tprivate _coordinates:number[];\r\n\tprivate _constraintShape:DDLSConstraintShape;\r\n\t\r\n\tprivate _pivotX:number;\r\n\tprivate _pivotY:number;\r\n\t\r\n\tprivate _scaleX:number;\r\n\tprivate _scaleY:number;\r\n\tprivate _rotation:number;\r\n\tprivate _x:number;\r\n\tprivate _y:number;\r\n\t\r\n\tprivate _hasChanged:boolean;\r\n\t\r\n\tconstructor()\r\n\t{\r\n\t\tthis._id = DDLSObject.INC;\r\n\t\tDDLSObject.INC++;\r\n\t\t\r\n\t\tthis._pivotX = 0;\r\n\t\tthis._pivotY = 0;\r\n\t\t\r\n\t\tthis._matrix = new DDLSMatrix2D();\r\n\t\tthis._scaleX = 1;\r\n\t\tthis._scaleY = 1;\r\n\t\tthis._rotation = 0;\r\n\t\tthis._x = 0;\r\n\t\tthis._y = 0;\r\n\t\t\r\n\t\tthis._coordinates = [];\r\n\t\t\r\n\t\tthis._hasChanged = false;\r\n\t}\r\n\t\r\n\tpublic get id():number\r\n\t{\r\n\t\treturn this._id;\r\n\t}\r\n\t\r\n\tpublic dispose():void\r\n\t{\r\n\t\tthis._matrix = null;\r\n\t\tthis._coordinates = null;\r\n\t\tthis._constraintShape = null;\r\n\t}\r\n\t\r\n\tpublic updateValuesFromMatrix():void\r\n\t{\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic updateMatrixFromValues():void\r\n\t{\r\n\t\tthis._matrix.identity();\r\n\t\tthis._matrix.translate(-this._pivotX, -this._pivotY);\r\n\t\tthis._matrix.scale(this._scaleX, this._scaleY);\r\n\t\tthis._matrix.rotate(this._rotation);\r\n\t\tthis._matrix.translate(this._x, this._y);\r\n\t}\r\n\t\r\n\tpublic get pivotX():number\r\n\t{\r\n\t\treturn this._pivotX;\r\n\t}\r\n\t\r\n\tpublic set pivotX(value:number)\r\n\t{\r\n\t\tthis._pivotX = value;\r\n\t\tthis._hasChanged = true;\r\n\t}\r\n\t\r\n\tpublic get pivotY():number\r\n\t{\r\n\t\treturn this._pivotY;\r\n\t}\r\n\t\r\n\tpublic set pivotY(value:number)\r\n\t{\r\n\t\tthis._pivotY = value;\r\n\t\tthis._hasChanged = true;\r\n\t}\r\n\t\r\n\tpublic get scaleX():number\r\n\t{\r\n\t\treturn this._scaleX;\r\n\t}\r\n\r\n\tpublic set scaleX(value:number)\r\n\t{\r\n\t\tif (this._scaleX != value)\r\n\t\t{\r\n\t\t\tthis._scaleX = value;\r\n\t\t\tthis._hasChanged = true;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get scaleY():number\r\n\t{\r\n\t\treturn this._scaleY;\r\n\t}\r\n\r\n\tpublic set scaleY(value:number)\r\n\t{\r\n\t\tif (this._scaleY != value)\r\n\t\t{\r\n\t\t\tthis._scaleY = value;\r\n\t\t\tthis._hasChanged = true;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get rotation():number\r\n\t{\r\n\t\treturn this._rotation;\r\n\t}\r\n\r\n\tpublic set rotation(value:number)\r\n\t{\r\n\t\tif (this._rotation != value)\r\n\t\t{\r\n\t\t\tthis._rotation = value;\r\n\t\t\tthis._hasChanged = true;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get x():number\r\n\t{\r\n\t\treturn this._x;\r\n\t}\r\n\r\n\tpublic set x(value:number)\r\n\t{\r\n\t\tif (this._x != value)\r\n\t\t{\r\n\t\t\tthis._x = value;\r\n\t\t\tthis._hasChanged = true;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get y():number\r\n\t{\r\n\t\treturn this._y;\r\n\t}\r\n\r\n\tpublic set y(value:number)\r\n\t{\r\n\t\tif (this._y != value)\r\n\t\t{\r\n\t\t\tthis._y = value;\r\n\t\t\tthis._hasChanged = true;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get matrix():DDLSMatrix2D\r\n\t{\r\n\t\treturn this._matrix;\r\n\t}\r\n\r\n\tpublic set matrix(value:DDLSMatrix2D)\r\n\t{\r\n\t\tthis._matrix = value;\r\n\t\tthis._hasChanged = true;\r\n\t}\r\n\r\n\tpublic get coordinates():number[]\r\n\t{\r\n\t\treturn this._coordinates;\r\n\t}\r\n\r\n\tpublic set coordinates(value:number[])\r\n\t{\r\n\t\tthis._coordinates = value;\r\n\t\tthis._hasChanged = true;\r\n\t}\r\n\r\n\tpublic get constraintShape():DDLSConstraintShape\r\n\t{\r\n\t\treturn this._constraintShape;\r\n\t}\r\n\r\n\tpublic set constraintShape(value:DDLSConstraintShape)\r\n\t{\r\n\t\tthis._constraintShape = value;\r\n\t\tthis._hasChanged = true;\r\n\t}\r\n\r\n\tpublic get hasChanged():boolean\r\n\t{\r\n\t\treturn this._hasChanged;\r\n\t}\r\n\r\n\tpublic set hasChanged(value:boolean)\r\n\t{\r\n\t\tthis._hasChanged = value;\r\n\t}\r\n\t\r\n\tpublic get edges():DDLSEdge[]\r\n\t{\r\n\t\tvar res:DDLSEdge[] = [];\r\n\t\t\r\n\t\tfor (var i:number=0 ; i< this._constraintShape.segments.length ; i++)\r\n\t\t{\r\n\t\t\tfor (var j:number=0 ; j<this._constraintShape.segments[i].edges.length ; j++)\r\n\t\t\t\tres.push(this._constraintShape.segments[i].edges[j]);\r\n\t\t}\r\n\t\t\r\n\t\treturn res;\r\n\t}\r\n\r\n}", "import { DDLSObject } from \"../data/DDLSObject\";\r\n\r\n\r\nexport class DDLSEntityAI {\r\n\r\n\tprivate static NUM_SEGMENTS: number = 6;\r\n\r\n\tprivate _radius: number;\r\n\tprivate _radiusSquared: number;\r\n\tprivate _x: number;\r\n\tprivate _y: number;\r\n\tprivate _dirNormX: number;\r\n\tprivate _dirNormY: number;\r\n\tprivate _angleFOV: number;\r\n\tprivate _radiusFOV: number;\r\n\tprivate _radiusSquaredFOV: number;\r\n\tprivate _approximateObject: DDLSObject;\r\n\r\n\r\n\tconstructor() {\r\n\t\tthis._radius = 10;\r\n\t\tthis._x = this._y = 0;\r\n\t\tthis._dirNormX = 1;\r\n\t\tthis._dirNormY = 0;\r\n\t\tthis._angleFOV = 60;\r\n\t}\r\n\r\n\tbuildApproximation(): void {\r\n\t\tthis._approximateObject = new DDLSObject();\r\n\t\tthis._approximateObject.matrix.translate(this.x, this.y);\r\n\t\tlet coordinates: Array<number> = new Array<number>();\r\n\t\tthis._approximateObject.coordinates = coordinates;\r\n\r\n\t\tif (this._radius == 0)\r\n\t\t\treturn;\r\n\r\n\t\tfor (let i = 0; i < DDLSEntityAI.NUM_SEGMENTS; i++) {\r\n\t\t\tcoordinates.push(this._radius * Math.cos(2 * Math.PI * i / DDLSEntityAI.NUM_SEGMENTS));\r\n\t\t\tcoordinates.push(this._radius * Math.sin(2 * Math.PI * i / DDLSEntityAI.NUM_SEGMENTS));\r\n\t\t\tcoordinates.push(this._radius * Math.cos(2 * Math.PI * (i + 1) / DDLSEntityAI.NUM_SEGMENTS));\r\n\t\t\tcoordinates.push(this._radius * Math.sin(2 * Math.PI * (i + 1) / DDLSEntityAI.NUM_SEGMENTS));\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tget approximateObject(): DDLSObject {\r\n\t\tthis._approximateObject.matrix.identity();\r\n\t\tthis._approximateObject.matrix.translate(this.x, this.y);\r\n\t\treturn this._approximateObject;\r\n\t}\r\n\r\n\tget radiusFOV(): number {\r\n\t\treturn this._radiusFOV;\r\n\t}\r\n\r\n\tset radiusFOV(value: number) {\r\n\t\tthis._radiusFOV = value;\r\n\t\tthis._radiusSquaredFOV = this._radiusFOV * this._radiusFOV;\r\n\t}\r\n\r\n\tget angleFOV(): number {\r\n\t\treturn this._angleFOV;\r\n\t}\r\n\r\n\tset angleFOV(value: number) {\r\n\t\tthis._angleFOV = value;\r\n\t}\r\n\r\n\tget dirNormY(): number {\r\n\t\treturn this._dirNormY;\r\n\t}\r\n\r\n\tset dirNormY(value: number) {\r\n\t\tthis._dirNormY = value;\r\n\t}\r\n\r\n\tget dirNormX(): number {\r\n\t\treturn this._dirNormX;\r\n\t}\r\n\r\n\tset dirNormX(value: number) {\r\n\t\tthis._dirNormX = value;\r\n\t}\r\n\r\n\tget y(): number {\r\n\t\treturn this._y;\r\n\t}\r\n\r\n\tset y(value: number) {\r\n\t\tthis._y = value;\r\n\t}\r\n\r\n\tget x(): number {\r\n\t\treturn this._x;\r\n\t}\r\n\r\n\tset x(value: number) {\r\n\t\tthis._x = value;\r\n\t}\r\n\r\n\tget radius(): number {\r\n\t\treturn this._radius;\r\n\t}\r\n\r\n\tget radiusSquared(): number {\r\n\t\treturn this._radiusSquared;\r\n\t}\r\n\r\n\tset radius(value: number) {\r\n\t\tthis._radius = value;\r\n\t\tthis._radiusSquared = this._radius * this._radius;\r\n\t}\r\n}\r\n", "import { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSFace } from \"../data/DDLSFace\";\r\nimport { DDLSVertex } from \"../data/DDLSVertex\";\r\nimport { DDLSGeom2D } from \"../data/math/DDLSGeom2D\";\r\nimport { DDLSPoint2D } from \"../data/math/DDLSPoint2D\";\r\n\r\nexport class DDLSFunnel {\r\n\r\n\tprivate _radius: number = 0;\r\n\tprivate _radiusSquared: number = 0;\r\n\tprivate _numSamplesCircle: number = 16;\r\n\tprivate _sampleCircle: Array<DDLSPoint2D>;\r\n\tprivate _sampleCircleDistanceSquared: number;\r\n\r\n\t// public debugSurface: Sprite;\r\n\r\n\r\n\tconstructor() {\r\n\t\tthis._poolPoints = new Array<DDLSPoint2D>();\r\n\t\tfor (var i: number = 0; i < this._poolPointsSize; i++) {\r\n\t\t\tthis._poolPoints.push(new DDLSPoint2D());\r\n\t\t}\r\n\t}\r\n\r\n\tdispose(): void {\r\n\t\tthis._sampleCircle = null;\r\n\t}\r\n\r\n\r\n\tprivate _poolPointsSize: number = 3000;\r\n\tprivate _poolPoints: Array<DDLSPoint2D>;\r\n\tprivate _currPoolPointsIndex: number = 0;\r\n\tprivate __point: DDLSPoint2D;\r\n\tgetPoint(x: number = 0, y: number = 0): DDLSPoint2D {\r\n\t\tthis.__point = this._poolPoints[this._currPoolPointsIndex];\r\n\t\tthis.__point.setTo(x, y);\r\n\r\n\t\tthis._currPoolPointsIndex++;\r\n\t\tif (this._currPoolPointsIndex == this._poolPointsSize) {\r\n\t\t\tthis._poolPoints.push(new DDLSPoint2D());\r\n\t\t\tthis._poolPointsSize++;\r\n\t\t}\r\n\r\n\t\treturn this.__point;\r\n\t}\r\n\tgetCopyPoint(pointToCopy: DDLSPoint2D): DDLSPoint2D {\r\n\t\treturn this.getPoint(pointToCopy.x, pointToCopy.y);\r\n\t}\r\n\r\n\tget radius(): number {\r\n\t\treturn this._radius;\r\n\t}\r\n\r\n\tset radius(value: number) {\r\n\t\tthis._radius = Math.max(0, value);\r\n\t\tthis._radiusSquared = this._radius * this._radius;\r\n\t\tthis._sampleCircle = new Array<DDLSPoint2D>();\r\n\t\tif (this._radius == 0)\r\n\t\t\treturn;\r\n\r\n\t\tfor (var i: number = 0; i < this._numSamplesCircle; i++) {\r\n\t\t\tthis._sampleCircle.push(new DDLSPoint2D(this._radius * Math.cos(-2 * Math.PI * i / this._numSamplesCircle), this._radius * Math.sin(-2 * Math.PI * i / this._numSamplesCircle)));\r\n\t\t}\r\n\r\n\t\tthis._sampleCircleDistanceSquared = (this._sampleCircle[0].x - this._sampleCircle[1].x) * (this._sampleCircle[0].x - this._sampleCircle[1].x) + (this._sampleCircle[0].y - this._sampleCircle[1].y) * (this._sampleCircle[0].y - this._sampleCircle[1].y);\r\n\t}\r\n\r\n\tfindPath(fromX: number, fromY: number\r\n\t\t, toX: number, toY: number\r\n\t\t, listFaces: Array<DDLSFace>\r\n\t\t, listEdges: Array<DDLSEdge>\r\n\t\t, resultPath: Array<{ x: number, y: number }>): void {\r\n\r\n\t\tthis._currPoolPointsIndex = 0;\r\n\r\n\t\t// we check the start and goal\r\n\t\tif (this._radius > 0) {\r\n\t\t\tvar checkFace: DDLSFace = listFaces[0];\r\n\t\t\tvar distanceSquared: number;\r\n\t\t\tvar distance: number;\r\n\t\t\tvar p1: DDLSPoint2D;\r\n\t\t\tvar p2: DDLSPoint2D;\r\n\t\t\tvar p3: DDLSPoint2D;\r\n\t\t\tp1 = checkFace.edge.originVertex.pos;\r\n\t\t\tp2 = checkFace.edge.destinationVertex.pos;\r\n\t\t\tp3 = checkFace.edge.nextLeftEdge.destinationVertex.pos;\r\n\t\t\tdistanceSquared = (p1.x - fromX) * (p1.x - fromX) + (p1.y - fromY) * (p1.y - fromY);\r\n\t\t\tif (distanceSquared <= this._radiusSquared) {\r\n\t\t\t\tdistance = Math.sqrt(distanceSquared);\r\n\t\t\t\tfromX = this._radius * 1.01 * ((fromX - p1.x) / distance) + p1.x;\r\n\t\t\t\tfromY = this._radius * 1.01 * ((fromY - p1.y) / distance) + p1.y;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdistanceSquared = (p2.x - fromX) * (p2.x - fromX) + (p2.y - fromY) * (p2.y - fromY);\r\n\t\t\t\tif (distanceSquared <= this._radiusSquared) {\r\n\t\t\t\t\tdistance = Math.sqrt(distanceSquared);\r\n\t\t\t\t\tfromX = this._radius * 1.01 * ((fromX - p2.x) / distance) + p2.x;\r\n\t\t\t\t\tfromY = this._radius * 1.01 * ((fromY - p2.y) / distance) + p2.y;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tdistanceSquared = (p3.x - fromX) * (p3.x - fromX) + (p3.y - fromY) * (p3.y - fromY);\r\n\t\t\t\t\tif (distanceSquared <= this._radiusSquared) {\r\n\t\t\t\t\t\tdistance = Math.sqrt(distanceSquared);\r\n\t\t\t\t\t\tfromX = this._radius * 1.01 * ((fromX - p3.x) / distance) + p3.x;\r\n\t\t\t\t\t\tfromY = this._radius * 1.01 * ((fromY - p3.y) / distance) + p3.y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//\r\n\t\t\tcheckFace = listFaces[listFaces.length - 1];\r\n\t\t\tp1 = checkFace.edge.originVertex.pos;\r\n\t\t\tp2 = checkFace.edge.destinationVertex.pos;\r\n\t\t\tp3 = checkFace.edge.nextLeftEdge.destinationVertex.pos;\r\n\t\t\tdistanceSquared = (p1.x - toX) * (p1.x - toX) + (p1.y - toY) * (p1.y - toY);\r\n\t\t\tif (distanceSquared <= this._radiusSquared) {\r\n\t\t\t\tdistance = Math.sqrt(distanceSquared);\r\n\t\t\t\ttoX = this._radius * 1.01 * ((toX - p1.x) / distance) + p1.x;\r\n\t\t\t\ttoY = this._radius * 1.01 * ((toY - p1.y) / distance) + p1.y;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdistanceSquared = (p2.x - toX) * (p2.x - toX) + (p2.y - toY) * (p2.y - toY);\r\n\t\t\t\tif (distanceSquared <= this._radiusSquared) {\r\n\t\t\t\t\tdistance = Math.sqrt(distanceSquared);\r\n\t\t\t\t\ttoX = this._radius * 1.01 * ((toX - p2.x) / distance) + p2.x;\r\n\t\t\t\t\ttoY = this._radius * 1.01 * ((toY - p2.y) / distance) + p2.y;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tdistanceSquared = (p3.x - toX) * (p3.x - toX) + (p3.y - toY) * (p3.y - toY);\r\n\t\t\t\t\tif (distanceSquared <= this._radiusSquared) {\r\n\t\t\t\t\t\tdistance = Math.sqrt(distanceSquared);\r\n\t\t\t\t\t\ttoX = this._radius * 1.01 * ((toX - p3.x) / distance) + p3.x;\r\n\t\t\t\t\t\ttoY = this._radius * 1.01 * ((toY - p3.y) / distance) + p3.y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\r\n\t\t// we build starting and ending points\r\n\t\tvar startPoint: DDLSPoint2D;\r\n\t\tvar endPoint: DDLSPoint2D;\r\n\t\tstartPoint = new DDLSPoint2D(fromX, fromY);\r\n\t\tendPoint = new DDLSPoint2D(toX, toY);\r\n\r\n\t\tif (listFaces.length == 1) {\r\n\t\t\t// resultPath.push(startPoint.x);\r\n\t\t\t// resultPath.push(startPoint.y);\r\n\t\t\t// resultPath.push(endPoint.x);\r\n\t\t\t// resultPath.push(endPoint.y);\r\n\t\t\tresultPath.push(startPoint.clone());\r\n\t\t\tresultPath.push(endPoint.clone());\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// useful\r\n\t\tvar i: number;\r\n\t\tvar j: number;\r\n\t\tvar k: number;\r\n\t\tvar currEdge: DDLSEdge;\r\n\t\tvar currVertex: DDLSVertex;\r\n\t\tvar direction: number;\r\n\r\n\t\t// first we skip the first face and first edge if the starting point lies on the first interior edge:\r\n\t\tif (listEdges[0] == DDLSGeom2D.isInFace(fromX, fromY, listFaces[0])) {\r\n\t\t\tlistEdges.shift();\r\n\t\t\tlistFaces.shift();\r\n\t\t}\r\n\r\n\t\t// our funnels, inited with starting point\r\n\t\tvar funnelLeft: Array<DDLSPoint2D> = new Array<DDLSPoint2D>();\r\n\t\tvar funnelRight: Array<DDLSPoint2D> = new Array<DDLSPoint2D>();\r\n\t\tfunnelLeft.push(startPoint);\r\n\t\tfunnelRight.push(startPoint);\r\n\r\n\t\t// useful to keep track of done vertices and compare the sides\r\n\t\tvar verticesDoneSide = new Map<number,number>();\r\n\r\n\t\t// we extract the vertices positions and sides from the edges list\r\n\t\tvar pointsList: Array<DDLSPoint2D> = new Array<DDLSPoint2D>();\r\n\t\tvar pointSides = new Map<number,number>();\r\n\t\t// we keep the successor relation in a dictionnary\r\n\t\tvar pointSuccessor = new Map<number,DDLSPoint2D>();\r\n\t\t//\r\n\t\tpointSides.set(startPoint.id, 0);\r\n\t\t// we begin with the vertices in first edge\r\n\t\tcurrEdge = listEdges[0];\r\n\t\tvar relativPos: number = DDLSGeom2D.getRelativePosition2(fromX, fromY, currEdge);\r\n\t\tvar prevPoint: DDLSPoint2D;\r\n\t\tvar newPointA: DDLSPoint2D;\r\n\t\tvar newPointB: DDLSPoint2D;\r\n\t\tnewPointA = this.getCopyPoint(currEdge.destinationVertex.pos);\r\n\t\tnewPointB = this.getCopyPoint(currEdge.originVertex.pos);\r\n\r\n\t\tpointsList.push(newPointA);\r\n\t\tpointsList.push(newPointB);\r\n\t\tpointSuccessor.set(startPoint.id, newPointA);\r\n\t\tpointSuccessor.set(newPointA.id, newPointB);\r\n\t\tprevPoint = newPointB;\r\n\t\tif (relativPos == 1) {\r\n\t\t\tpointSides.set(newPointA.id, 1);\r\n\t\t\tpointSides.set(newPointB.id, -1);\r\n\t\t\tverticesDoneSide.set(currEdge.destinationVertex.id, 1);\r\n\t\t\tverticesDoneSide.set(currEdge.originVertex.id, -1);\r\n\t\t}\r\n\t\telse if (relativPos == -1) {\r\n\t\t\tpointSides.set(newPointA.id, -1);\r\n\t\t\tpointSides.set(newPointB.id, 1);\r\n\t\t\tverticesDoneSide.set(currEdge.destinationVertex.id, -1);\r\n\t\t\tverticesDoneSide.set(currEdge.originVertex.id, 1);\r\n\t\t}\r\n\r\n\t\t// then we iterate through the edges\r\n\t\tvar fromVertex: DDLSVertex = listEdges[0].originVertex;\r\n\t\tvar fromFromVertex: DDLSVertex = listEdges[0].destinationVertex;\r\n\t\tfor (i = 1; i < listEdges.length; i++) {\r\n\t\t\t// we identify the current vertex and his origin vertex\r\n\t\t\tcurrEdge = listEdges[i];\r\n\t\t\tif (currEdge.originVertex == fromVertex) {\r\n\t\t\t\tcurrVertex = currEdge.destinationVertex;\r\n\t\t\t}\r\n\t\t\telse if (currEdge.destinationVertex == fromVertex) {\r\n\t\t\t\tcurrVertex = currEdge.originVertex;\r\n\t\t\t}\r\n\t\t\telse if (currEdge.originVertex == fromFromVertex) {\r\n\t\t\t\tcurrVertex = currEdge.destinationVertex;\r\n\t\t\t\tfromVertex = fromFromVertex;\r\n\t\t\t}\r\n\t\t\telse if (currEdge.destinationVertex == fromFromVertex) {\r\n\t\t\t\tcurrVertex = currEdge.originVertex;\r\n\t\t\t\tfromVertex = fromFromVertex;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconsole.log(\"IMPOSSIBLE TO IDENTIFY THE VERTEX !!!\");\r\n\t\t\t}\r\n\r\n\t\t\tnewPointA = this.getCopyPoint(currVertex.pos);\r\n\t\t\tpointsList.push(newPointA);\r\n\t\t\tdirection = - verticesDoneSide.get(fromVertex.id);\r\n\t\t\tpointSides.set(newPointA.id, direction);\r\n\t\t\tpointSuccessor.set(prevPoint.id, newPointA);\r\n\t\t\tverticesDoneSide.set(currVertex.id, direction);\r\n\t\t\tprevPoint = newPointA;\r\n\t\t\tfromFromVertex = fromVertex;\r\n\t\t\tfromVertex = currVertex;\r\n\t\t}\r\n\t\t// we then we add the end point\r\n\t\tpointSuccessor.set(prevPoint.id, endPoint);\r\n\t\tpointSides.set(endPoint.id, 0);\r\n\r\n\t\t/*\r\n\t\tdebugSurface.graphics.clear();\r\n\t\tdebugSurface.graphics.lineStyle(1, 0x0000FF);\r\n\t\tvar ppp1:Point = startPoint;\r\n\t\tvar ppp2:Point = pointSuccessor[ppp1];\r\n\t\twhile (ppp2)\r\n\t\t{\r\n\t\t\tdebugSurface.graphics.moveTo(ppp1.x, ppp1.y+2);\r\n\t\t\tdebugSurface.graphics.lineTo(ppp2.x, ppp2.y+2);\r\n\t\t\tdebugSurface.graphics.drawCircle(ppp2.x, ppp2.y, 3);\r\n\t\t\tppp1 = ppp2;\r\n\t\t\tppp2 = pointSuccessor[ppp2];\r\n\t\t}\r\n\t\t\r\n\t\tdebugSurface.graphics.lineStyle(1, 0x00FF00);\r\n\t\tfor (i=1 ; i<pointsList.length ; i++)\r\n\t\t{\r\n\t\t\tdebugSurface.graphics.moveTo(pointsList[i-1].x+2, pointsList[i-1].y);\r\n\t\t\tdebugSurface.graphics.lineTo(pointsList[i].x+2, pointsList[i].y);\r\n\t\t}\r\n\t\t*/\r\n\r\n\t\t// we will keep the points and funnel sides of the optimized path\r\n\t\tvar pathPoints: Array<DDLSPoint2D> = new Array<DDLSPoint2D>();\r\n\t\tvar pathSides = new Map<number,number>();\r\n\t\tpathPoints.push(startPoint);\r\n\t\tpathSides.set(startPoint.id, 0);\r\n\r\n\t\t// now we process the points by order\r\n\t\tvar currPos: DDLSPoint2D;\r\n\t\tfor (i = 0; i < pointsList.length; i++) {\r\n\t\t\tcurrPos = pointsList[i];\r\n\r\n\t\t\t// we identify the current vertex funnel's position by the position of his origin vertex\r\n\t\t\tif (pointSides.get(currPos.id) == -1) {\r\n\t\t\t\t// current vertex is at right\r\n\t\t\t\t//trace(\"current vertex is at right\");\r\n\t\t\t\tfor (j = funnelLeft.length - 2; j >= 0; j--) {\r\n\t\t\t\t\tdirection = DDLSGeom2D.getDirection(funnelLeft[j].x, funnelLeft[j].y, funnelLeft[j + 1].x, funnelLeft[j + 1].y, currPos.x, currPos.y);\r\n\t\t\t\t\tif (direction != -1) {\r\n\t\t\t\t\t\t//trace(\"funnels are crossing\");\r\n\r\n\t\t\t\t\t\tfunnelLeft.shift();\r\n\t\t\t\t\t\tfor (k = 0; k <= j - 1; k++) {\r\n\t\t\t\t\t\t\tpathPoints.push(funnelLeft[0]);\r\n\t\t\t\t\t\t\tpathSides.set(funnelLeft[0].id, 1);\r\n\t\t\t\t\t\t\tfunnelLeft.shift();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpathPoints.push(funnelLeft[0]);\r\n\t\t\t\t\t\tpathSides.set(funnelLeft[0].id, 1);\r\n\t\t\t\t\t\tfunnelRight.splice(0, funnelRight.length);\r\n\t\t\t\t\t\tfunnelRight.push(funnelLeft[0], currPos);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunnelRight.push(currPos);\r\n\t\t\t\tfor (j = funnelRight.length - 3; j >= 0; j--) {\r\n\t\t\t\t\tdirection = DDLSGeom2D.getDirection(funnelRight[j].x, funnelRight[j].y, funnelRight[j + 1].x, funnelRight[j + 1].y, currPos.x, currPos.y);\r\n\t\t\t\t\tif (direction == -1)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tfunnelRight.splice(j + 1, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// current vertex is at left\r\n\t\t\t\tfor (j = funnelRight.length - 2; j >= 0; j--) {\r\n\t\t\t\t\tdirection = DDLSGeom2D.getDirection(funnelRight[j].x, funnelRight[j].y, funnelRight[j + 1].x, funnelRight[j + 1].y, currPos.x, currPos.y);\r\n\t\t\t\t\tif (direction != 1) {\r\n\t\t\t\t\t\tfunnelRight.shift();\r\n\t\t\t\t\t\tfor (k = 0; k <= j - 1; k++) {\r\n\t\t\t\t\t\t\tpathPoints.push(funnelRight[0]);\r\n\t\t\t\t\t\t\tpathSides.set(funnelRight[0].id, -1);\r\n\t\t\t\t\t\t\tfunnelRight.shift();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpathPoints.push(funnelRight[0]);\r\n\t\t\t\t\t\tpathSides.set(funnelRight[0].id, -1);\r\n\t\t\t\t\t\tfunnelLeft.splice(0, funnelLeft.length);\r\n\t\t\t\t\t\tfunnelLeft.push(funnelRight[0], currPos);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunnelLeft.push(currPos);\r\n\t\t\t\tfor (j = funnelLeft.length - 3; j >= 0; j--) {\r\n\t\t\t\t\tdirection = DDLSGeom2D.getDirection(funnelLeft[j].x, funnelLeft[j].y, funnelLeft[j + 1].x, funnelLeft[j + 1].y, currPos.x, currPos.y);\r\n\t\t\t\t\tif (direction == 1)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tfunnelLeft.splice(j + 1, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// check if the goal is blocked by one funnel's right vertex\r\n\t\tvar blocked: boolean = false;\r\n\t\t//trace(\"check if the goal is blocked by one funnel right vertex\");\r\n\t\tfor (j = funnelRight.length - 2; j >= 0; j--) {\r\n\t\t\tdirection = DDLSGeom2D.getDirection(funnelRight[j].x, funnelRight[j].y, funnelRight[j + 1].x, funnelRight[j + 1].y, toX, toY);\r\n\t\t\t//trace(\"dir\", funnelRight[j].x, funnelRight[j].y, funnelRight[j+1].x, funnelRight[j+1].y, toX, toY);\r\n\t\t\tif (direction != 1) {\r\n\t\t\t\t//trace(\"goal access right blocked\");\r\n\t\t\t\t// access blocked\r\n\t\t\t\tfunnelRight.shift();\r\n\t\t\t\tfor (k = 0; k <= j; k++) {\r\n\t\t\t\t\tpathPoints.push(funnelRight[0]);\r\n\t\t\t\t\tpathSides.set(funnelRight[0].id, -1);\r\n\t\t\t\t\tfunnelRight.shift();\r\n\t\t\t\t}\r\n\t\t\t\tpathPoints.push(endPoint);\r\n\t\t\t\tpathSides.set(endPoint.id, 0);\r\n\t\t\t\tblocked = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!blocked) {\r\n\t\t\t// check if the goal is blocked by one funnel's left vertex\r\n\t\t\t//trace(\"check if the goal is blocked by one funnel left vertex\");\r\n\t\t\tfor (j = funnelLeft.length - 2; j >= 0; j--) {\r\n\t\t\t\tdirection = DDLSGeom2D.getDirection(funnelLeft[j].x, funnelLeft[j].y, funnelLeft[j + 1].x, funnelLeft[j + 1].y, toX, toY);\r\n\t\t\t\t//trace(\"dir\", funnelLeft[j].x, funnelLeft[j].y, funnelLeft[j+1].x, funnelLeft[j+1].y, toX, toY);\r\n\t\t\t\tif (direction != -1) {\r\n\t\t\t\t\t//trace(\"goal access left blocked\");\r\n\t\t\t\t\t// access blocked\r\n\t\t\t\t\tfunnelLeft.shift();\r\n\t\t\t\t\tfor (k = 0; k <= j; k++) {\r\n\t\t\t\t\t\tpathPoints.push(funnelLeft[0]);\r\n\t\t\t\t\t\tpathSides.set(funnelLeft[0].id, 1);\r\n\t\t\t\t\t\tfunnelLeft.shift();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpathPoints.push(endPoint);\r\n\t\t\t\t\tpathSides.set(endPoint.id, 0);\r\n\t\t\t\t\tblocked = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if not blocked, we consider the direct path\r\n\t\tif (!blocked) {\r\n\t\t\tpathPoints.push(endPoint);\r\n\t\t\tpathSides.set(endPoint.id, 0);\r\n\t\t\tblocked = true;\r\n\t\t}\r\n\r\n\t\t// if radius is non zero\r\n\t\tif (this.radius > 0) {\r\n\t\t\tvar adjustedPoints: Array<DDLSPoint2D> = new Array<DDLSPoint2D>();\r\n\t\t\tvar newPath: Array<DDLSPoint2D> = new Array<DDLSPoint2D>();\r\n\r\n\t\t\tif (pathPoints.length == 2) {\r\n\t\t\t\tthis.adjustWithTangents(pathPoints[0], false, pathPoints[1], false, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n\t\t\t}\r\n\t\t\telse if (pathPoints.length > 2) {\r\n\t\t\t\t// tangent from start point to 2nd point\r\n\t\t\t\tthis.adjustWithTangents(pathPoints[0], false, pathPoints[1], true, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n\r\n\t\t\t\t// tangents for intermediate points\r\n\t\t\t\tif (pathPoints.length > 3) {\r\n\t\t\t\t\tfor (i = 1; i <= pathPoints.length - 3; i++) {\r\n\t\t\t\t\t\tthis.adjustWithTangents(pathPoints[i], true, pathPoints[i + 1], true, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// tangent from last-1 point to end point\r\n\t\t\t\tvar pathLength: number = pathPoints.length;\r\n\t\t\t\tthis.adjustWithTangents(pathPoints[pathLength - 2], true, pathPoints[pathLength - 1], false, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n\t\t\t}\r\n\r\n\t\t\tnewPath.push(endPoint);\r\n\r\n\t\t\t// adjusted path can have useless tangents, we check it\r\n\t\t\tthis.checkAdjustedPath(newPath, adjustedPoints, pointSides);\r\n\r\n\t\t\tvar smoothPoints: Array<DDLSPoint2D> = new Array<DDLSPoint2D>();\r\n\t\t\tfor (i = newPath.length - 2; i >= 1; i--) {\r\n\t\t\t\tthis.smoothAngle(adjustedPoints[i * 2 - 1], newPath[i], adjustedPoints[i * 2], pointSides.get(newPath[i].id), smoothPoints);\r\n\t\t\t\twhile (smoothPoints.length) {\r\n\t\t\t\t\tadjustedPoints.splice(i * 2, 0, smoothPoints.pop());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tadjustedPoints = pathPoints;\r\n\t\t}\r\n\r\n\t\t// extract coordinates\r\n\t\tfor (i = 0; i < adjustedPoints.length; i++) {\r\n\t\t\t// resultPath.push(adjustedPoints[i].x);\r\n\t\t\t// resultPath.push(adjustedPoints[i].y);\r\n\t\t\tresultPath.push(adjustedPoints[i].clone());\r\n\t\t}\r\n\t}\r\n\r\n\tprivate adjustWithTangents(p1: DDLSPoint2D, applyRadiusToP1: boolean\r\n\t\t, p2: DDLSPoint2D, applyRadiusToP2: boolean\r\n\t\t, pointSides: Map<number,number>, pointSuccessor: Map<number,DDLSPoint2D>\r\n\t\t, newPath: Array<DDLSPoint2D>\r\n\t\t, adjustedPoints: Array<DDLSPoint2D>): void {\r\n\t\t// we find the tangent T between the points pathPoints[i] - pathPoints[i+1]\r\n\t\t// then we check the unused intermediate points between pathPoints[i] and pathPoints[i+1]\r\n\t\t// if a point P is too close from the segment, we replace T by 2 tangents T1, T2, between the points pathPoints[i] P and P - pathPoints[i+1]\r\n\r\n\t\t//trace(\"adjustWithTangents\");\r\n\r\n\t\tvar tangentsResult: Array<number> = new Array<number>();\r\n\r\n\t\tvar side1: number = pointSides.get(p1.id);\r\n\t\tvar side2: number = pointSides.get(p2.id);\r\n\r\n\t\tvar pTangent1: DDLSPoint2D;\r\n\t\tvar pTangent2: DDLSPoint2D;\r\n\r\n\t\t// if no radius application\r\n\t\tif (!applyRadiusToP1 && !applyRadiusToP2) {\r\n\t\t\t//trace(\"no radius applied\");\r\n\t\t\tpTangent1 = p1;\r\n\t\t\tpTangent2 = p2;\r\n\t\t}\r\n\t\t// we apply radius to p2 only\r\n\t\telse if (!applyRadiusToP1) {\r\n\t\t\t//trace(\"! applyRadiusToP1\");\r\n\t\t\tDDLSGeom2D.tangentsPointToCircle(p1.x, p1.y, p2.x, p2.y, this._radius, tangentsResult);\r\n\t\t\t// p2 lies on the left funnel\r\n\t\t\tif (side2 == 1) {\r\n\t\t\t\tpTangent1 = p1;\r\n\t\t\t\tpTangent2 = this.getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t}\r\n\t\t\t// p2 lies on the right funnel\r\n\t\t\telse {\r\n\t\t\t\tpTangent1 = p1;\r\n\t\t\t\tpTangent2 = this.getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// we apply radius to p1 only\r\n\t\telse if (!applyRadiusToP2) {\r\n\t\t\t//trace(\"! applyRadiusToP2\");\r\n\t\t\tDDLSGeom2D.tangentsPointToCircle(p2.x, p2.y, p1.x, p1.y, this._radius, tangentsResult);\r\n\t\t\t// p1 lies on the left funnel\r\n\t\t\tif (side1 == 1) {\r\n\t\t\t\tpTangent1 = this.getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t\tpTangent2 = p2;\r\n\t\t\t}\r\n\t\t\t// p1 lies on the right funnel\r\n\t\t\telse {\r\n\t\t\t\tpTangent1 = this.getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t\tpTangent2 = p2;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// we apply radius to both points\r\n\t\telse {\r\n\t\t\t//trace(\"we apply radius to both points\");\r\n\t\t\t// both points lie on left funnel\r\n\t\t\tif (side1 == 1 && side2 == 1) {\r\n\t\t\t\tDDLSGeom2D.tangentsParalCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult);\r\n\t\t\t\t// we keep the points of the right tangent\r\n\t\t\t\tpTangent1 = this.getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t\tpTangent2 = this.getPoint(tangentsResult[4], tangentsResult[5]);\r\n\t\t\t}\r\n\t\t\t// both points lie on right funnel\r\n\t\t\telse if (side1 == -1 && side2 == -1) {\r\n\t\t\t\tDDLSGeom2D.tangentsParalCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult);\r\n\t\t\t\t// we keep the points of the left tangent\r\n\t\t\t\tpTangent1 = this.getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t\tpTangent2 = this.getPoint(tangentsResult[6], tangentsResult[7]);\r\n\t\t\t}\r\n\t\t\t// 1st point lies on left funnel, 2nd on right funnel\r\n\t\t\telse if (side1 == 1 && side2 == -1) {\r\n\t\t\t\tif (DDLSGeom2D.tangentsCrossCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult)) {\r\n\t\t\t\t\t// we keep the points of the right-left tangent\r\n\t\t\t\t\tpTangent1 = this.getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t\t\tpTangent2 = this.getPoint(tangentsResult[6], tangentsResult[7]);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// NO TANGENT BECAUSE POINTS TOO CLOSE\r\n\t\t\t\t\t// A* MUST CHECK THAT !\r\n\t\t\t\t\tconsole.log(\"NO TANGENT, points are too close for radius\");\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 1st point lies on right funnel, 2nd on left funnel\r\n\t\t\telse {\r\n\t\t\t\tif (DDLSGeom2D.tangentsCrossCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult)) {\r\n\t\t\t\t\t// we keep the points of the left-right tangent\r\n\t\t\t\t\tpTangent1 = this.getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t\t\tpTangent2 = this.getPoint(tangentsResult[4], tangentsResult[5]);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// NO TANGENT BECAUSE POINTS TOO CLOSE\r\n\t\t\t\t\t// A* MUST CHECK THAT !\r\n\t\t\t\t\tconsole.log(\"NO TANGENT, points are too close for radius\");\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar successor: DDLSPoint2D = pointSuccessor.get(p1.id);\r\n\t\tvar distance: number;\r\n\t\twhile (successor != p2) {\r\n\t\t\tdistance = DDLSGeom2D.distanceSquaredPointToSegment(successor.x, successor.y, pTangent1.x, pTangent1.y, pTangent2.x, pTangent2.y);\r\n\t\t\tif (distance < this._radiusSquared) {\r\n\t\t\t\tthis.adjustWithTangents(p1, applyRadiusToP1, successor, true, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n\t\t\t\tthis.adjustWithTangents(successor, true, p2, applyRadiusToP2, pointSides, pointSuccessor, newPath, adjustedPoints);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tsuccessor = pointSuccessor.get(successor.id);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// we check distance in order to remove useless close points due to straight line subdivision\r\n\t\t/*if ( adjustedPoints.length > 0 )\r\n\t\t{\r\n\t\t\tvar distanceSquared:number;\r\n\t\t\tvar lastPoint:Point = adjustedPoints[adjustedPoints.length-1];\r\n\t\t\tdistanceSquared = (lastPoint.x - pTangent1.x)*(lastPoint.x - pTangent1.x) + (lastPoint.y - pTangent1.y)*(lastPoint.y - pTangent1.y);\r\n\t\t\tif (distanceSquared <= QEConstants.EPSILON_SQUARED)\r\n\t\t\t{\r\n\t\t\t\tadjustedPoints.pop();\r\n\t\t\t\tadjustedPoints.push(pTangent2);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}*/\r\n\t\tadjustedPoints.push(pTangent1, pTangent2);\r\n\t\tnewPath.push(p1);\r\n\t}\r\n\r\n\tprivate checkAdjustedPath(newPath: Array<DDLSPoint2D>, adjustedPoints: Array<DDLSPoint2D>, pointSides: Map<number,number>): void {\r\n\r\n\t\tvar needCheck: boolean = true;\r\n\r\n\t\tvar point0: DDLSPoint2D;\r\n\t\tvar point0Side: number;\r\n\t\tvar point1: DDLSPoint2D;\r\n\t\tvar point1Side: number;\r\n\t\tvar point2: DDLSPoint2D;\r\n\t\tvar point2Side: number;\r\n\r\n\t\tvar pt1: DDLSPoint2D;\r\n\t\tvar pt2: DDLSPoint2D;\r\n\t\tvar pt3: DDLSPoint2D;\r\n\t\tvar dot: number;\r\n\r\n\t\tvar tangentsResult: Array<number> = new Array<number>();\r\n\t\tvar pTangent1: DDLSPoint2D;\r\n\t\tvar pTangent2: DDLSPoint2D;\r\n\r\n\t\twhile (needCheck) {\r\n\t\t\tneedCheck = false;\r\n\t\t\tfor (var i: number = 2; i < newPath.length; i++) {\r\n\t\t\t\tpoint2 = newPath[i];\r\n\t\t\t\tpoint2Side = pointSides.get(point2.id);\r\n\t\t\t\tpoint1 = newPath[i - 1];\r\n\t\t\t\tpoint1Side = pointSides.get(point1.id);\r\n\t\t\t\tpoint0 = newPath[i - 2];\r\n\t\t\t\tpoint0Side = pointSides.get(point0.id);\r\n\r\n\t\t\t\tif (point1Side == point2Side) {\r\n\t\t\t\t\tpt1 = adjustedPoints[(i - 2) * 2];\r\n\t\t\t\t\tpt2 = adjustedPoints[(i - 1) * 2 - 1];\r\n\t\t\t\t\tpt3 = adjustedPoints[(i - 1) * 2];\r\n\t\t\t\t\tdot = (pt1.x - pt2.x) * (pt3.x - pt2.x) + (pt1.y - pt2.y) * (pt3.y - pt2.y)\r\n\t\t\t\t\tif (dot > 0) {\r\n\t\t\t\t\t\t//needCheck = true;\r\n\t\t\t\t\t\t//trace(\"dot > 0\");\r\n\t\t\t\t\t\t// rework the tangent\r\n\t\t\t\t\t\tif (i == 2) {\r\n\t\t\t\t\t\t\t// tangent from start point\r\n\t\t\t\t\t\t\tDDLSGeom2D.tangentsPointToCircle(point0.x, point0.y, point2.x, point2.y, this._radius, tangentsResult);\r\n\t\t\t\t\t\t\t// p2 lies on the left funnel\r\n\t\t\t\t\t\t\tif (point2Side == 1) {\r\n\t\t\t\t\t\t\t\tpTangent1 = point0;\r\n\t\t\t\t\t\t\t\tpTangent2 = this.getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tpTangent1 = point0;\r\n\t\t\t\t\t\t\t\tpTangent2 = this.getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (i == newPath.length - 1) {\r\n\t\t\t\t\t\t\t// tangent to end point\r\n\t\t\t\t\t\t\tDDLSGeom2D.tangentsPointToCircle(point2.x, point2.y, point0.x, point0.y, this._radius, tangentsResult);\r\n\t\t\t\t\t\t\t// p1 lies on the left funnel\r\n\t\t\t\t\t\t\tif (point0Side == 1) {\r\n\t\t\t\t\t\t\t\tpTangent1 = this.getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t\t\t\t\t\tpTangent2 = point2;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// p1 lies on the right funnel\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tpTangent1 = this.getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t\t\t\t\t\tpTangent2 = point2;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// 1st point lies on left funnel, 2nd on right funnel\r\n\t\t\t\t\t\t\tif (point0Side == 1 && point2Side == -1) {\r\n\t\t\t\t\t\t\t\t//trace(\"point0Side == 1 && point2Side == -1\");\r\n\t\t\t\t\t\t\t\tDDLSGeom2D.tangentsCrossCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult)\r\n\t\t\t\t\t\t\t\t// we keep the points of the right-left tangent\r\n\t\t\t\t\t\t\t\tpTangent1 = this.getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t\t\t\t\t\tpTangent2 = this.getPoint(tangentsResult[6], tangentsResult[7]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// 1st point lies on right funnel, 2nd on left funnel\r\n\t\t\t\t\t\t\telse if (point0Side == -1 && point2Side == 1) {\r\n\t\t\t\t\t\t\t\t//trace(\"point0Side == -1 && point2Side == 1\");\r\n\t\t\t\t\t\t\t\tDDLSGeom2D.tangentsCrossCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult)\r\n\t\t\t\t\t\t\t\t// we keep the points of the right-left tangent\r\n\t\t\t\t\t\t\t\tpTangent1 = this.getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t\t\t\t\t\tpTangent2 = this.getPoint(tangentsResult[4], tangentsResult[5]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// both points lie on left funnel\r\n\t\t\t\t\t\t\telse if (point0Side == 1 && point2Side == 1) {\r\n\t\t\t\t\t\t\t\t//trace(\"point0Side == 1 && point2Side == 1\");\r\n\t\t\t\t\t\t\t\tDDLSGeom2D.tangentsParalCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);\r\n\t\t\t\t\t\t\t\t// we keep the points of the right tangent\r\n\t\t\t\t\t\t\t\tpTangent1 = this.getPoint(tangentsResult[2], tangentsResult[3]);\r\n\t\t\t\t\t\t\t\tpTangent2 = this.getPoint(tangentsResult[4], tangentsResult[5]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// both points lie on right funnel\r\n\t\t\t\t\t\t\telse if (point0Side == -1 && point2Side == -1) {\r\n\t\t\t\t\t\t\t\t//trace(\"point0Side == -1 && point2Side == -1\");\r\n\t\t\t\t\t\t\t\tDDLSGeom2D.tangentsParalCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);\r\n\t\t\t\t\t\t\t\t// we keep the points of the right tangent\r\n\t\t\t\t\t\t\t\tpTangent1 = this.getPoint(tangentsResult[0], tangentsResult[1]);\r\n\t\t\t\t\t\t\t\tpTangent2 = this.getPoint(tangentsResult[6], tangentsResult[7]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tadjustedPoints.splice((i - 2) * 2, 1, pTangent1);\r\n\t\t\t\t\t\tadjustedPoints.splice(i * 2 - 1, 1, pTangent2);\r\n\r\n\t\t\t\t\t\t// delete useless point\r\n\t\t\t\t\t\tnewPath.splice(i - 1, 1);\r\n\t\t\t\t\t\tadjustedPoints.splice((i - 1) * 2 - 1, 2);\r\n\r\n\t\t\t\t\t\ttangentsResult.splice(0, tangentsResult.length);\r\n\t\t\t\t\t\ti--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate smoothAngle(prevPoint: DDLSPoint2D, pointToSmooth: DDLSPoint2D, nextPoint: DDLSPoint2D, side: number, encirclePoints: Array<DDLSPoint2D>): void {\r\n\t\tvar angleType: number = DDLSGeom2D.getDirection(prevPoint.x, prevPoint.y\r\n\t\t\t, pointToSmooth.x, pointToSmooth.y\r\n\t\t\t, nextPoint.x, nextPoint.y);\r\n\r\n\t\t/*\r\n\t\ttrace(\"smoothAngle\");\r\n\t\ttrace(\"angleType\", angleType);\r\n\t\ttrace(\"prevPoint\", prevPoint);\r\n\t\ttrace(\"pointToSmooth\", pointToSmooth);\r\n\t\ttrace(\"nextPoint\", nextPoint);\r\n\t\t*/\r\n\r\n\t\tvar distanceSquared: number = (prevPoint.x - nextPoint.x) * (prevPoint.x - nextPoint.x) + (prevPoint.y - nextPoint.y) * (prevPoint.y - nextPoint.y);\r\n\t\tif (distanceSquared <= this._sampleCircleDistanceSquared)\r\n\t\t\treturn;\r\n\r\n\t\tvar index: number = 0;\r\n\t\tvar side1: number;\r\n\t\tvar side2: number;\r\n\t\tvar pointInArea: boolean;\r\n\t\tvar xToCheck: number;\r\n\t\tvar yToCheck: number;\r\n\t\tfor (var i: number = 0; i < this._numSamplesCircle; i++) {\r\n\t\t\tpointInArea = false;\r\n\t\t\txToCheck = pointToSmooth.x + this._sampleCircle[i].x;\r\n\t\t\tyToCheck = pointToSmooth.y + this._sampleCircle[i].y;\r\n\t\t\tside1 = DDLSGeom2D.getDirection(prevPoint.x, prevPoint.y, pointToSmooth.x, pointToSmooth.y, xToCheck, yToCheck);\r\n\t\t\tside2 = DDLSGeom2D.getDirection(pointToSmooth.x, pointToSmooth.y, nextPoint.x, nextPoint.y, xToCheck, yToCheck);\r\n\r\n\t\t\t// if funnel left\r\n\t\t\tif (side == 1) {\r\n\t\t\t\t//trace(\"funnel side is 1\");\r\n\t\t\t\t// if angle is < 180\r\n\t\t\t\tif (angleType == -1) {\r\n\t\t\t\t\t//trace(\"angle type is -1\");\r\n\t\t\t\t\tif (side1 == -1 && side2 == -1)\r\n\t\t\t\t\t\tpointInArea = true;\r\n\t\t\t\t}\r\n\t\t\t\t// if angle is >= 180\r\n\t\t\t\telse {\r\n\t\t\t\t\t//trace(\"angle type is 1\")\r\n\t\t\t\t\tif (side1 == -1 || side2 == -1)\r\n\t\t\t\t\t\tpointInArea = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// if funnel right\r\n\t\t\telse {\r\n\t\t\t\t// if angle is < 180\r\n\t\t\t\tif (angleType == 1) {\r\n\t\t\t\t\tif (side1 == 1 && side2 == 1)\r\n\t\t\t\t\t\tpointInArea = true;\r\n\t\t\t\t}\r\n\t\t\t\t// if angle is >= 180\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (side1 == 1 || side2 == 1)\r\n\t\t\t\t\t\tpointInArea = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (pointInArea) {\r\n\t\t\t\tencirclePoints.splice(index, 0, new DDLSPoint2D(xToCheck, yToCheck));\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tindex = 0;\r\n\t\t\t// points in sample circle are CCW\r\n\t\t\t// so we inverse the order for right funnel\r\n\t\t}\r\n\t\tif (side == -1)\r\n\t\t\tencirclePoints.reverse();\r\n\t}\r\n}\r\n", "import { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSFace } from \"../data/DDLSFace\";\r\nimport { DDLSMesh } from \"../data/DDLSMesh\";\r\nimport { DDLSGeom2D } from \"../data/math/DDLSGeom2D\";\r\nimport { DDLSAStar } from \"./DDLSAStar\";\r\nimport { DDLSFunnel } from \"./DDLSFunnel\";\r\n\r\nexport class DDLSPathFinder {\r\n\r\n\tprivate _mesh: DDLSMesh;\r\n\tprivate _astar: DDLSAStar;\r\n\tprivate _funnel: DDLSFunnel;\r\n\t//\t\tprivate _entity:DDLSEntityAI;\r\n\tprivate _radius: number;\r\n\r\n\r\n\tprivate __listFaces: DDLSFace[];\r\n\tprivate __listEdges: DDLSEdge[];\r\n\r\n\t/**\r\n\t * \u5BFB\u8DEF\u5DE5\u5177 \r\n\t */\r\n\tconstructor() {\r\n\t\tthis._astar = new DDLSAStar();\r\n\t\tthis._funnel = new DDLSFunnel();\r\n\r\n\t\tthis.__listFaces = [];\r\n\t\tthis.__listEdges = [];\r\n\t}\r\n\r\n\tpublic dispose(): void {\r\n\t\tthis._mesh = null;\r\n\t\tthis._astar.dispose();\r\n\t\tthis._astar = null;\r\n\t\tthis._funnel.dispose();\r\n\t\tthis._funnel = null;\r\n\t\tthis.__listEdges = null;\r\n\t\tthis.__listFaces = null;\r\n\t}\r\n\r\n\t/*\t\tpublic get entity():DDLSEntityAI\r\n\t\t{\r\n\t\t\treturn this._entity;\r\n\t\t}\r\n\t\r\n\t\tpublic set this.entity(value:DDLSEntityAI):void\r\n\t\t{\r\n\t\t\tthis._entity = value;\r\n\t\t}*/\r\n\r\n\tpublic get mesh(): DDLSMesh {\r\n\t\treturn this._mesh;\r\n\t}\r\n\r\n\tpublic set mesh(value: DDLSMesh) {\r\n\t\tthis._mesh = value;\r\n\t\tthis._astar.mesh = this._mesh;\r\n\t}\r\n\r\n\tpublic findPath(startX: number, startY: number, toX: number, toY: number, resultPath: any[], radius: number = 0): boolean {\r\n\t\tresultPath.splice(0, resultPath.length);\r\n\r\n\t\tif (!this._mesh)\r\n\t\t\tthrow new Error(\"Mesh missing\");\r\n\t\t/*\t\t\tif (!this._entity)\r\n\t\t\t\t\tthrow new Error(\"Entity missing\");*/\r\n\r\n\t\tif (DDLSGeom2D.isCircleIntersectingAnyConstraint(toX, toY, radius, this._mesh)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tthis._astar.radius = radius;\r\n\t\tthis._funnel.radius = radius;\r\n\r\n\t\tthis.__listFaces.splice(0, this.__listFaces.length);\r\n\t\tthis.__listEdges.splice(0, this.__listEdges.length);\r\n\t\tthis._astar.findPath(startX, startY, toX, toY, this.__listFaces, this.__listEdges);\r\n\t\tif (this.__listFaces.length == 0) {\r\n\t\t\t//console.log(\"DDLSPathFinder this.__listFaces.length == 0\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tthis._funnel.findPath(startX, startY, toX, toY, this.__listFaces, this.__listEdges, resultPath);\r\n\t\treturn true;\r\n\t}\r\n}", "import { DDLSGraphNode } from \"./DDLSGraphNode\";\r\n\r\nexport class DDLSGraphEdge {\r\n\r\n\tprivate static INC: number = 0;\r\n\tprivate _id: number;\r\n\r\n\tprivate _prev: DDLSGraphEdge;\r\n\tprivate _next: DDLSGraphEdge;\r\n\r\n\tprivate _rotPrevEdge: DDLSGraphEdge;\r\n\tprivate _rotNextEdge: DDLSGraphEdge;\r\n\tprivate _oppositeEdge: DDLSGraphEdge;\r\n\tprivate _sourceNode: DDLSGraphNode;\r\n\tprivate _destinationNode: DDLSGraphNode;\r\n\r\n\tprivate _data: { sumDistancesSquared: number, length: number, nodesCount: number };\r\n\r\n\tconstructor() {\r\n\t\tthis._id = DDLSGraphEdge.INC;\r\n\t\tDDLSGraphEdge.INC++;\r\n\t}\r\n\r\n\tget id(): number {\r\n\t\treturn this._id;\r\n\t}\r\n\r\n\tdispose(): void {\r\n\t\tthis._prev = null;\r\n\t\tthis._next = null;\r\n\t\tthis._rotNextEdge = null;\r\n\t\tthis._rotNextEdge = null;\r\n\t\tthis._oppositeEdge = null;\r\n\t\tthis._sourceNode = null;\r\n\t\tthis._destinationNode;\r\n\t\tthis._data = null;\r\n\t}\r\n\r\n\tget prev(): DDLSGraphEdge {\r\n\t\treturn this._prev;\r\n\t}\r\n\r\n\tset prev(value: DDLSGraphEdge) {\r\n\t\tthis._prev = value;\r\n\t}\r\n\r\n\tget next(): DDLSGraphEdge {\r\n\t\treturn this._next;\r\n\t}\r\n\r\n\tset next(value: DDLSGraphEdge) {\r\n\t\tthis._next = value;\r\n\t}\r\n\r\n\tget rotPrevEdge(): DDLSGraphEdge {\r\n\t\treturn this._rotPrevEdge;\r\n\t}\r\n\r\n\tset rotPrevEdge(value: DDLSGraphEdge) {\r\n\t\tthis._rotPrevEdge = value;\r\n\t}\r\n\r\n\tget rotNextEdge(): DDLSGraphEdge {\r\n\t\treturn this._rotNextEdge;\r\n\t}\r\n\r\n\tset rotNextEdge(value: DDLSGraphEdge) {\r\n\t\tthis._rotNextEdge = value;\r\n\t}\r\n\r\n\tget oppositeEdge(): DDLSGraphEdge {\r\n\t\treturn this._oppositeEdge;\r\n\t}\r\n\r\n\tset oppositeEdge(value: DDLSGraphEdge) {\r\n\t\tthis._oppositeEdge = value;\r\n\t}\r\n\r\n\tget sourceNode(): DDLSGraphNode {\r\n\t\treturn this._sourceNode;\r\n\t}\r\n\r\n\tset sourceNode(value: DDLSGraphNode) {\r\n\t\tthis._sourceNode = value;\r\n\t}\r\n\r\n\tget destinationNode(): DDLSGraphNode {\r\n\t\treturn this._destinationNode;\r\n\t}\r\n\r\n\tset destinationNode(value: DDLSGraphNode) {\r\n\t\tthis._destinationNode = value;\r\n\t}\r\n\r\n\tget data(): { sumDistancesSquared: number, length: number, nodesCount: number } {\r\n\t\treturn this._data;\r\n\t}\r\n\r\n\tset data(value: { sumDistancesSquared: number, length: number, nodesCount: number }) {\r\n\t\tthis._data = value;\r\n\t}\r\n}\r\n", "import { DDLSPoint2D } from \"../math/DDLSPoint2D\";\r\nimport { DDLSGraphEdge } from \"./DDLSGraphEdge\";\r\n\r\n\r\nexport class DDLSGraphNode {\r\n\r\n\tprivate static INC: number = 0;\r\n\tprivate _id: number;\r\n\r\n\tprivate _prev: DDLSGraphNode;\r\n\tprivate _next: DDLSGraphNode;\r\n\r\n\tprivate _outgoingEdge: DDLSGraphEdge;\r\n\tprivate _successorNodes: Map<number,DDLSGraphEdge>;\r\n\r\n\tprivate _data: { index: number, point: DDLSPoint2D };\r\n\r\n\tconstructor() {\r\n\t\tthis._id = DDLSGraphNode.INC;\r\n\t\tDDLSGraphNode.INC++;\r\n\r\n\t\tthis._successorNodes = new Map<number,DDLSGraphEdge>();\r\n\t}\r\n\r\n\tget id(): number {\r\n\t\treturn this._id;\r\n\t}\r\n\r\n\tdispose(): void {\r\n\t\tthis._prev = null;\r\n\t\tthis._next = null;\r\n\t\tthis._outgoingEdge = null;\r\n\t\tthis._successorNodes = null;\r\n\t\tthis._data = null;\r\n\t}\r\n\r\n\tget prev(): DDLSGraphNode {\r\n\t\treturn this._prev;\r\n\t}\r\n\r\n\tset prev(value: DDLSGraphNode) {\r\n\t\tthis._prev = value;\r\n\t}\r\n\r\n\tget next(): DDLSGraphNode {\r\n\t\treturn this._next;\r\n\t}\r\n\r\n\tset next(value: DDLSGraphNode) {\r\n\t\tthis._next = value;\r\n\t}\r\n\r\n\tget outgoingEdge(): DDLSGraphEdge {\r\n\t\treturn this._outgoingEdge;\r\n\t}\r\n\r\n\tset outgoingEdge(value: DDLSGraphEdge) {\r\n\t\tthis._outgoingEdge = value;\r\n\t}\r\n\r\n\tget successorNodes(): Map<number,DDLSGraphEdge> {\r\n\t\treturn this._successorNodes;\r\n\t}\r\n\r\n\tset successorNodes(value: Map<number,DDLSGraphEdge>) {\r\n\t\tthis._successorNodes = value;\r\n\t}\r\n\r\n\tget data(): { index: number, point: DDLSPoint2D } {\r\n\t\treturn this._data;\r\n\t}\r\n\r\n\tset data(value: { index: number, point: DDLSPoint2D }) {\r\n\t\tthis._data = value;\r\n\t}\r\n}\r\n", "import { DDLSGraphEdge } from \"./DDLSGraphEdge\";\r\nimport { DDLSGraphNode } from \"./DDLSGraphNode\";\r\n\r\n\r\nexport class DDLSGraph {\r\n\r\n\tprivate static INC: number = 0;\r\n\tprivate _id: number;\r\n\r\n\tprivate _node: DDLSGraphNode;\r\n\tprivate _edge: DDLSGraphEdge;\r\n\r\n\tconstructor() {\r\n\t\tthis._id = DDLSGraph.INC;\r\n\t\tDDLSGraph.INC++;\r\n\t}\r\n\r\n\tget id(): number {\r\n\t\treturn this._id;\r\n\t}\r\n\r\n\tdispose(): void {\r\n\t\twhile (this._node) {\r\n\t\t\tthis.deleteNode(this._node);\r\n\t\t}\r\n\t}\r\n\r\n\tget edge(): DDLSGraphEdge {\r\n\t\treturn this._edge;\r\n\t}\r\n\r\n\tget node(): DDLSGraphNode {\r\n\t\treturn this._node;\r\n\t}\r\n\r\n\tinsertNode(): DDLSGraphNode {\r\n\t\tlet node: DDLSGraphNode = new DDLSGraphNode();\r\n\t\tif (this._node) {\r\n\t\t\tnode.next = this._node;\r\n\t\t\tthis._node.prev = node;\r\n\t\t}\r\n\t\tthis._node = node;\r\n\r\n\t\treturn node;\r\n\t}\r\n\r\n\tdeleteNode(node: DDLSGraphNode): void {\r\n\t\twhile (node.outgoingEdge) {\r\n\t\t\tif (node.outgoingEdge.oppositeEdge) {\r\n\t\t\t\tthis.deleteEdge(node.outgoingEdge.oppositeEdge);\r\n\t\t\t}\r\n\t\t\tthis.deleteEdge(node.outgoingEdge);\r\n\t\t}\r\n\r\n\t\tlet otherNode: DDLSGraphNode = this._node;\r\n\t\tlet incomingEdge: DDLSGraphEdge;\r\n\t\twhile (otherNode) {\r\n\t\t\tincomingEdge = otherNode.successorNodes.get(node.id);\r\n\t\t\tif (incomingEdge) {\r\n\t\t\t\tthis.deleteEdge(incomingEdge);\r\n\t\t\t}\r\n\t\t\totherNode = otherNode.next;\r\n\t\t}\r\n\r\n\t\tif (this._node == node) {\r\n\t\t\tif (node.next) {\r\n\t\t\t\tnode.next.prev = null;\r\n\t\t\t\tthis._node = node.next;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis._node = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (node.next) {\r\n\t\t\t\tnode.prev.next = node.next;\r\n\t\t\t\tnode.next.prev = node.prev;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tnode.prev.next = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnode.dispose();\r\n\t}\r\n\r\n\tinsertEdge(fromNode: DDLSGraphNode, toNode: DDLSGraphNode): DDLSGraphEdge {\r\n\t\tif (fromNode.successorNodes.has(toNode.id))\r\n\t\t\treturn null;\r\n\r\n\t\tlet edge: DDLSGraphEdge = new DDLSGraphEdge();\r\n\t\tif (this._edge) {\r\n\t\t\tthis._edge.prev = edge;\r\n\t\t\tedge.next = this._edge;\r\n\t\t}\r\n\t\tthis._edge = edge;\r\n\r\n\t\tedge.sourceNode = fromNode;\r\n\t\tedge.destinationNode = toNode;\r\n\t\tfromNode.successorNodes.set(toNode.id, edge);\r\n\t\tif (fromNode.outgoingEdge) {\r\n\t\t\tfromNode.outgoingEdge.rotPrevEdge = edge;\r\n\t\t\tedge.rotNextEdge = fromNode.outgoingEdge;\r\n\t\t\tfromNode.outgoingEdge = edge;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfromNode.outgoingEdge = edge;\r\n\t\t}\r\n\r\n\t\tlet oppositeEdge: DDLSGraphEdge = toNode.successorNodes.get(fromNode.id);\r\n\t\tif (oppositeEdge) {\r\n\t\t\tedge.oppositeEdge = oppositeEdge;\r\n\t\t\toppositeEdge.oppositeEdge = edge;\r\n\t\t}\r\n\r\n\t\treturn edge;\r\n\t}\r\n\r\n\tdeleteEdge(edge: DDLSGraphEdge): void {\r\n\t\tedge.sourceNode.successorNodes.delete(edge.destinationNode.id);\r\n\r\n\t\tif (this._edge == edge) {\r\n\t\t\tif (edge.next) {\r\n\t\t\t\tedge.next.prev = null;\r\n\t\t\t\tthis._edge = edge.next;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis._edge = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (edge.next) {\r\n\t\t\t\tedge.prev.next = edge.next;\r\n\t\t\t\tedge.next.prev = edge.prev;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tedge.prev.next = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (edge.sourceNode.outgoingEdge == edge) {\r\n\t\t\tif (edge.rotNextEdge) {\r\n\t\t\t\tedge.rotNextEdge.rotPrevEdge = null;\r\n\t\t\t\tedge.sourceNode.outgoingEdge = edge.rotNextEdge;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tedge.sourceNode.outgoingEdge = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (edge.rotNextEdge) {\r\n\t\t\t\tedge.rotPrevEdge.rotNextEdge = edge.rotNextEdge;\r\n\t\t\t\tedge.rotNextEdge.rotPrevEdge = edge.rotPrevEdge;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tedge.rotPrevEdge.rotNextEdge = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tedge.dispose();\r\n\t}\r\n\r\n}", "import { DDLSConstraintShape } from \"./DDLSConstraintShape\";\r\nimport { DDLSEdge } from \"./DDLSEdge\";\r\n\r\n\r\nexport class DDLSConstraintSegment {\r\n\r\n\tprivate static INC: number = 0;\r\n\tprivate _id: number;\r\n\r\n\tprivate _edges: DDLSEdge[];\r\n\tprivate _fromShape: DDLSConstraintShape;\r\n\r\n\tconstructor() {\r\n\t\tthis._id = DDLSConstraintSegment.INC;\r\n\t\tDDLSConstraintSegment.INC++;\r\n\r\n\t\tthis._edges = [];\r\n\t}\r\n\r\n\tpublic get id(): number {\r\n\t\treturn this._id;\r\n\t}\r\n\r\n\tpublic get fromShape(): DDLSConstraintShape {\r\n\t\treturn this._fromShape;\r\n\t}\r\n\r\n\tpublic set fromShape(value: DDLSConstraintShape) {\r\n\t\tthis._fromShape = value;\r\n\t}\r\n\r\n\tpublic addEdge(edge: DDLSEdge): void {\r\n\t\tif (this._edges.indexOf(edge) == -1 && this._edges.indexOf(edge.oppositeEdge) == -1)\r\n\t\t\tthis._edges.push(edge);\r\n\t}\r\n\r\n\tpublic removeEdge(edge: DDLSEdge): void {\r\n\t\tvar index: number;\r\n\t\tindex = this._edges.indexOf(edge);\r\n\t\tif (index == -1)\r\n\t\t\tindex = this._edges.indexOf(edge.oppositeEdge);\r\n\r\n\t\tif (index != -1)\r\n\t\t\tthis._edges.splice(index, 1);\r\n\t}\r\n\r\n\tpublic get edges(): DDLSEdge[] {\r\n\t\treturn this._edges;\r\n\t}\r\n\r\n\tpublic dispose(): void {\r\n\t\tthis._edges = null;\r\n\t\tthis._fromShape = null;\r\n\t}\r\n\r\n\tpublic toString(): string {\r\n\t\treturn \"seg_id \" + this._id;\r\n\t}\r\n\r\n}", "import { DDLSConstraintSegment } from \"./DDLSConstraintSegment\";\r\n\r\nexport class DDLSConstraintShape {\r\n\r\n\tprivate static INC: number = 0;\r\n\tprivate _id: number;\r\n\r\n\tprivate _segments: DDLSConstraintSegment[];\r\n\r\n\tconstructor() {\r\n\t\tthis._id = DDLSConstraintShape.INC;\r\n\t\tDDLSConstraintShape.INC++;\r\n\r\n\t\tthis._segments = [];\r\n\t}\r\n\r\n\tpublic get id(): number {\r\n\t\treturn this._id;\r\n\t}\r\n\r\n\tpublic get segments(): DDLSConstraintSegment[] {\r\n\t\treturn this._segments;\r\n\t}\r\n\r\n\tpublic dispose(): void {\r\n\t\twhile (this._segments.length > 0)\r\n\t\t\tthis._segments.pop().dispose();\r\n\t\tthis._segments = null;\r\n\t}\r\n\r\n}", "import { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSVertex } from \"../data/DDLSVertex\";\r\n\r\n\r\n\r\nexport class IteratorFromVertexToOutgoingEdges\r\n{\r\n\t\r\n\tprivate _fromVertex:DDLSVertex;\r\n\tprivate _nextEdge:DDLSEdge;\r\n\t\r\n\tpublic realEdgesOnly:boolean = true;\r\n\t\r\n\tconstructor()\r\n\t{\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic set fromVertex( value:DDLSVertex )\r\n\t{\r\n\t\tthis._fromVertex = value;\r\n\t\tthis._nextEdge = this._fromVertex.edge;\r\n\r\n\t\tif(this._nextEdge == undefined || this._nextEdge.isReal == undefined)\r\n\t\t\tthrow \"aaa\";\r\n\t\t\t\r\n\r\n\t\twhile ( this.realEdgesOnly && ! this._nextEdge.isReal )\r\n\t\t{\r\n\t\t\tthis._nextEdge = this._nextEdge.rotLeftEdge;\r\n\r\n\t\t\tif(this._nextEdge == undefined || this._nextEdge.isReal == undefined)\r\n\t\t\t\tthrow \"aaa\";\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate _resultEdge:DDLSEdge;\r\n\tpublic next():DDLSEdge\r\n\t{\r\n\t\tif (this._nextEdge)\r\n\t\t{\r\n\t\t\tthis._resultEdge = this._nextEdge;\r\n\t\t\tdo\r\n\t\t\t{\r\n\t\t\t\tthis._nextEdge = this._nextEdge.rotLeftEdge;\r\n\t\t\t\tif ( this._nextEdge == this._fromVertex.edge )\r\n\t\t\t\t{\r\n\t\t\t\t\tthis._nextEdge = null;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile ( this.realEdgesOnly && ! this._nextEdge.isReal )\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis._resultEdge = null;\r\n\t\t}\r\n\t\t\r\n\t\treturn this._resultEdge;\r\n\t}\r\n\t\r\n}", "import { DDLSObject } from \"./DDLSObject\";\r\nimport { DDLSVertex } from \"./DDLSVertex\";\r\nimport { DDLSFace } from \"./DDLSFace\";\r\nimport { DDLSEdge } from \"./DDLSEdge\";\r\nimport { DDLSConstraintShape } from \"./DDLSConstraintShape\";\r\nimport { DDLSConstraintSegment } from \"./DDLSConstraintSegment\";\r\nimport { DDLSConstants } from \"./DDLSConstants\";\r\nimport { DDLSGeom2D } from \"./math/DDLSGeom2D\";\r\nimport { DDLSPoint2D } from \"./math/DDLSPoint2D\";\r\nimport { DDLSMatrix2D } from \"./math/DDLSMatrix2D\";\r\nimport { IteratorFromVertexToOutgoingEdges } from \"../iterators/IteratorFromVertexToOutgoingEdges\";\r\n\r\n\r\nexport class DDLSMesh {\r\n\r\n    private static INC: number = 0;\r\n    private _id: number;\r\n\r\n    private _width: number;\r\n    private _height: number;\r\n    private _clipping: boolean;\r\n\r\n    private _vertices: DDLSVertex[];\r\n    private _edges: EdgeMap;\r\n    private _faces: FaceMap;\r\n    private _constraintShapes: DDLSConstraintShape[];\r\n    private _objects: DDLSObject[];\r\n\r\n    // keep references of center vertex and bounding edges when split, useful to restore <Delaunay> edges\r\n    private __centerVertex: DDLSVertex;\r\n    private __edgesToCheck: DDLSEdge[];\r\n\r\n    constructor(width: number, height: number) {\r\n        this._id = DDLSMesh.INC;\r\n        DDLSMesh.INC++;\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n        this._clipping = true;\r\n\r\n        this._vertices = [];\r\n        this._edges = new EdgeMap();\r\n        this._faces = new FaceMap();\r\n        this._constraintShapes = [];\r\n        this._objects = [];\r\n\r\n        this.__edgesToCheck = [];\r\n    }\r\n\r\n    public get height(): number {\r\n        return this._height;\r\n    }\r\n\r\n    public get width(): number {\r\n        return this._width;\r\n    }\r\n\r\n    public get clipping(): boolean {\r\n        return this._clipping;\r\n    }\r\n\r\n    public set clipping(value: boolean) {\r\n        this._clipping = value;\r\n    }\r\n\r\n    public get id(): number {\r\n        return this._id;\r\n    }\r\n\r\n    public dispose(): void {\r\n        while (this._vertices.length > 0)\r\n            this._vertices.pop().dispose();\r\n        this._vertices = null;\r\n\r\n        this._edges.dispose();\r\n        this._edges = null;\r\n        this._faces.dispose();\r\n        this._faces = null;\r\n        while (this._constraintShapes.length > 0)\r\n            this._constraintShapes.pop().dispose();\r\n        this._constraintShapes = null;\r\n        while (this._objects.length > 0)\r\n            this._objects.pop().dispose();\r\n        this._objects = null;\r\n\r\n        this.__edgesToCheck = null;\r\n        this.__centerVertex = null;\r\n    }\r\n\r\n    public get __vertices(): DDLSVertex[] {\r\n        return this._vertices;\r\n    }\r\n\r\n    public get __edges(): DDLSEdge[] {\r\n        return this._edges.vector;\r\n    }\r\n\r\n    public get __faces(): DDLSFace[] {\r\n        return this._faces.vector;\r\n    }\r\n\r\n    public get __constraintShapes(): DDLSConstraintShape[] {\r\n        return this._constraintShapes;\r\n    }\r\n\r\n    public buildFromRecord(rec: string): void {\r\n        var positions: any[] = rec.split(';');\r\n        for (var i: number = 0; i < positions.length; i += 4) {\r\n            this.insertConstraintSegment(Number(positions[i]), Number(positions[i + 1]), Number(positions[i + 2]), Number(positions[i + 3]));\r\n        }\r\n    }\r\n\r\n    public insertObject(object: DDLSObject): void {\r\n        if (object.constraintShape)\r\n            this.deleteObject(object);\r\n\r\n        var shape: DDLSConstraintShape = new DDLSConstraintShape();\r\n        var segment: DDLSConstraintSegment;\r\n        var coordinates: number[] = object.coordinates;\r\n        var m: DDLSMatrix2D = object.matrix;\r\n\r\n        object.updateMatrixFromValues();\r\n        var x1: number;\r\n        var y1: number;\r\n        var x2: number;\r\n        var y2: number;\r\n        var transfx1: number;\r\n        var transfy1: number;\r\n        var transfx2: number;\r\n        var transfy2: number;\r\n\r\n        for (var i: number = 0; i < coordinates.length; i += 4) {\r\n            x1 = coordinates[i];\r\n            y1 = coordinates[i + 1];\r\n            x2 = coordinates[i + 2];\r\n            y2 = coordinates[i + 3];\r\n            transfx1 = m.transformX(x1, y1);\r\n            transfy1 = m.transformY(x1, y1);\r\n            transfx2 = m.transformX(x2, y2);\r\n            transfy2 = m.transformY(x2, y2);\r\n\r\n            segment = this.insertConstraintSegment(transfx1, transfy1, transfx2, transfy2);\r\n            if (segment) {\r\n                segment.fromShape = shape;\r\n                shape.segments.push(segment);\r\n            }\r\n        }\r\n\r\n        this._constraintShapes.push(shape);\r\n        object.constraintShape = shape;\r\n\r\n        if (!this.__objectsUpdateInProgress) {\r\n            this._objects.push(object);\r\n        }\r\n    }\r\n\r\n    public deleteAllObject(): void {\r\n        while (this._objects.length > 0) {\r\n            let obj = this._objects.pop();\r\n            this.deleteObject(obj);\r\n        }\r\n    }\r\n\r\n    public deleteObject(object: DDLSObject): void {\r\n        if (!object.constraintShape)\r\n            return;\r\n\r\n        this.deleteConstraintShape(object.constraintShape);\r\n        object.constraintShape = null;\r\n\r\n        if (!this.__objectsUpdateInProgress) {\r\n            var index: number = this._objects.indexOf(object);\r\n            this._objects.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private __objectsUpdateInProgress: boolean;\r\n    public updateObjects(): void {\r\n        this.__objectsUpdateInProgress = true;\r\n        for (var i: number = 0; i < this._objects.length; i++) {\r\n            if (this._objects[i].hasChanged) {\r\n                this.deleteObject(this._objects[i]);\r\n                this.insertObject(this._objects[i]);\r\n                this._objects[i].hasChanged = false;\r\n            }\r\n        }\r\n        this.__objectsUpdateInProgress = false;\r\n    }\r\n\r\n    // insert a new collection of constrained edges.\r\n    // Coordinates parameter is a list with form [x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, ....]\r\n    // where each 4-uple sequence (xi, yi, xi+1, yi+1) is a constraint segment (with i % 4 == 0)\r\n    // and where each couple sequence (xi, yi) is a point.\r\n    // Segments are not necessary connected.\r\n    // Segments can overlap (then they will be automaticaly subdivided).\r\n    public insertConstraintShape(coordinates: number[]): DDLSConstraintShape {\r\n        var shape: DDLSConstraintShape = new DDLSConstraintShape();\r\n        var segment: DDLSConstraintSegment;\r\n\r\n        for (var i: number = 0; i < coordinates.length; i += 4) {\r\n            segment = this.insertConstraintSegment(coordinates[i], coordinates[i + 1], coordinates[i + 2], coordinates[i + 3]);\r\n            if (segment) {\r\n                segment.fromShape = shape;\r\n                shape.segments.push(segment);\r\n            }\r\n        }\r\n\r\n        this._constraintShapes.push(shape);\r\n\r\n        return shape;\r\n    }\r\n\r\n    public deleteConstraintShape(shape: DDLSConstraintShape): void {\r\n        if (shape.segments) {\r\n            for (var i: number = 0; i < shape.segments.length; i++) {\r\n                this.deleteConstraintSegment(shape.segments[i]);\r\n            }\r\n        }\r\n\r\n        shape.dispose();\r\n\r\n        this._constraintShapes.splice(this._constraintShapes.indexOf(shape), 1);\r\n    }\r\n\r\n    public insertConstraintSegment(x1: number, y1: number, x2: number, y2: number): DDLSConstraintSegment {\r\n        // we clip against AABB\r\n        var newX1: number = x1;\r\n        var newY1: number = y1;\r\n        var newX2: number = x2;\r\n        var newY2: number = y2;\r\n\r\n        if ((x1 > this._width && x2 > this._width)\r\n            || (x1 < 0 && x2 < 0)\r\n            || (y1 > this._height && y2 > this._height)\r\n            || (y1 < 0 && y2 < 0)) {\r\n            return null;\r\n        }\r\n        else {\r\n            var nx: number = x2 - x1;\r\n            var ny: number = y2 - y1;\r\n\r\n            var tmin: number = Number.NEGATIVE_INFINITY;\r\n            var tmax: number = Number.POSITIVE_INFINITY;\r\n\r\n            if (nx != 0.0) {\r\n                var tx1: number = (0 - x1) / nx;\r\n                var tx2: number = (this._width - x1) / nx;\r\n\r\n                tmin = Math.max(tmin, Math.min(tx1, tx2));\r\n                tmax = Math.min(tmax, Math.max(tx1, tx2));\r\n            }\r\n\r\n            if (ny != 0.0) {\r\n                var ty1: number = (0 - y1) / ny;\r\n                var ty2: number = (this._height - y1) / ny;\r\n\r\n                tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n                tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n            }\r\n\r\n            if (tmax >= tmin) {\r\n\r\n                if (tmax < 1) {\r\n                    //Clip end point\r\n                    newX2 = nx * tmax + x1;\r\n                    newY2 = ny * tmax + y1;\r\n                }\r\n\r\n                if (tmin > 0) {\r\n                    //Clip start point\r\n                    newX1 = nx * tmin + x1;\r\n                    newY1 = ny * tmin + y1;\r\n                }\r\n            }\r\n            else\r\n                return null;\r\n        }\r\n\r\n        // we this.check the vertices insertions\r\n        var vertexDown: DDLSVertex = this.insertVertex(newX1, newY1);\r\n        if (!vertexDown)\r\n            return null;\r\n        var vertexUp: DDLSVertex = this.insertVertex(newX2, newY2);\r\n        if (!vertexUp)\r\n            return null;\r\n        if (vertexDown == vertexUp)\r\n            return null;\r\n\r\n        //console.log(\"vertices\", vertexDown.id, vertexUp.id)\r\n\r\n        // useful\r\n        var iterVertexToOutEdges: IteratorFromVertexToOutgoingEdges = new IteratorFromVertexToOutgoingEdges();\r\n        var currVertex: DDLSVertex;\r\n        var currEdge: DDLSEdge;\r\n        var i: number;\r\n\r\n        // the new constraint segment\r\n        var segment: DDLSConstraintSegment = new DDLSConstraintSegment();\r\n\r\n        var tempEdgeDownUp: DDLSEdge = new DDLSEdge();\r\n        var tempSdgeUpDown: DDLSEdge = new DDLSEdge();\r\n        tempEdgeDownUp.setDatas(vertexDown, tempSdgeUpDown, null, null, true, true);\r\n        tempSdgeUpDown.setDatas(vertexUp, tempEdgeDownUp, null, null, true, true);\r\n\r\n        var intersectedEdges: DDLSEdge[] = [];\r\n        var leftBoundingEdges: DDLSEdge[] = [];\r\n        var rightBoundingEdges: DDLSEdge[] = [];\r\n\r\n        var currObjet: Object;\r\n        var pIntersect: DDLSPoint2D = new DDLSPoint2D();\r\n        var edgeLeft: DDLSEdge;\r\n        var newEdgeDownUp: DDLSEdge;\r\n        var newEdgeUpDown: DDLSEdge;\r\n        var done: boolean;\r\n        currVertex = vertexDown;\r\n        currObjet = currVertex;\r\n        while (true) {\r\n            done = false;\r\n            currVertex = <DDLSVertex>currObjet;\r\n            if (currVertex instanceof DDLSVertex) {\r\n                //console.log(\"case vertex\");\r\n                iterVertexToOutEdges.fromVertex = currVertex;\r\n                while (currEdge = iterVertexToOutEdges.next()) {\r\n                    // if we meet directly the end vertex\r\n                    if (currEdge.destinationVertex == vertexUp) {\r\n                        //console.log(\"we met the end vertex\");\r\n                        if (!currEdge.isConstrained) {\r\n                            currEdge.isConstrained = true;\r\n                            currEdge.oppositeEdge.isConstrained = true;\r\n                        }\r\n                        currEdge.addFromConstraintSegment(segment);\r\n                        currEdge.oppositeEdge.fromConstraintSegments = currEdge.fromConstraintSegments;\r\n                        vertexDown.addFromConstraintSegment(segment);\r\n                        vertexUp.addFromConstraintSegment(segment);\r\n                        segment.addEdge(currEdge);\r\n                        return segment;\r\n                    }\r\n                    // if we meet a vertex\r\n                    if (DDLSGeom2D.distanceSquaredVertexToEdge(currEdge.destinationVertex, tempEdgeDownUp) <= DDLSConstants.EPSILON_SQUARED) {\r\n                        //console.log(\"we met a vertex\");\r\n                        if (!currEdge.isConstrained) {\r\n                            //console.log(\"edge is not constrained\");\r\n                            currEdge.isConstrained = true;\r\n                            currEdge.oppositeEdge.isConstrained = true;\r\n                        }\r\n                        currEdge.addFromConstraintSegment(segment);\r\n                        currEdge.oppositeEdge.fromConstraintSegments = currEdge.fromConstraintSegments;\r\n                        vertexDown.addFromConstraintSegment(segment);\r\n                        segment.addEdge(currEdge);\r\n                        vertexDown = currEdge.destinationVertex;\r\n                        tempEdgeDownUp.originVertex = vertexDown;\r\n                        currObjet = vertexDown;\r\n                        done = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (done)\r\n                    continue;\r\n\r\n                iterVertexToOutEdges.fromVertex = currVertex;\r\n                currEdge = iterVertexToOutEdges.next();\r\n                while (currEdge) {\r\n                    currEdge = currEdge.nextLeftEdge;\r\n                    if (DDLSGeom2D.intersections2edges(currEdge, tempEdgeDownUp, pIntersect)) {\r\n                        //console.log(\"edge intersection\");\r\n                        if (currEdge.isConstrained) {\r\n                            //console.log(\"edge is constrained\");\r\n                            vertexDown = this.splitEdge(currEdge, pIntersect.x, pIntersect.y);\r\n                            iterVertexToOutEdges.fromVertex = currVertex;\r\n                            currEdge = iterVertexToOutEdges.next();\r\n                            while (currEdge) {\r\n                                if (currEdge.destinationVertex == vertexDown) {\r\n                                    currEdge.isConstrained = true;\r\n                                    currEdge.oppositeEdge.isConstrained = true;\r\n                                    currEdge.addFromConstraintSegment(segment);\r\n                                    currEdge.oppositeEdge.fromConstraintSegments = currEdge.fromConstraintSegments;\r\n                                    segment.addEdge(currEdge);\r\n                                    break;\r\n                                }\r\n                                currEdge = iterVertexToOutEdges.next();\r\n                            }\r\n                            currVertex.addFromConstraintSegment(segment);\r\n                            tempEdgeDownUp.originVertex = vertexDown;\r\n                            currObjet = vertexDown;\r\n                        }\r\n                        else {\r\n                            //console.log(\"edge is not constrained\");\r\n                            intersectedEdges.push(currEdge);\r\n                            leftBoundingEdges.unshift(currEdge.nextLeftEdge);\r\n                            rightBoundingEdges.push(currEdge.prevLeftEdge);\r\n                            currEdge = currEdge.oppositeEdge; // we keep the edge from left to right\r\n                            currObjet = currEdge;\r\n                        }\r\n                        break;\r\n                    }\r\n                    currEdge = iterVertexToOutEdges.next();\r\n                }\r\n            }\r\n            else if (currObjet instanceof DDLSEdge && (currEdge = <DDLSEdge>currObjet)) {\r\n                //console.log(\"case edge\");\r\n                edgeLeft = currEdge.nextLeftEdge;\r\n                if (edgeLeft.destinationVertex == vertexUp) {\r\n                    //console.log(\"end point reached\");\r\n                    leftBoundingEdges.unshift(edgeLeft.nextLeftEdge);\r\n                    rightBoundingEdges.push(edgeLeft);\r\n\r\n                    newEdgeDownUp = new DDLSEdge();\r\n                    newEdgeUpDown = new DDLSEdge();\r\n                    newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);\r\n                    newEdgeUpDown.setDatas(vertexUp, newEdgeDownUp, null, null, true, true);\r\n                    leftBoundingEdges.push(newEdgeDownUp);\r\n                    rightBoundingEdges.push(newEdgeUpDown);\r\n                    this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);\r\n\r\n                    return segment;\r\n                }\r\n                else if (DDLSGeom2D.distanceSquaredVertexToEdge(edgeLeft.destinationVertex, tempEdgeDownUp) <= DDLSConstants.EPSILON_SQUARED) {\r\n                    //console.log(\"we met a vertex\");\r\n                    leftBoundingEdges.unshift(edgeLeft.nextLeftEdge);\r\n                    rightBoundingEdges.push(edgeLeft);\r\n\r\n                    newEdgeDownUp = new DDLSEdge();\r\n                    newEdgeUpDown = new DDLSEdge();\r\n                    newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);\r\n                    newEdgeUpDown.setDatas(edgeLeft.destinationVertex, newEdgeDownUp, null, null, true, true);\r\n                    leftBoundingEdges.push(newEdgeDownUp);\r\n                    rightBoundingEdges.push(newEdgeUpDown);\r\n                    this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);\r\n\r\n                    intersectedEdges.splice(0, intersectedEdges.length);\r\n                    leftBoundingEdges.splice(0, leftBoundingEdges.length);\r\n                    rightBoundingEdges.splice(0, rightBoundingEdges.length);\r\n\r\n                    vertexDown = edgeLeft.destinationVertex;\r\n                    tempEdgeDownUp.originVertex = vertexDown;\r\n                    currObjet = vertexDown;\r\n                }\r\n                else {\r\n                    if (DDLSGeom2D.intersections2edges(edgeLeft, tempEdgeDownUp, pIntersect)) {\r\n                        //console.log(\"1st left edge intersected\");\r\n                        if (edgeLeft.isConstrained) {\r\n                            //console.log(\"edge is constrained\");\r\n                            currVertex = this.splitEdge(edgeLeft, pIntersect.x, pIntersect.y);\r\n\r\n                            iterVertexToOutEdges.fromVertex = currVertex;\r\n                            currEdge = iterVertexToOutEdges.next();\r\n                            while (currEdge) {\r\n                                if (currEdge.destinationVertex == leftBoundingEdges[0].originVertex) {\r\n                                    leftBoundingEdges.unshift(currEdge);\r\n                                }\r\n                                if (currEdge.destinationVertex == rightBoundingEdges[rightBoundingEdges.length - 1].destinationVertex) {\r\n                                    rightBoundingEdges.push(currEdge.oppositeEdge);\r\n                                }\r\n                                currEdge = iterVertexToOutEdges.next();\r\n                            }\r\n\r\n                            newEdgeDownUp = new DDLSEdge();\r\n                            newEdgeUpDown = new DDLSEdge();\r\n                            newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);\r\n                            newEdgeUpDown.setDatas(currVertex, newEdgeDownUp, null, null, true, true);\r\n                            leftBoundingEdges.push(newEdgeDownUp);\r\n                            rightBoundingEdges.push(newEdgeUpDown);\r\n                            this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);\r\n\r\n                            intersectedEdges.splice(0, intersectedEdges.length);\r\n                            leftBoundingEdges.splice(0, leftBoundingEdges.length);\r\n                            rightBoundingEdges.splice(0, rightBoundingEdges.length);\r\n                            vertexDown = currVertex;\r\n                            tempEdgeDownUp.originVertex = vertexDown;\r\n                            currObjet = vertexDown;\r\n                        }\r\n                        else {\r\n                            //console.log(\"edge is not constrained\");\r\n                            intersectedEdges.push(edgeLeft);\r\n                            leftBoundingEdges.unshift(edgeLeft.nextLeftEdge);\r\n                            currEdge = edgeLeft.oppositeEdge; // we keep the edge from left to right\r\n                            currObjet = currEdge;\r\n                        }\r\n                    }\r\n                    else {\r\n                        //console.log(\"2nd left edge intersected\");\r\n                        edgeLeft = edgeLeft.nextLeftEdge;\r\n                        DDLSGeom2D.intersections2edges(edgeLeft, tempEdgeDownUp, pIntersect);\r\n                        if (edgeLeft.isConstrained) {\r\n                            //console.log(\"edge is constrained\");\r\n                            currVertex = this.splitEdge(edgeLeft, pIntersect.x, pIntersect.y);\r\n\r\n                            iterVertexToOutEdges.fromVertex = currVertex;\r\n                            currEdge = iterVertexToOutEdges.next();\r\n                            while (currEdge) {\r\n                                if (currEdge.destinationVertex == leftBoundingEdges[0].originVertex) {\r\n                                    leftBoundingEdges.unshift(currEdge);\r\n                                }\r\n                                if (currEdge.destinationVertex == rightBoundingEdges[rightBoundingEdges.length - 1].destinationVertex) {\r\n                                    rightBoundingEdges.push(currEdge.oppositeEdge);\r\n                                }\r\n                                currEdge = iterVertexToOutEdges.next();\r\n                            }\r\n\r\n                            newEdgeDownUp = new DDLSEdge();\r\n                            newEdgeUpDown = new DDLSEdge();\r\n                            newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);\r\n                            newEdgeUpDown.setDatas(currVertex, newEdgeDownUp, null, null, true, true);\r\n                            leftBoundingEdges.push(newEdgeDownUp);\r\n                            rightBoundingEdges.push(newEdgeUpDown);\r\n                            this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);\r\n\r\n                            intersectedEdges.splice(0, intersectedEdges.length);\r\n                            leftBoundingEdges.splice(0, leftBoundingEdges.length);\r\n                            rightBoundingEdges.splice(0, rightBoundingEdges.length);\r\n                            vertexDown = currVertex;\r\n                            tempEdgeDownUp.originVertex = vertexDown;\r\n                            currObjet = vertexDown;\r\n                        }\r\n                        else {\r\n                            //console.log(\"edge is not constrained\");\r\n                            intersectedEdges.push(edgeLeft);\r\n                            rightBoundingEdges.push(edgeLeft.prevLeftEdge);\r\n                            currEdge = edgeLeft.oppositeEdge; // we keep the edge from left to right\r\n                            currObjet = currEdge;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // return segment;\r\n    }\r\n\r\n    private insertNewConstrainedEdge(fromSegment: DDLSConstraintSegment, edgeDownUp: DDLSEdge, intersectedEdges: DDLSEdge[], leftBoundingEdges: DDLSEdge[], rightBoundingEdges: DDLSEdge[]): void {\r\n        //console.log(\"insertNewConstrainedEdge\");\r\n        this._edges.push(edgeDownUp);\r\n        this._edges.push(edgeDownUp.oppositeEdge);\r\n\r\n        edgeDownUp.addFromConstraintSegment(fromSegment);\r\n        edgeDownUp.oppositeEdge.fromConstraintSegments = edgeDownUp.fromConstraintSegments;\r\n\r\n        fromSegment.addEdge(edgeDownUp);\r\n\r\n        edgeDownUp.originVertex.addFromConstraintSegment(fromSegment);\r\n        edgeDownUp.destinationVertex.addFromConstraintSegment(fromSegment);\r\n\r\n        this.untriangulate(intersectedEdges);\r\n\r\n        this.triangulate(leftBoundingEdges, true);\r\n        this.triangulate(rightBoundingEdges, true);\r\n    }\r\n\r\n    public deleteConstraintSegment(segment: DDLSConstraintSegment): void {\r\n        //console.log(\"this.deleteConstraintSegment this.id\", segment.id);\r\n        var i: number;\r\n        var vertexToDelete: DDLSVertex[] = [];\r\n        var edge: DDLSEdge;\r\n        var vertex: DDLSVertex;\r\n        var fromConstraintSegment: DDLSConstraintSegment[];\r\n        for (i = 0; i < segment.edges.length; i++) {\r\n            edge = segment.edges[i];\r\n            //console.log(\"unconstrain edge \", edge);\r\n            edge.removeFromConstraintSegment(segment);\r\n            if (edge.fromConstraintSegments.length == 0) {\r\n                edge.isConstrained = false;\r\n                edge.oppositeEdge.isConstrained = false;\r\n            }\r\n\r\n            vertex = edge.originVertex;\r\n            vertex.removeFromConstraintSegment(segment);\r\n            vertexToDelete.push(vertex);\r\n        }\r\n        vertex = edge.destinationVertex;\r\n        vertex.removeFromConstraintSegment(segment);\r\n        vertexToDelete.push(vertex);\r\n\r\n        //console.log(\"clean the useless vertices\");\r\n        for (i = 0; i < vertexToDelete.length; i++) {\r\n            this.deleteVertex(vertexToDelete[i]);\r\n        }\r\n        //console.log(\"clean done\");\r\n\r\n\r\n        segment.dispose();\r\n    }\r\n\r\n    private check(): void {\r\n        for (var i: number = 0; i < this.__edges.length; i++) {\r\n            if (!this.__edges[i].nextLeftEdge) {\r\n                console.log(\"!!! missing nextLeftEdge\");\r\n                return;\r\n            }\r\n        }\r\n        console.log(\"this.check OK\");\r\n\r\n    }\r\n\r\n    public insertVertex(x: number, y: number): DDLSVertex {\r\n        //console.log(\"insertVertex\", x, y);\r\n        if (x < 0 || y < 0 || x > this._width || y > this._height)\r\n            return null;\r\n\r\n        this.__edgesToCheck.splice(0, this.__edgesToCheck.length);\r\n\r\n        var inObject: Object = DDLSGeom2D.locatePosition(x, y, this);\r\n        var inVertex: DDLSVertex;\r\n        var inEdge: DDLSEdge;\r\n        var inFace: DDLSFace;\r\n        var newVertex: DDLSVertex;\r\n        if (inObject instanceof DDLSVertex)\r\n            inVertex = inObject;\r\n\r\n        if (inVertex) {\r\n            //console.log(\"inVertex\", inVertex.id);\r\n            newVertex = inVertex;\r\n        }\r\n        else if ((inEdge = inObject instanceof DDLSEdge ? <DDLSEdge>inObject : null)) {\r\n            //console.log(\"inEdge\", inEdge);\r\n            newVertex = this.splitEdge(inEdge, x, y);\r\n        }\r\n        else if ((inFace = inObject instanceof DDLSFace ? <DDLSFace>inObject : null)) {\r\n            //console.log(\"inFace\");\r\n            newVertex = this.splitFace(inFace, x, y);\r\n        }\r\n\r\n        this.restoreAsDelaunay();\r\n\r\n        return newVertex;\r\n    }\r\n\r\n    public flipEdge(edge: DDLSEdge): DDLSEdge {\r\n        // retrieve and create useful objets\r\n        var eBot_Top: DDLSEdge = edge;\r\n        var eTop_Bot: DDLSEdge = edge.oppositeEdge;\r\n        var eLeft_Right: DDLSEdge = new DDLSEdge();\r\n        var eRight_Left: DDLSEdge = new DDLSEdge();\r\n        var eTop_Left: DDLSEdge = eBot_Top.nextLeftEdge;\r\n        var eLeft_Bot: DDLSEdge = eTop_Left.nextLeftEdge;\r\n        var eBot_Right: DDLSEdge = eTop_Bot.nextLeftEdge;\r\n        var eRight_Top: DDLSEdge = eBot_Right.nextLeftEdge;\r\n\r\n        var vBot: DDLSVertex = eBot_Top.originVertex;\r\n        var vTop: DDLSVertex = eTop_Bot.originVertex;\r\n        var vLeft: DDLSVertex = eLeft_Bot.originVertex;\r\n        var vRight: DDLSVertex = eRight_Top.originVertex;\r\n\r\n        var fLeft: DDLSFace = eBot_Top.leftFace;\r\n        var fRight: DDLSFace = eTop_Bot.leftFace;\r\n        var fBot: DDLSFace = new DDLSFace();\r\n        var fTop: DDLSFace = new DDLSFace();\r\n\r\n        // add the new edges\r\n        this._edges.push(eLeft_Right);\r\n        this._edges.push(eRight_Left);\r\n\r\n        // add the new faces\r\n        this._faces.push(fTop);\r\n        this._faces.push(fBot);\r\n\r\n        // set vertex, edge and face references for the new LEFT_RIGHT and RIGHT-LEFT edges\r\n        eLeft_Right.setDatas(vLeft, eRight_Left, eRight_Top, fTop, edge.isReal, edge.isConstrained);\r\n        eRight_Left.setDatas(vRight, eLeft_Right, eLeft_Bot, fBot, edge.isReal, edge.isConstrained);\r\n\r\n        // set edge references for the new TOP and BOTTOM faces\r\n        fTop.setDatas(eLeft_Right);\r\n        fBot.setDatas(eRight_Left);\r\n\r\n        // this.check the edge references of TOP and BOTTOM vertices\r\n        if (vTop.edge == eTop_Bot)\r\n            vTop.setDatas(eTop_Left);\r\n        if (vBot.edge == eBot_Top)\r\n            vBot.setDatas(eBot_Right);\r\n\r\n        // set the new edge and face references for the 4 bouding edges\r\n        eTop_Left.nextLeftEdge = eLeft_Right;\r\n        eTop_Left.leftFace = fTop;\r\n        eLeft_Bot.nextLeftEdge = eBot_Right;\r\n        eLeft_Bot.leftFace = fBot;\r\n        eBot_Right.nextLeftEdge = eRight_Left;\r\n        eBot_Right.leftFace = fBot;\r\n        eRight_Top.nextLeftEdge = eTop_Left;\r\n        eRight_Top.leftFace = fTop;\r\n\r\n        // remove the old TOP-BOTTOM and BOTTOM-TOP edges\r\n        eBot_Top.dispose();\r\n        eTop_Bot.dispose();\r\n        this._edges.splice(eBot_Top);\r\n        this._edges.splice(eTop_Bot);\r\n\r\n        // remove the old LEFT and RIGHT faces\r\n        fLeft.dispose();\r\n        fRight.dispose();\r\n        this._faces.splice(fLeft);\r\n        this._faces.splice(fRight);\r\n\r\n        return eRight_Left;\r\n    }\r\n\r\n    public splitEdge(edge: DDLSEdge, x: number, y: number): DDLSVertex {\r\n        // empty old references\r\n        this.__edgesToCheck.splice(0, this.__edgesToCheck.length);\r\n\r\n        // retrieve useful objets\r\n        var eLeft_Right: DDLSEdge = edge;\r\n        var eRight_Left: DDLSEdge = eLeft_Right.oppositeEdge;\r\n        var eRight_Top: DDLSEdge = eLeft_Right.nextLeftEdge;\r\n        var eTop_Left: DDLSEdge = eRight_Top.nextLeftEdge;\r\n        var eLeft_Bot: DDLSEdge = eRight_Left.nextLeftEdge;\r\n        var eBot_Right: DDLSEdge = eLeft_Bot.nextLeftEdge;\r\n\r\n        var vTop: DDLSVertex = eTop_Left.originVertex;\r\n        var vLeft: DDLSVertex = eLeft_Right.originVertex;\r\n        var vBot: DDLSVertex = eBot_Right.originVertex;\r\n        var vRight: DDLSVertex = eRight_Left.originVertex;\r\n\r\n        var fTop: DDLSFace = eLeft_Right.leftFace;\r\n        var fBot: DDLSFace = eRight_Left.leftFace;\r\n\r\n        // this.check distance from the position to edge end points\r\n        if ((vLeft.pos.x - x) * (vLeft.pos.x - x) + (vLeft.pos.y - y) * (vLeft.pos.y - y) <= DDLSConstants.EPSILON_SQUARED)\r\n            return vLeft;\r\n        if ((vRight.pos.x - x) * (vRight.pos.x - x) + (vRight.pos.y - y) * (vRight.pos.y - y) <= DDLSConstants.EPSILON_SQUARED)\r\n            return vRight;\r\n\r\n        // create new objects\r\n        var vCenter: DDLSVertex = new DDLSVertex();\r\n\r\n        var eTop_Center: DDLSEdge = new DDLSEdge();\r\n        var eCenter_Top: DDLSEdge = new DDLSEdge();\r\n        var eBot_Center: DDLSEdge = new DDLSEdge();\r\n        var eCenter_Bot: DDLSEdge = new DDLSEdge();\r\n\r\n        var eLeft_Center: DDLSEdge = new DDLSEdge();\r\n        var eCenter_Left: DDLSEdge = new DDLSEdge();\r\n        var eRight_Center: DDLSEdge = new DDLSEdge();\r\n        var eCenter_Right: DDLSEdge = new DDLSEdge();\r\n\r\n        var fTopLeft: DDLSFace = new DDLSFace();\r\n        var fBotLeft: DDLSFace = new DDLSFace();\r\n        var fBotRight: DDLSFace = new DDLSFace();\r\n        var fTopRight: DDLSFace = new DDLSFace();\r\n\r\n        // add the new vertex\r\n        this._vertices.push(vCenter);\r\n\r\n        // add the new edges\r\n        this._edges.push(eCenter_Top);\r\n        this._edges.push(eTop_Center);\r\n        this._edges.push(eCenter_Left);\r\n        this._edges.push(eLeft_Center);\r\n        this._edges.push(eCenter_Bot);\r\n        this._edges.push(eBot_Center);\r\n        this._edges.push(eCenter_Right);\r\n        this._edges.push(eRight_Center);\r\n\r\n        // add the new faces\r\n        this._faces.push(fTopRight);\r\n        this._faces.push(fBotRight);\r\n        this._faces.push(fBotLeft);\r\n        this._faces.push(fTopLeft);\r\n\r\n        // set pos and edge reference for the new CENTER vertex\r\n        vCenter.setDatas(fTop.isReal ? eCenter_Top : eCenter_Bot);\r\n        vCenter.pos.x = x;\r\n        vCenter.pos.y = y;\r\n        DDLSGeom2D.projectOrthogonaly(vCenter.pos, eLeft_Right);\r\n\r\n        // set the new vertex, edge and face references for the new 8 center crossing edges\r\n        eCenter_Top.setDatas(vCenter, eTop_Center, eTop_Left, fTopLeft, fTop.isReal);\r\n        eTop_Center.setDatas(vTop, eCenter_Top, eCenter_Right, fTopRight, fTop.isReal);\r\n        eCenter_Left.setDatas(vCenter, eLeft_Center, eLeft_Bot, fBotLeft, edge.isReal, edge.isConstrained);\r\n        eLeft_Center.setDatas(vLeft, eCenter_Left, eCenter_Top, fTopLeft, edge.isReal, edge.isConstrained);\r\n        eCenter_Bot.setDatas(vCenter, eBot_Center, eBot_Right, fBotRight, fBot.isReal);\r\n        eBot_Center.setDatas(vBot, eCenter_Bot, eCenter_Left, fBotLeft, fBot.isReal);\r\n        eCenter_Right.setDatas(vCenter, eRight_Center, eRight_Top, fTopRight, edge.isReal, edge.isConstrained);\r\n        eRight_Center.setDatas(vRight, eCenter_Right, eCenter_Bot, fBotRight, edge.isReal, edge.isConstrained);\r\n\r\n        // set the new edge references for the new 4 faces\r\n        fTopLeft.setDatas(eCenter_Top, fTop.isReal);\r\n        fBotLeft.setDatas(eCenter_Left, fBot.isReal);\r\n        fBotRight.setDatas(eCenter_Bot, fBot.isReal);\r\n        fTopRight.setDatas(eCenter_Right, fTop.isReal);\r\n\r\n        // this.check the edge references of LEFT and RIGHT vertices\r\n        if (vLeft.edge == eLeft_Right)\r\n            vLeft.setDatas(eLeft_Center);\r\n        if (vRight.edge == eRight_Left)\r\n            vRight.setDatas(eRight_Center);\r\n\r\n        // set the new edge and face references for the 4 bounding edges\r\n        eTop_Left.nextLeftEdge = eLeft_Center;\r\n        eTop_Left.leftFace = fTopLeft;\r\n        eLeft_Bot.nextLeftEdge = eBot_Center;\r\n        eLeft_Bot.leftFace = fBotLeft;\r\n        eBot_Right.nextLeftEdge = eRight_Center;\r\n        eBot_Right.leftFace = fBotRight;\r\n        eRight_Top.nextLeftEdge = eTop_Center;\r\n        eRight_Top.leftFace = fTopRight;\r\n\r\n        // if the edge was constrained, we must:\r\n        // - add the segments the edge is from to the 2 new\r\n        // - update the segments the edge is from by deleting the old edge and inserting the 2 new\r\n        // - add the segments the edge is from to the new vertex\r\n        if (eLeft_Right.isConstrained) {\r\n            var fromSegments: DDLSConstraintSegment[] = eLeft_Right.fromConstraintSegments;\r\n            eLeft_Center.fromConstraintSegments = fromSegments.slice(0);\r\n            eCenter_Left.fromConstraintSegments = eLeft_Center.fromConstraintSegments;\r\n            eCenter_Right.fromConstraintSegments = fromSegments.slice(0);\r\n            eRight_Center.fromConstraintSegments = eCenter_Right.fromConstraintSegments;\r\n\r\n            var edges: DDLSEdge[];\r\n            var index: number;\r\n            for (var i: number = 0; i < eLeft_Right.fromConstraintSegments.length; i++) {\r\n                edges = eLeft_Right.fromConstraintSegments[i].edges;\r\n                index = edges.indexOf(eLeft_Right);\r\n                if (index != -1)\r\n                    edges.splice(index, 1, eLeft_Center, eCenter_Right);\r\n                else\r\n                    edges.splice(edges.indexOf(eRight_Left), 1, eRight_Center, eCenter_Left);\r\n            }\r\n\r\n            vCenter.fromConstraintSegments = fromSegments.slice(0);\r\n        }\r\n\r\n        // remove the old LEFT-RIGHT and RIGHT-LEFT edges\r\n        eLeft_Right.dispose();\r\n        eRight_Left.dispose();\r\n        this._edges.splice(eLeft_Right);\r\n        this._edges.splice(eRight_Left);\r\n\r\n        // remove the old TOP and BOTTOM faces\r\n        fTop.dispose();\r\n        fBot.dispose();\r\n        this._faces.splice(fTop);\r\n        this._faces.splice(fBot);\r\n\r\n        // add new bounds references for Delaunay restoring\r\n        this.__centerVertex = vCenter;\r\n        this.__edgesToCheck.push(eTop_Left);\r\n        this.__edgesToCheck.push(eLeft_Bot);\r\n        this.__edgesToCheck.push(eBot_Right);\r\n        this.__edgesToCheck.push(eRight_Top);\r\n\r\n        return vCenter;\r\n    }\r\n\r\n    public splitFace(face: DDLSFace, x: number, y: number): DDLSVertex {\r\n        // empty old references\r\n        this.__edgesToCheck.splice(0, this.__edgesToCheck.length);\r\n\r\n        // retrieve useful objects\r\n        var eTop_Left: DDLSEdge = face.edge;\r\n        var eLeft_Right: DDLSEdge = eTop_Left.nextLeftEdge;\r\n        var eRight_Top: DDLSEdge = eLeft_Right.nextLeftEdge;\r\n\r\n        var vTop: DDLSVertex = eTop_Left.originVertex;\r\n        var vLeft: DDLSVertex = eLeft_Right.originVertex;\r\n        var vRight: DDLSVertex = eRight_Top.originVertex;\r\n\r\n        // create new objects\r\n        var vCenter: DDLSVertex = new DDLSVertex();\r\n\r\n        var eTop_Center: DDLSEdge = new DDLSEdge();\r\n        var eCenter_Top: DDLSEdge = new DDLSEdge();\r\n        var eLeft_Center: DDLSEdge = new DDLSEdge();\r\n        var eCenter_Left: DDLSEdge = new DDLSEdge();\r\n        var eRight_Center: DDLSEdge = new DDLSEdge();\r\n        var eCenter_Right: DDLSEdge = new DDLSEdge();\r\n\r\n        var fTopLeft: DDLSFace = new DDLSFace();\r\n        var fBot: DDLSFace = new DDLSFace();\r\n        var fTopRight: DDLSFace = new DDLSFace();\r\n\r\n        // add the new vertex\r\n        this._vertices.push(vCenter);\r\n\r\n        // add the new edges\r\n        this._edges.push(eTop_Center);\r\n        this._edges.push(eCenter_Top);\r\n        this._edges.push(eLeft_Center);\r\n        this._edges.push(eCenter_Left);\r\n        this._edges.push(eRight_Center);\r\n        this._edges.push(eCenter_Right);\r\n\r\n        // add the new faces\r\n        this._faces.push(fTopLeft);\r\n        this._faces.push(fBot);\r\n        this._faces.push(fTopRight);\r\n\r\n        // set pos and edge reference for the new CENTER vertex\r\n        vCenter.setDatas(eCenter_Top);\r\n        vCenter.pos.x = x;\r\n        vCenter.pos.y = y;\r\n\r\n        // set the new vertex, edge and face references for the new 6 center crossing edges\r\n        eTop_Center.setDatas(vTop, eCenter_Top, eCenter_Right, fTopRight);\r\n        eCenter_Top.setDatas(vCenter, eTop_Center, eTop_Left, fTopLeft);\r\n        eLeft_Center.setDatas(vLeft, eCenter_Left, eCenter_Top, fTopLeft);\r\n        eCenter_Left.setDatas(vCenter, eLeft_Center, eLeft_Right, fBot);\r\n        eRight_Center.setDatas(vRight, eCenter_Right, eCenter_Left, fBot);\r\n        eCenter_Right.setDatas(vCenter, eRight_Center, eRight_Top, fTopRight);\r\n\r\n        // set the new edge references for the new 3 faces\r\n        fTopLeft.setDatas(eCenter_Top);\r\n        fBot.setDatas(eCenter_Left);\r\n        fTopRight.setDatas(eCenter_Right);\r\n\r\n        // set the new edge and face references for the 3 bounding edges\r\n        eTop_Left.nextLeftEdge = eLeft_Center;\r\n        eTop_Left.leftFace = fTopLeft;\r\n        eLeft_Right.nextLeftEdge = eRight_Center;\r\n        eLeft_Right.leftFace = fBot;\r\n        eRight_Top.nextLeftEdge = eTop_Center;\r\n        eRight_Top.leftFace = fTopRight;\r\n\r\n        // we remove the old face\r\n        face.dispose();\r\n        this._faces.splice(face);\r\n\r\n        // add new bounds references for Delaunay restoring\r\n        this.__centerVertex = vCenter;\r\n        this.__edgesToCheck.push(eTop_Left);\r\n        this.__edgesToCheck.push(eLeft_Right);\r\n        this.__edgesToCheck.push(eRight_Top);\r\n\r\n        return vCenter;\r\n    }\r\n\r\n    public restoreAsDelaunay(): void {\r\n        var edge: DDLSEdge;\r\n        while (this.__edgesToCheck.length) {\r\n            edge = this.__edgesToCheck.shift();\r\n            if (edge.isReal && !edge.isConstrained && !DDLSGeom2D.isDelaunay(edge)) {\r\n                if (edge.nextLeftEdge.destinationVertex == this.__centerVertex) {\r\n                    this.__edgesToCheck.push(edge.nextRightEdge);\r\n                    this.__edgesToCheck.push(edge.prevRightEdge);\r\n                }\r\n                else {\r\n                    this.__edgesToCheck.push(edge.nextLeftEdge);\r\n                    this.__edgesToCheck.push(edge.prevLeftEdge);\r\n                }\r\n                this.flipEdge(edge);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Delete a vertex IF POSSIBLE and then fill the hole with a new triangulation.\r\n    // A vertex can be deleted if:\r\n    // - it is free of constraint segment (no adjacency to any constrained edge)\r\n    // - it is adjacent to exactly 2 contrained edges and is not an end point of any constraint segment\r\n    public deleteVertex(vertex: DDLSVertex): boolean {\r\n        //console.log(\"tryToDeleteVertex this.id\", vertex.id);\r\n        var i: number;\r\n        var freeOfConstraint: boolean;\r\n        var iterEdges: IteratorFromVertexToOutgoingEdges = new IteratorFromVertexToOutgoingEdges();\r\n        iterEdges.fromVertex = vertex;\r\n        iterEdges.realEdgesOnly = false;\r\n        var edge: DDLSEdge;\r\n        var outgoingEdges: DDLSEdge[] = [];\r\n\r\n        freeOfConstraint = vertex.fromConstraintSegments.length == 0;\r\n\r\n        //console.log(\"  -> freeOfConstraint\", freeOfConstraint);\r\n\r\n        var bound: DDLSEdge[] = [];\r\n        if (freeOfConstraint) {\r\n            edge = iterEdges.next();\r\n            while (edge) {\r\n                outgoingEdges.push(edge);\r\n                bound.push(edge.nextLeftEdge);\r\n                edge = iterEdges.next();\r\n            }\r\n        }\r\n        else {\r\n            // we this.check if the vertex is an end point of a constraint segment\r\n            var edges: DDLSEdge[];\r\n            for (i = 0; i < vertex.fromConstraintSegments.length; i++) {\r\n                edges = vertex.fromConstraintSegments[i].edges;\r\n                if (edges[0].originVertex == vertex\r\n                    || edges[edges.length - 1].destinationVertex == vertex) {\r\n                    //console.log(\"  -> is end point of a constraint segment\");\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // we this.check the count of adjacent constrained edges\r\n            var count: number = 0;\r\n            edge = iterEdges.next();\r\n            while (edge) {\r\n                outgoingEdges.push(edge);\r\n\r\n                if (edge.isConstrained) {\r\n                    count++;\r\n                    if (count > 2) {\r\n                        //console.log(\"  -> count of adjacent constrained edges\", count);\r\n                        return false;\r\n                    }\r\n                }\r\n                edge = iterEdges.next();\r\n            }\r\n\r\n            // if not disqualified, then we can process\r\n            //console.log(\"process vertex deletion\");\r\n            var boundA: DDLSEdge[] = [];\r\n            var boundB: DDLSEdge[] = [];\r\n            var constrainedEdgeA: DDLSEdge;\r\n            var constrainedEdgeB: DDLSEdge;\r\n            var edgeA: DDLSEdge = new DDLSEdge();\r\n            var edgeB: DDLSEdge = new DDLSEdge();\r\n            var realA: boolean;\r\n            var realB: boolean;\r\n            this._edges.push(edgeA);\r\n            this._edges.push(edgeB);\r\n            for (i = 0; i < outgoingEdges.length; i++) {\r\n                edge = outgoingEdges[i];\r\n                if (edge.isConstrained) {\r\n                    if (!constrainedEdgeA) {\r\n                        edgeB.setDatas(edge.destinationVertex, edgeA, null, null, true, true);\r\n                        boundA.push(edgeA, edge.nextLeftEdge);\r\n                        boundB.push(edgeB);\r\n                        constrainedEdgeA = edge;\r\n                    }\r\n                    else if (!constrainedEdgeB) {\r\n                        edgeA.setDatas(edge.destinationVertex, edgeB, null, null, true, true);\r\n                        boundB.push(edge.nextLeftEdge);\r\n                        constrainedEdgeB = edge;\r\n                    }\r\n                }\r\n                else {\r\n                    if (!constrainedEdgeA)\r\n                        boundB.push(edge.nextLeftEdge);\r\n                    else if (!constrainedEdgeB)\r\n                        boundA.push(edge.nextLeftEdge);\r\n                    else\r\n                        boundB.push(edge.nextLeftEdge);\r\n                }\r\n            }\r\n\r\n            // keep infos about reality\r\n            realA = constrainedEdgeA.leftFace.isReal;\r\n            realB = constrainedEdgeB.leftFace.isReal;\r\n\r\n            // we update the segments infos\r\n            edgeA.fromConstraintSegments = constrainedEdgeA.fromConstraintSegments.slice(0);\r\n            edgeB.fromConstraintSegments = edgeA.fromConstraintSegments;\r\n            var index: number;\r\n            for (i = 0; i < vertex.fromConstraintSegments.length; i++) {\r\n                edges = vertex.fromConstraintSegments[i].edges;\r\n                index = edges.indexOf(constrainedEdgeA);\r\n                if (index != -1) {\r\n                    edges.splice(index - 1, 2, edgeA);\r\n                }\r\n                else {\r\n                    edges.splice(edges.indexOf(constrainedEdgeB) - 1, 2, edgeB);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deletion of old faces and edges\r\n        var faceToDelete: DDLSFace;\r\n        for (i = 0; i < outgoingEdges.length; i++) {\r\n            edge = outgoingEdges[i];\r\n\r\n            faceToDelete = edge.leftFace;\r\n            this._faces.splice(faceToDelete);\r\n            faceToDelete.dispose();\r\n\r\n            edge.destinationVertex.edge = edge.nextLeftEdge;\r\n\r\n            this._edges.splice(edge.oppositeEdge);\r\n            edge.oppositeEdge.dispose();\r\n            this._edges.splice(edge);\r\n            edge.dispose();\r\n        }\r\n\r\n        this._vertices.splice(this._vertices.indexOf(vertex), 1);\r\n        vertex.dispose();\r\n\r\n        // finally we this.triangulate\r\n        if (freeOfConstraint) {\r\n            //console.log(\"trigger single hole triangulation\");\r\n            this.triangulate(bound, true);\r\n        }\r\n        else {\r\n            //console.log(\"trigger dual holes triangulation\");\r\n            this.triangulate(boundA, realA);\r\n            this.triangulate(boundB, realB);\r\n        }\r\n\r\n        //this.check();\r\n        return true;\r\n    }\r\n\r\n    ///// PRIVATE\r\n\r\n\r\n\r\n    // this.untriangulate is usually used while a new edge insertion in order to delete the intersected edges\r\n    // edgesList is a list of chained edges oriented from right to left\r\n    private untriangulate(edgesList: DDLSEdge[]): void {\r\n        // we clean useless faces and adjacent vertices\r\n        var i: number;\r\n        var verticesCleaned: any = {};\r\n        var currEdge: DDLSEdge;\r\n        var outEdge: DDLSEdge;\r\n        for (i = 0; i < edgesList.length; i++) {\r\n            currEdge = edgesList[i];\r\n            //\r\n            if (!verticesCleaned[currEdge.originVertex.id]) {\r\n                currEdge.originVertex.edge = currEdge.prevLeftEdge.oppositeEdge;\r\n                verticesCleaned[currEdge.originVertex.id] = true;\r\n            }\r\n            if (!verticesCleaned[currEdge.destinationVertex.id]) {\r\n                currEdge.destinationVertex.edge = currEdge.nextLeftEdge;\r\n                verticesCleaned[currEdge.destinationVertex.id] = true;\r\n            }\r\n            //\r\n            this._faces.splice(currEdge.leftFace);\r\n            currEdge.leftFace.dispose();\r\n            if (i == edgesList.length - 1) {\r\n                this._faces.splice(currEdge.rightFace);\r\n                currEdge.rightFace.dispose();\r\n            }\r\n            //\r\n        }\r\n\r\n        // finally we delete the intersected edges\r\n        for (i = 0; i < edgesList.length; i++) {\r\n            currEdge = edgesList[i];\r\n            this._edges.splice(currEdge.oppositeEdge);\r\n            this._edges.splice(currEdge);\r\n            currEdge.oppositeEdge.dispose();\r\n            currEdge.dispose();\r\n        }\r\n    }\r\n\r\n    // this.triangulate is usually used to fill the hole after deletion of a vertex from mesh or after untriangulation\r\n    // - bounds is the list of edges in CCW bounding the surface to retriangulate,\r\n    private triangulate(bound: DDLSEdge[], isReal: boolean): void {\r\n        if (bound.length < 2) {\r\n            console.log(\"BREAK ! the hole has less than 2 edges\");\r\n            return;\r\n        }\r\n        // if the hole is a 2 edges polygon, we have a big problem\r\n        else if (bound.length == 2) {\r\n            //throw new Error(\"BREAK ! the hole has only 2 edges! \" + \"  - edge0: \" + bound[0].originVertex.id + \" -> \" + bound[0].destinationVertex.id + \"  - edge1: \" +  bound[1].originVertex.id + \" -> \" + bound[1].destinationVertex.id);\r\n            console.log(\"BREAK ! the hole has only 2 edges\");\r\n            console.log(\"  - edge0:\", bound[0].originVertex.id, \"->\", bound[0].destinationVertex.id);\r\n            console.log(\"  - edge1:\", bound[1].originVertex.id, \"->\", bound[1].destinationVertex.id);\r\n            return;\r\n        }\r\n        // if the hole is a 3 edges polygon:\r\n        else if (bound.length == 3) {\r\n            /*console.log(\"the hole is a 3 edges polygon\");\r\n            console.log(\"  - edge0:\", bound[0].originVertex.id, \"->\", bound[0].destinationVertex.id);\r\n            console.log(\"  - edge1:\", bound[1].originVertex.id, \"->\", bound[1].destinationVertex.id);\r\n            console.log(\"  - edge2:\", bound[2].originVertex.id, \"->\", bound[2].destinationVertex.id);*/\r\n            var f: DDLSFace = new DDLSFace();\r\n            f.setDatas(bound[0], isReal);\r\n            this._faces.push(f);\r\n            bound[0].leftFace = f;\r\n            bound[1].leftFace = f;\r\n            bound[2].leftFace = f;\r\n            bound[0].nextLeftEdge = bound[1];\r\n            bound[1].nextLeftEdge = bound[2];\r\n            bound[2].nextLeftEdge = bound[0];\r\n        }\r\n        else // if more than 3 edges, we process recursively:\r\n        {\r\n            //console.log(\"the hole has\", bound.length, \"edges\");\r\n            for (i = 0; i < bound.length; i++) {\r\n                //console.log(\"  - edge\", i, \":\", bound[i].originVertex.id, \"->\", bound[i].destinationVertex.id);\r\n            }\r\n\r\n            var baseEdge: DDLSEdge = bound[0];\r\n            var vertexA: DDLSVertex = baseEdge.originVertex;\r\n            var vertexB: DDLSVertex = baseEdge.destinationVertex;\r\n            var vertexC: DDLSVertex;\r\n            var vertexCheck: DDLSVertex;\r\n            var circumcenter: DDLSPoint2D = new DDLSPoint2D();\r\n            var radiusSquared: number;\r\n            var distanceSquared: number;\r\n            var isDelaunay: boolean;\r\n            var index: number;\r\n            var i: number;\r\n            for (i = 2; i < bound.length; i++) {\r\n                vertexC = bound[i].originVertex;\r\n                if (DDLSGeom2D.getRelativePosition2(vertexC.pos.x, vertexC.pos.y, baseEdge) == 1) {\r\n                    index = i;\r\n                    isDelaunay = true;\r\n                    DDLSGeom2D.getCircumcenter(vertexA.pos.x, vertexA.pos.y, vertexB.pos.x, vertexB.pos.y, vertexC.pos.x, vertexC.pos.y, circumcenter);\r\n                    radiusSquared = (vertexA.pos.x - circumcenter.x) * (vertexA.pos.x - circumcenter.x) + (vertexA.pos.y - circumcenter.y) * (vertexA.pos.y - circumcenter.y);\r\n                    // for perfect regular n-sides polygons, checking strict delaunay circumcircle condition is not possible, so we substract EPSILON to circumcircle radius:\r\n                    radiusSquared -= DDLSConstants.EPSILON_SQUARED;\r\n                    for (var j: number = 2; j < bound.length; j++) {\r\n                        if (j != i) {\r\n                            vertexCheck = bound[j].originVertex;\r\n                            distanceSquared = (vertexCheck.pos.x - circumcenter.x) * (vertexCheck.pos.x - circumcenter.x) + (vertexCheck.pos.y - circumcenter.y) * (vertexCheck.pos.y - circumcenter.y);\r\n                            if (distanceSquared < radiusSquared) {\r\n                                isDelaunay = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (isDelaunay)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (!isDelaunay) {\r\n                // for perfect regular n-sides polygons, checking delaunay circumcircle condition is not possible\r\n                console.log(\"NO DELAUNAY FOUND\");\r\n                var s: string = \"\";\r\n                for (i = 0; i < bound.length; i++) {\r\n                    s += bound[i].originVertex.pos.x + \" , \";\r\n                    s += bound[i].originVertex.pos.y + \" , \";\r\n                    s += bound[i].destinationVertex.pos.x + \" , \";\r\n                    s += bound[i].destinationVertex.pos.y + \" , \";\r\n                }\r\n                //console.log(s);\r\n\r\n                index = 2;\r\n            }\r\n            //console.log(\"index\", index, \"on\", bound.length);\r\n\r\n            var edgeA: DDLSEdge;\r\n            var edgeAopp: DDLSEdge;\r\n            var edgeB: DDLSEdge;\r\n            var edgeBopp: DDLSEdge;\r\n            var boundA: DDLSEdge[];\r\n            var boundM: DDLSEdge[];\r\n            var boundB: DDLSEdge[];\r\n\r\n            if (index < (bound.length - 1)) {\r\n                edgeA = new DDLSEdge();\r\n                edgeAopp = new DDLSEdge();\r\n                this._edges.push(edgeA);\r\n                this._edges.push(edgeAopp);\r\n                edgeA.setDatas(vertexA, edgeAopp, null, null, isReal, false);\r\n                edgeAopp.setDatas(bound[index].originVertex, edgeA, null, null, isReal, false);\r\n                boundA = bound.slice(index);\r\n                boundA.push(edgeA);\r\n                this.triangulate(boundA, isReal);\r\n            }\r\n\r\n            if (index > 2) {\r\n                edgeB = new DDLSEdge();\r\n                edgeBopp = new DDLSEdge();\r\n                this._edges.push(edgeB);\r\n                this._edges.push(edgeBopp);\r\n                edgeB.setDatas(bound[1].originVertex, edgeBopp, null, null, isReal, false);\r\n                edgeBopp.setDatas(bound[index].originVertex, edgeB, null, null, isReal, false);\r\n                boundB = bound.slice(1, index);\r\n                boundB.push(edgeBopp);\r\n                this.triangulate(boundB, isReal);\r\n            }\r\n\r\n            boundM = [];\r\n            if (index == 2)\r\n                boundM.push(baseEdge, bound[1], edgeAopp);\r\n            else if (index == (bound.length - 1))\r\n                boundM.push(baseEdge, edgeB, bound[index]);\r\n            else\r\n                boundM.push(baseEdge, edgeB, edgeAopp);\r\n            this.triangulate(boundM, isReal);\r\n        }\r\n    }\r\n\r\n    public debug(): void {\r\n        var i: number;\r\n        for (i = 0; i < this.__vertices.length; i++) {\r\n            console.log(\"-- vertex\", this._vertices[i].id);\r\n            console.log(\"  edge\", this._vertices[i].edge.id, \" - \", this._vertices[i].edge);\r\n            console.log(\"  edge isReal:\", this._vertices[i].edge.isReal);\r\n        }\r\n        for (i = 0; i < this.__edges.length; i++) {\r\n            console.log(\"-- edge\", this.__edges[i]);\r\n            console.log(\"  isReal\", this.__edges[i].id, \" - \", this.__edges[i].isReal);\r\n            console.log(\"  nextLeftEdge\", this.__edges[i].nextLeftEdge);\r\n            console.log(\"  oppositeEdge\", this.__edges[i].oppositeEdge);\r\n        }\r\n    }\r\n}\r\n\r\nclass EdgeMap {\r\n    private content: any;\r\n    private dataChanged: boolean;\r\n    constructor() {\r\n        this.content = {};\r\n    }\r\n    public push(value: DDLSEdge): void {\r\n        var old: DDLSEdge = this.content[value.id];\r\n        if (old) {\r\n            throw new Error(\"\u91CD\u590D\u6DFB\u52A0\");\r\n        }\r\n        this.content[value.id] = value;\r\n        this.dataChanged = true;\r\n    }\r\n    public splice(edge: DDLSEdge): void {\r\n        var old: DDLSEdge = this.content[edge.id];\r\n        delete this.content[edge.id];\r\n        this.dataChanged = true;\r\n    }\r\n    private _vector: DDLSEdge[];\r\n    public get vector(): DDLSEdge[] {\r\n        if (!this._vector) {\r\n            this._vector = [];\r\n        }\r\n        if (this.dataChanged) {\r\n            this._vector.length = 0;\r\n            for (var i of this.content) {\r\n                this._vector.push(i);\r\n            }\r\n            this.dataChanged = false;\r\n        }\r\n        return this._vector;\r\n    }\r\n\r\n    public dispose(): void {\r\n        Object.keys(this.content).forEach((key) => {\r\n            const element = this.content[key];\r\n            element.dispose();\r\n        });\r\n        this.content = null;\r\n        this._vector.length = 0;\r\n        this._vector = null;\r\n    }\r\n}\r\n\r\nclass FaceMap {\r\n    private content: any;\r\n    private dataChanged: boolean;\r\n    constructor() {\r\n        this.content = {};\r\n    }\r\n\r\n    public push(value: DDLSFace): void {\r\n        var old: DDLSFace = this.content[value.id];\r\n        if (old) {\r\n            console.error(\"\u91CD\u590D\u6DFB\u52A0\");\r\n            return;\r\n        }\r\n        this.content[value.id] = value;\r\n        this.dataChanged = true;\r\n    }\r\n\r\n    public splice(edge: DDLSFace): void {\r\n        var old: DDLSFace = this.content[edge.id];\r\n        delete this.content[edge.id];\r\n        this.dataChanged = true;\r\n    }\r\n    private _vector: DDLSFace[];\r\n    public get vector(): DDLSFace[] {\r\n        if (!this._vector) {\r\n            this._vector = [];\r\n        }\r\n        if (this.dataChanged) {\r\n            this._vector.length = 0;\r\n            for (var i of this.content) {\r\n                this._vector.push(i);\r\n            }\r\n            this.dataChanged = false;\r\n        }\r\n        return this._vector;\r\n    }\r\n\r\n    public dispose(): void {\r\n        Object.keys(this.content).forEach((key) => {\r\n            const element = this.content[key];\r\n            element.dispose();\r\n        });\r\n        this.content = null;\r\n        this._vector.length = 0;\r\n        this._vector = null;\r\n    }\r\n}", "import { DDLSConstants } from \"../data/DDLSConstants\";\r\nimport { DDLSConstraintSegment } from \"../data/DDLSConstraintSegment\";\r\nimport { DDLSConstraintShape } from \"../data/DDLSConstraintShape\";\r\nimport { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSFace } from \"../data/DDLSFace\";\r\nimport { DDLSMesh } from \"../data/DDLSMesh\";\r\nimport { DDLSVertex } from \"../data/DDLSVertex\";\r\n\r\n\r\nexport class DDLSRectMeshFactory {\r\n\r\n    public static buildRectangle(width: number, height: number): DDLSMesh {\r\n        /*\r\n            TL\r\n        ----+-----+ TR\r\n        \\   |    /|\r\n        \\   |   / |\r\n        \\   |  /  |\r\n        \\   | /   |\r\n        \\   |/    |\r\n        \\   +-----+ BR\r\n        \\  BL     \\\r\n        \\----------\r\n        */\r\n\r\n        var vTL: DDLSVertex = new DDLSVertex();\r\n        var vTR: DDLSVertex = new DDLSVertex();\r\n        var vBR: DDLSVertex = new DDLSVertex();\r\n        var vBL: DDLSVertex = new DDLSVertex();\r\n\r\n        var eTL_TR: DDLSEdge = new DDLSEdge();\r\n        var eTR_TL: DDLSEdge = new DDLSEdge();\r\n        var eTR_BR: DDLSEdge = new DDLSEdge();\r\n        var eBR_TR: DDLSEdge = new DDLSEdge();\r\n        var eBR_BL: DDLSEdge = new DDLSEdge();\r\n        var eBL_BR: DDLSEdge = new DDLSEdge();\r\n        var eBL_TL: DDLSEdge = new DDLSEdge();\r\n        var eTL_BL: DDLSEdge = new DDLSEdge();\r\n        var eTR_BL: DDLSEdge = new DDLSEdge();\r\n        var eBL_TR: DDLSEdge = new DDLSEdge();\r\n        var eTL_BR: DDLSEdge = new DDLSEdge();\r\n        var eBR_TL: DDLSEdge = new DDLSEdge();\r\n\r\n        var fTL_BL_TR: DDLSFace = new DDLSFace();\r\n        var fTR_BL_BR: DDLSFace = new DDLSFace();\r\n        var fTL_BR_BL: DDLSFace = new DDLSFace();\r\n        var fTL_TR_BR: DDLSFace = new DDLSFace();\r\n\r\n        var boundShape: DDLSConstraintShape = new DDLSConstraintShape();\r\n        var segTop: DDLSConstraintSegment = new DDLSConstraintSegment();\r\n        var segRight: DDLSConstraintSegment = new DDLSConstraintSegment();\r\n        var segBot: DDLSConstraintSegment = new DDLSConstraintSegment();\r\n        var segLeft: DDLSConstraintSegment = new DDLSConstraintSegment();\r\n\r\n        var mesh: DDLSMesh = new DDLSMesh(width, height);\r\n\r\n        //\r\n\r\n        var offset: number = DDLSConstants.EPSILON * 1000;\r\n        vTL.pos.setTo(0 - offset, 0 - offset);\r\n        vTR.pos.setTo(width + offset, 0 - offset);\r\n        vBR.pos.setTo(width + offset, height + offset);\r\n        vBL.pos.setTo(0 - offset, height + offset);\r\n\r\n        vTL.setDatas(eTL_TR);\r\n        vTR.setDatas(eTR_BR);\r\n        vBR.setDatas(eBR_BL);\r\n        vBL.setDatas(eBL_TL);\r\n\r\n        eTL_TR.setDatas(vTL, eTR_TL, eTR_BR, fTL_TR_BR, true, true);\r\n        eTR_TL.setDatas(vTR, eTL_TR, eTL_BL, fTL_BL_TR, true, true);\r\n        eTR_BR.setDatas(vTR, eBR_TR, eBR_TL, fTL_TR_BR, true, true);\r\n        eBR_TR.setDatas(vBR, eTR_BR, eTR_BL, fTR_BL_BR, true, true);\r\n        eBR_BL.setDatas(vBR, eBL_BR, eBL_TL, fTL_BR_BL, true, true);\r\n        eBL_BR.setDatas(vBL, eBR_BL, eBR_TR, fTR_BL_BR, true, true);\r\n        eBL_TL.setDatas(vBL, eTL_BL, eTL_BR, fTL_BR_BL, true, true);\r\n        eTL_BL.setDatas(vTL, eBL_TL, eBL_TR, fTL_BL_TR, true, true);\r\n        eTR_BL.setDatas(vTR, eBL_TR, eBL_BR, fTR_BL_BR, true, false);// diagonal edge\r\n        eBL_TR.setDatas(vBL, eTR_BL, eTR_TL, fTL_BL_TR, true, false);// diagonal edge\r\n        eTL_BR.setDatas(vTL, eBR_TL, eBR_BL, fTL_BR_BL, false, false);// imaginary edge\r\n        eBR_TL.setDatas(vBR, eTL_BR, eTL_TR, fTL_TR_BR, false, false);// imaginary edge\r\n\r\n        fTL_BL_TR.setDatas(eBL_TR);\r\n        fTR_BL_BR.setDatas(eTR_BL);\r\n        fTL_BR_BL.setDatas(eBR_BL, false);\r\n        fTL_TR_BR.setDatas(eTR_BR, false);\r\n\r\n        // constraint relations datas\r\n        vTL.fromConstraintSegments.push(segTop, segLeft);\r\n        vTR.fromConstraintSegments.push(segTop, segRight);\r\n        vBR.fromConstraintSegments.push(segRight, segBot);\r\n        vBL.fromConstraintSegments.push(segBot, segLeft);\r\n\r\n        eTL_TR.fromConstraintSegments.push(segTop);\r\n        eTR_TL.fromConstraintSegments.push(segTop);\r\n        eTR_BR.fromConstraintSegments.push(segRight);\r\n        eBR_TR.fromConstraintSegments.push(segRight);\r\n        eBR_BL.fromConstraintSegments.push(segBot);\r\n        eBL_BR.fromConstraintSegments.push(segBot);\r\n        eBL_TL.fromConstraintSegments.push(segLeft);\r\n        eTL_BL.fromConstraintSegments.push(segLeft);\r\n\r\n        segTop.edges.push(eTL_TR);\r\n        segRight.edges.push(eTR_BR);\r\n        segBot.edges.push(eBR_BL);\r\n        segLeft.edges.push(eBL_TL);\r\n        segTop.fromShape = boundShape;\r\n        segRight.fromShape = boundShape;\r\n        segBot.fromShape = boundShape;\r\n        segLeft.fromShape = boundShape;\r\n        boundShape.segments.push(segTop, segRight, segBot, segLeft);\r\n\r\n        mesh.__vertices.push(vTL, vTR, vBR, vBL);\r\n        mesh.__edges.push(eTL_TR, eTR_TL, eTR_BR, eBR_TR, eBR_BL, eBL_BR, eBL_TL, eTL_BL, eTR_BL, eBL_TR, eTL_BR, eBR_TL);\r\n        mesh.__faces.push(fTL_BL_TR, fTR_BL_BR, fTL_BR_BL, fTL_TR_BR);\r\n        mesh.__constraintShapes.push(boundShape);\r\n\r\n        var securityRect: number[] = [];\r\n        securityRect.push(0, 0, width, 0);\r\n        securityRect.push(width, 0, width, height);\r\n        securityRect.push(width, height, 0, height);\r\n        securityRect.push(0, height, 0, 0);\r\n        mesh.clipping = false;\r\n        mesh.insertConstraintShape(securityRect);\r\n        mesh.clipping = true;\r\n\r\n        return mesh;\r\n    }\r\n\r\n}", "import { DDLSMesh } from \"../data/DDLSMesh\";\r\nimport { DDLSVertex } from \"../data/DDLSVertex\";\r\n\r\n\r\nexport class IteratorFromMeshToVertices {\r\n\r\n\tprivate _fromMesh: DDLSMesh;\r\n\tprivate _currIndex: number;\r\n\r\n\tconstructor() {\r\n\r\n\t}\r\n\r\n\tset fromMesh(value: DDLSMesh) {\r\n\t\tthis._fromMesh = value;\r\n\t\tthis._currIndex = 0;\r\n\t}\r\n\r\n\tprivate _resultVertex: DDLSVertex;\r\n\r\n\tnext(): DDLSVertex {\r\n\t\tdo {\r\n\t\t\tif (this._currIndex < this._fromMesh.__vertices.length) {\r\n\t\t\t\tthis._resultVertex = this._fromMesh.__vertices[this._currIndex];\r\n\t\t\t\tthis._currIndex++;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis._resultVertex = null;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile (!this._resultVertex.isReal)\r\n\r\n\t\treturn this._resultVertex;\r\n\t}\r\n\r\n}", "import { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSVertex } from \"../data/DDLSVertex\";\r\n\r\n\r\nexport class IteratorFromVertexToIncomingEdges {\r\n\r\n\tprivate _fromVertex: DDLSVertex;\r\n\tprivate _nextEdge: DDLSEdge;\r\n\r\n\tconstructor() {\r\n\r\n\t}\r\n\r\n\tset fromVertex(value: DDLSVertex) {\r\n\t\tthis._fromVertex = value;\r\n\t\tthis._nextEdge = this._fromVertex.edge;\r\n\t\twhile (!this._nextEdge.isReal) {\r\n\t\t\tthis._nextEdge = this._nextEdge.rotLeftEdge;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _resultEdge: DDLSEdge;\r\n\r\n\tnext(): DDLSEdge {\r\n\t\tif (this._nextEdge) {\r\n\t\t\tthis._resultEdge = this._nextEdge.oppositeEdge;\r\n\t\t\tdo {\r\n\t\t\t\tthis._nextEdge = this._nextEdge.rotLeftEdge;\r\n\t\t\t\tif (this._nextEdge == this._fromVertex.edge) {\r\n\t\t\t\t\tthis._nextEdge = null;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (!this._nextEdge.isReal)\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._resultEdge = null;\r\n\t\t}\r\n\r\n\t\treturn this._resultEdge;\r\n\t}\r\n\r\n}", "import { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSFace } from \"../data/DDLSFace\";\r\nimport { DDLSMesh } from \"../data/DDLSMesh\";\r\nimport { DDLSVertex } from \"../data/DDLSVertex\";\r\nimport { DDLSGeom2D } from \"../data/math/DDLSGeom2D\";\r\nimport { DDLSPoint2D } from \"../data/math/DDLSPoint2D\";\r\nimport { Vec2 } from \"cc\";\r\n\r\n\r\nexport class DDLSUtils {\r\n\r\n    private static checkedEdges: Map<number, boolean> = new Map<number, boolean>();\r\n\r\n    /**\r\n     * \u8BA1\u7B97\u89D2\u8272\u7AD9\u4F4D\u4F4D\u7F6E\r\n     * @param world \r\n     * @param role_x \r\n     * @param role_y \r\n     * @param targetX \r\n     * @param targetY \r\n     * @param radius \r\n     * @param result \r\n     * @returns \r\n     */\r\n    static calculatePos(mesh: DDLSMesh, role_x: number, role_y: number, targetX: number, targetY: number, radius: number, result?: { x: number, y: number }): { x: number, y: number } {\r\n        result = result || { x: 0, y: 0 };\r\n        radius = radius || 1;\r\n        const vector = new Vec2();\r\n        vector.set(targetX - role_x, targetY - role_y);\r\n        let len = vector.length();\r\n        let count = Math.ceil(len / radius) || 1;\r\n        let tx: number = role_x;\r\n        let ty: number = role_y;\r\n        //\u6BCF\u6B21\u79FB\u52A8\u534A\u5F84\u8DDD\u79BB\u8FDB\u884C\u6D4B\u8BD5,\u68C0\u6D4B\u4E24\u70B9\u4E4B\u95F4\u662F\u5426\u6709\u963B\u6321\r\n        let isblock: boolean = false;\r\n        vector.normalize();\r\n        vector.multiplyScalar(radius);\r\n        for (let index = 0; index < count; index++) {\r\n            tx += vector.x;\r\n            ty += vector.y;\r\n            if (DDLSGeom2D.isCircleIntersectingAnyConstraint(tx, ty, radius, mesh)) {\r\n                tx -= vector.x;\r\n                ty -= vector.y;\r\n                isblock = true;\r\n                break;\r\n            }\r\n        }\r\n        if (isblock) {\r\n            result.x = tx;\r\n            result.y = ty;\r\n        } else {\r\n            result.x = targetX;\r\n            result.y = targetY;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * \u68C0\u6D4B\u662F\u5426\u53D1\u751F\u78B0\u649E\u5E76\u8FD4\u56DE\u78B0\u649E\u7684\u8FB9\u7F18\u5BF9\u8C61\r\n     */\r\n    static isCircleIntersectingAnyConstraint(x: number, y: number, radius: number, mesh: DDLSMesh, result?: Array<DDLSEdge>): Array<DDLSEdge> {\r\n        result = result || [];\r\n        result.length = 0;\r\n        if (x <= 0 || x >= mesh.width || y <= 0 || y >= mesh.height)\r\n            return null;\r\n\r\n        let loc: Object = DDLSGeom2D.locatePosition(x, y, mesh);\r\n        let face: DDLSFace;\r\n        if (loc instanceof DDLSVertex)\r\n            face = (loc as DDLSVertex).edge.leftFace;\r\n        else if (loc instanceof DDLSEdge)\r\n            face = (loc as DDLSEdge).leftFace;\r\n        else\r\n            face = loc as DDLSFace;\r\n\r\n        // check if edge intersects\r\n        let edgesToCheck: Array<DDLSEdge> = new Array<DDLSEdge>();\r\n        edgesToCheck.push(face.edge);\r\n        edgesToCheck.push(face.edge.nextLeftEdge);\r\n        edgesToCheck.push(face.edge.nextLeftEdge.nextLeftEdge);\r\n\r\n        //clear\r\n        DDLSUtils.checkedEdges.clear();\r\n\r\n        let edge: DDLSEdge;\r\n        let pos1: DDLSPoint2D;\r\n        let pos2: DDLSPoint2D;\r\n        let intersecting: boolean;\r\n        while (edgesToCheck.length > 0) {\r\n            edge = edgesToCheck.pop();\r\n            DDLSUtils.checkedEdges.set(edge.id, true);\r\n            pos1 = edge.originVertex.pos;\r\n            pos2 = edge.destinationVertex.pos;\r\n            intersecting = DDLSGeom2D.intersectionsSegmentCircle(pos1.x, pos1.y, pos2.x, pos2.y, x, y, radius);\r\n            if (intersecting) {\r\n                if (edge.isConstrained)\r\n                    result.push(edge);\r\n                else {\r\n                    edge = edge.oppositeEdge.nextLeftEdge;\r\n                    if (!DDLSUtils.checkedEdges.has(edge.id) && !DDLSUtils.checkedEdges.has(edge.oppositeEdge.id)\r\n                        && edgesToCheck.indexOf(edge) == -1 && edgesToCheck.indexOf(edge.oppositeEdge) == -1) {\r\n                        edgesToCheck.push(edge);\r\n                    }\r\n                    edge = edge.nextLeftEdge;\r\n                    if (!DDLSUtils.checkedEdges.has(edge.id) && !DDLSUtils.checkedEdges.has(edge.oppositeEdge.id)\r\n                        && edgesToCheck.indexOf(edge) == -1 && edgesToCheck.indexOf(edge.oppositeEdge) == -1) {\r\n                        edgesToCheck.push(edge);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * \u8DEF\u5F84\u683C\u5F0F\u5316\r\n     * @param path \r\n     * @param result \r\n     * @param checkDup   \u662F\u5426\u53BB\u91CD\r\n     */\r\n    static pathFormatting(path: Array<number>, result: Array<number>, checkDup: boolean = false): void {\r\n        if (checkDup) {\r\n            let cache: any = {};\r\n            let key: string;\r\n            for (let index = 0; index < path.length; index += 2) {\r\n                const x = path[index];\r\n                const y = path[index + 1];\r\n                key = x + \"_\" + y;\r\n                if (cache[key]) {\r\n                    path.splice(index, 2);\r\n                    index -= 2;\r\n                } else {\r\n                    cache[key] = true;\r\n                }\r\n            }\r\n        }\r\n        for (let index = 0; index < path.length; index += 2) {\r\n            result.push(path[index], path[index + 1]);\r\n            if (index > 0) {\r\n                result.push(path[index], path[index + 1]);\r\n            }\r\n        }\r\n        result.push(path[0], path[1]);\r\n    }\r\n}", "import { Rect, Vec2 } from \"cc\";\r\n\r\n/** A polygon describes a closed two-dimensional shape bounded by a number of straight\r\n *  line segments.\r\n *\r\n *  <p>The vertices of a polygon form a closed path (i.e. the last vertex will be connected\r\n *  to the first). It is recommended to provide the vertices in clockwise order.\r\n *  Self-intersecting paths are not supported and will give wrong results on triangulation,\r\n *  area calculation, etc.</p>\r\n */\r\nexport class Polygon {\r\n\r\n    public _coords: Array<number>;\r\n\r\n    public _rect: Rect = new Rect();\r\n\r\n    /** Creates a Polygon with the given coordinates.\r\n     *  @param vertices an array that contains either 'Point' instances or\r\n     *                  alternating 'x' and 'y' coordinates.\r\n     */\r\n    constructor(vertices?: Array<number>) {\r\n        this._coords = [];\r\n        this._rect.x = Number.MAX_VALUE;\r\n        this._rect.y = Number.MAX_VALUE;\r\n        this._rect.width = Number.MAX_VALUE;\r\n        this._rect.height = Number.MAX_VALUE;\r\n        this.addVertices.apply(this, vertices);\r\n    }\r\n\r\n    /** Creates a clone of this polygon. */\r\n    clone(): Polygon {\r\n        let clone: Polygon = new Polygon();\r\n        let numCoords = this._coords.length;\r\n\r\n        for (let i = 0; i < numCoords; ++i) {\r\n            clone._coords[i] = this._coords[i];\r\n            clone._rect = this._rect.clone();\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /** Reverses the order of the vertices. Note that some methods of the Polygon class\r\n     *  require the vertices in clockwise order. */\r\n    reverse(): void {\r\n        let numCoords = this._coords.length;\r\n        let numVertices = Math.floor(numCoords / 2);\r\n        let tmp: number;\r\n\r\n        for (let i = 0; i < numVertices; i += 2) {\r\n            tmp = this._coords[i];\r\n            this._coords[i] = this._coords[numCoords - i - 2];\r\n            this._coords[numCoords - i - 2] = tmp;\r\n\r\n            tmp = this._coords[i + 1];\r\n            this._coords[i + 1] = this._coords[numCoords - i - 1];\r\n            this._coords[numCoords - i - 1] = tmp;\r\n        }\r\n    }\r\n\r\n    /** Adds vertices to the polygon. Pass either a list of 'Point' instances or alternating\r\n     *  'x' and 'y' coordinates. */\r\n    addVertices(...args: Array<number | { x: number, y: number }>): void {\r\n        let i: number;\r\n        let numArgs: number = args.length;\r\n        let numCoords: number = this._coords.length;\r\n\r\n        let minX = Math.min(this._rect.x, Number.MAX_VALUE);\r\n        let minY = Math.min(this._rect.y, Number.MAX_VALUE);\r\n        let maxX = Math.max(this._rect.x + this._rect.width, Number.MIN_VALUE);\r\n        let maxY = Math.max(this._rect.y + this._rect.height, Number.MIN_VALUE);\r\n\r\n        if (numArgs > 0) {\r\n            if (typeof args[0] == \"number\") {\r\n                for (i = 0; i < numArgs; ++i) {\r\n                    const value = args[i] as number;\r\n                    this._coords[numCoords + i] = value;\r\n                    //x\r\n                    if ((i + 1) % 2 != 0) {\r\n                        if (value < minX) {\r\n                            minX = value;\r\n                        }\r\n                        if (value > maxX) {\r\n                            maxX = value;\r\n                        }\r\n                    } else {//y\r\n                        if (value < minY) {\r\n                            minY = value;\r\n                        }\r\n                        if (value > maxY) {\r\n                            maxY = value;\r\n                        }\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                for (i = 0; i < numArgs; i++) {\r\n                    const point = args[i] as { x: number, y: number };\r\n                    this._coords[numCoords + i * 2] = point.x;\r\n                    this._coords[numCoords + i * 2 + 1] = point.y;\r\n                    if (point.x < minX) {\r\n                        minX = point.x;\r\n                    }\r\n                    if (point.y < minY) {\r\n                        minY = point.y;\r\n                    }\r\n                    if (point.x > maxX) {\r\n                        maxX = point.x;\r\n                    }\r\n                    if (point.y > maxY) {\r\n                        maxY = point.y;\r\n                    }\r\n                }\r\n            }\r\n            this._rect.set(\r\n                minX,\r\n                minY,\r\n                maxX - minX,\r\n                maxY - minY\r\n            )\r\n        }\r\n    }\r\n\r\n    /** Moves a given vertex to a certain position or adds a new vertex at the end. */\r\n    setVertex(index: number, x: number, y: number): void {\r\n        if (index >= 0 && index <= this.numVertices) {\r\n            this._coords[index * 2] = x;\r\n            this._coords[index * 2 + 1] = y;\r\n        } else {\r\n            throw new RangeError(\"Invalid index: \" + index);\r\n        }\r\n    }\r\n\r\n    /** Returns the coordinates of a certain vertex. */\r\n    getVertex(index: number, out: Vec2 = null): Vec2 {\r\n        if (index >= 0 && index < this.numVertices) {\r\n            out = out || new Vec2();\r\n            out.set(this._coords[index * 2], this._coords[index * 2 + 1])\r\n            return out;\r\n        }\r\n        else {\r\n            throw new RangeError(\"Invalid index: \" + index);\r\n        }\r\n    }\r\n\r\n    /** Figures out if the given coordinates lie within the polygon. */\r\n    contains(x: number, y: number): Boolean {\r\n        // Algorithm & implementation thankfully taken from:\r\n        // -> http://alienryderflex.com/polygon/\r\n\r\n        let i: number, j: number = this.numVertices - 1;\r\n        let oddNodes: number = 0;\r\n\r\n        for (i = 0; i < this.numVertices; ++i) {\r\n            let ix: number = this._coords[i * 2];\r\n            let iy: number = this._coords[i * 2 + 1];\r\n            let jx: number = this._coords[j * 2];\r\n            let jy: number = this._coords[j * 2 + 1];\r\n\r\n            if ((iy < y && jy >= y || jy < y && iy >= y) && (ix <= x || jx <= x)) {\r\n                oddNodes ^= Number(ix + (y - iy) / (jy - iy) * (jx - ix) < x);\r\n            }\r\n            j = i;\r\n        }\r\n\r\n        return oddNodes != 0;\r\n    }\r\n\r\n    /** Figures out if the given point lies within the polygon. */\r\n    containsPoint(point: { x: number, y: number }): Boolean {\r\n        return this.contains(point.x, point.y);\r\n    }\r\n\r\n    /** Creates a string that contains the values of all included points. */\r\n    toString(): string {\r\n        let result: string = \"[Polygon\";\r\n        let numPoints: number = this.numVertices;\r\n\r\n        if (numPoints > 0) result += \"\\n\";\r\n\r\n        for (let i: number = 0; i < numPoints; ++i) {\r\n            result += \"  [Vertex \" + i + \": \" +\r\n                \"x=\" + this._coords[i * 2].toFixed(1) + \", \" +\r\n                \"y=\" + this._coords[i * 2 + 1].toFixed(1) + \"]\" +\r\n                (i == numPoints - 1 ? \"\\n\" : \",\\n\");\r\n        }\r\n\r\n        return result + \"]\";\r\n    }\r\n\r\n    // helpers\r\n\r\n    /** Calculates if the area of the triangle a->b->c is to on the right-hand side of a->b. */\r\n    private static isConvexTriangle(ax: number, ay: number,\r\n        bx: number, by: number,\r\n        cx: number, cy: number): Boolean {\r\n        // dot product of [the normal of (a->b)] and (b->c) must be positive\r\n        return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;\r\n    }\r\n\r\n    /** Finds out if the vector a->b intersects c->d. */\r\n    private static areVectorsIntersecting(ax: number, ay: number, bx: number, by: number,\r\n        cx: number, cy: number, dx: number, dy: number): Boolean {\r\n        if ((ax == bx && ay == by) || (cx == dx && cy == dy)) return false; // length = 0\r\n\r\n        let abx: number = bx - ax;\r\n        let aby: number = by - ay;\r\n        let cdx: number = dx - cx;\r\n        let cdy: number = dy - cy;\r\n        let tDen: number = cdy * abx - cdx * aby;\r\n\r\n        if (tDen == 0.0) return false; // parallel or identical\r\n\r\n        let t: number = (aby * (cx - ax) - abx * (cy - ay)) / tDen;\r\n\r\n        if (t < 0 || t > 1) return false; // outside c->d\r\n\r\n        let s: number = aby ? (cy - ay + t * cdy) / aby :\r\n            (cx - ax + t * cdx) / abx;\r\n\r\n        return s >= 0.0 && s <= 1.0; // inside a->b\r\n    }\r\n\r\n    // properties\r\n\r\n    /** Indicates if the polygon's line segments are not self-intersecting.\r\n     *  Beware: this is a brute-force implementation with <code>O(n^2)</code>. */\r\n    get isSimple(): Boolean {\r\n        let numCoords: number = this._coords.length;\r\n        if (numCoords <= 6) return true;\r\n\r\n        for (let i: number = 0; i < numCoords; i += 2) {\r\n            let ax: number = this._coords[i];\r\n            let ay: number = this._coords[i + 1];\r\n            let bx: number = this._coords[(i + 2) % numCoords];\r\n            let by: number = this._coords[(i + 3) % numCoords];\r\n            let endJ: number = i + numCoords - 2;\r\n\r\n            for (let j: number = i + 4; j < endJ; j += 2) {\r\n                let cx: number = this._coords[j % numCoords];\r\n                let cy: number = this._coords[(j + 1) % numCoords];\r\n                let dx: number = this._coords[(j + 2) % numCoords];\r\n                let dy: number = this._coords[(j + 3) % numCoords];\r\n\r\n                if (Polygon.areVectorsIntersecting(ax, ay, bx, by, cx, cy, dx, dy))\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** Indicates if the polygon is convex. In a convex polygon, the vector between any two\r\n     *  points inside the polygon lies inside it, as well. */\r\n    get isConvex(): Boolean {\r\n        let numCoords: number = this._coords.length;\r\n\r\n        if (numCoords < 6) return true;\r\n        else {\r\n            for (let i = 0; i < numCoords; i += 2) {\r\n                if (!Polygon.isConvexTriangle(this._coords[i], this._coords[i + 1],\r\n                    this._coords[(i + 2) % numCoords], this._coords[(i + 3) % numCoords],\r\n                    this._coords[(i + 4) % numCoords], this._coords[(i + 5) % numCoords])) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** Calculates the total area of the polygon. */\r\n    get area(): number {\r\n        let area: number = 0;\r\n        let numCoords: number = this._coords.length;\r\n\r\n        if (numCoords >= 6) {\r\n            for (let i: number = 0; i < numCoords; i += 2) {\r\n                area += this._coords[i] * this._coords[(i + 3) % numCoords];\r\n                area -= this._coords[i + 1] * this._coords[(i + 2) % numCoords];\r\n            }\r\n        }\r\n\r\n        return area / 2.0;\r\n    }\r\n\r\n    /** Returns the total number of vertices spawning up the polygon. Assigning a value\r\n     *  that's smaller than the current number of vertices will crop the path; a bigger\r\n     *  value will fill up the path with zeros. */\r\n    get numVertices(): number {\r\n        return this._coords.length / 2;\r\n    }\r\n\r\n    set numVertices(value: number) {\r\n        let oldLength: number = this.numVertices;\r\n        this._coords.length = value * 2;\r\n\r\n        if (oldLength < value) {\r\n            for (let i: number = oldLength; i < value; ++i)\r\n                this._coords[i * 2] = this._coords[i * 2 + 1] = 0.0;\r\n        }\r\n    }\r\n\r\n    /** Returns the number of triangles that will be required when triangulating the polygon. */\r\n    get numTriangles(): number {\r\n        let numVertices: number = this.numVertices;\r\n        return numVertices >= 3 ? numVertices - 2 : 0;\r\n    }\r\n\r\n    get rect(): Rect {\r\n        return this._rect;\r\n    }\r\n}", "import { Color, Graphics, Node, UITransform } from \"cc\";\r\nimport { DDLSEdge } from \"../data/DDLSEdge\";\r\nimport { DDLSFace } from \"../data/DDLSFace\";\r\nimport { DDLSMesh } from \"../data/DDLSMesh\";\r\nimport { DDLSVertex } from \"../data/DDLSVertex\";\r\nimport { IteratorFromMeshToVertices } from \"../iterators/IteratorFromMeshToVertices\";\r\nimport { IteratorFromVertexToIncomingEdges } from \"../iterators/IteratorFromVertexToIncomingEdges\";\r\n\r\n\r\n\r\nexport class DDLSSimpleView extends Node {\r\n    /**\r\n     * Y\u8F74\u53CD\u8F6C\r\n     */\r\n    yAxisFlip: boolean = true;\r\n\r\n    uiTrans: UITransform;\r\n\r\n    colorEdges: Color = new Color(255, 255, 255, 255);\r\n    colorConstraints: Color = new Color(255, 0, 0, 255);\r\n    colorVertices: Color = new Color(0, 0, 255, 255);\r\n    colorPaths: Color = new Color(255, 0, 255, 255);\r\n    colorEntities: Color = new Color(0, 255, 0, 255);\r\n\r\n    private edgesNode: Node;\r\n    private constraintsNode: Node;\r\n    private verticesNode: Node;\r\n    private pathsNode: Node;\r\n    private entitiesNode: Node;\r\n\r\n    private edges: Graphics;\r\n    private constraints: Graphics;\r\n    private vertices: Graphics;\r\n    private paths: Graphics;\r\n    private entities: Graphics;\r\n    private showVerticesIndices: boolean = false;\r\n\r\n\r\n    constructor(YAxisFlip: boolean = true) {\r\n        super();\r\n        this.yAxisFlip = YAxisFlip;\r\n\r\n        this.edgesNode = new Node(\"Edges\");\r\n        this.__addUITrans(this.edgesNode);\r\n\r\n        this.constraintsNode = new Node(\"Constraints\");\r\n        this.__addUITrans(this.constraintsNode);\r\n\r\n        this.verticesNode = new Node(\"Vertices\");\r\n        this.__addUITrans(this.verticesNode);\r\n\r\n        this.pathsNode = new Node(\"Paths\");\r\n        this.__addUITrans(this.pathsNode);\r\n\r\n        this.entitiesNode = new Node(\"Entities\");\r\n        this.__addUITrans(this.entitiesNode);\r\n\r\n        this.edges = this.edgesNode.addComponent(Graphics);\r\n        this.constraints = this.constraintsNode.addComponent(Graphics);\r\n        this.vertices = this.verticesNode.addComponent(Graphics);\r\n        this.paths = this.pathsNode.addComponent(Graphics);\r\n        this.entities = this.entitiesNode.addComponent(Graphics);\r\n\r\n        this.addChild(this.edgesNode);\r\n        this.addChild(this.constraintsNode);\r\n        this.addChild(this.verticesNode);\r\n        this.addChild(this.pathsNode);\r\n        this.addChild(this.entitiesNode);\r\n\r\n        this.uiTrans = this.__addUITrans(this);\r\n    }\r\n\r\n    private __addUITrans(node: Node): UITransform {\r\n        let trans = node.addComponent(UITransform);\r\n        trans.setAnchorPoint(0, 1);\r\n        return trans;\r\n    }\r\n\r\n    reset(): void {\r\n        this.clear();\r\n    }\r\n\r\n    clear(): void {\r\n        this.edges.clear();\r\n        this.constraints.clear();\r\n        this.vertices.clear();\r\n        this.paths.clear();\r\n        this.entities.clear();\r\n    }\r\n\r\n    /**\r\n     * \u7ED8\u5236\u70B9\r\n     * @param x \r\n     * @param y \r\n     * @param radius\r\n     * @param color\r\n     * @param cleanBefore \r\n     */\r\n    drawPoint(x: number, y: number, radius: number, color: Color, cleanBefore?: boolean): void {\r\n        if (cleanBefore)\r\n            this.entities.clear();\r\n\r\n        this.entities.fillColor = color;\r\n        this.entities.circle(x, y, radius);\r\n        this.entities.fill();\r\n    }\r\n\r\n    /**\r\n     * \u7ED8\u5236\u8DEF\u5F84\r\n     * @param path \r\n     * @param cleanBefore \r\n     * @returns \r\n     */\r\n    drawPathByPoints(path: Array<{ x: number, y: number }>, cleanBefore: boolean = true): void {\r\n        if (cleanBefore) {\r\n            this.paths.clear();\r\n        }\r\n        if (path.length == 0) {\r\n            return;\r\n        }\r\n        this.paths.lineWidth = 5;\r\n        this.paths.strokeColor = this.colorPaths;\r\n\r\n        this.paths.moveTo(path[0].x, path[0].y);\r\n        this.paths.circle(path[0].x, path[0].y, 4);\r\n        for (let index = 1; index < path.length; index++) {\r\n            this.paths.lineTo(path[index].x, path[index].y);\r\n            this.paths.circle(path[index].x, path[index].y, 4);\r\n        }\r\n        this.paths.stroke();\r\n        this.paths.fill();\r\n    }\r\n\r\n\r\n    /**\r\n     * \u7ED8\u5236\u8DEF\u5F84\r\n     * @param path \r\n     * @param cleanBefore \r\n     * @returns \r\n     */\r\n    drawPath(path: Array<number>, cleanBefore: boolean = true): void {\r\n        if (cleanBefore) {\r\n            this.paths.clear();\r\n        }\r\n        if (path.length == 0) {\r\n            return;\r\n        }\r\n        this.paths.strokeColor = this.colorPaths;\r\n        this.paths.lineWidth = 1.5;\r\n        this.paths.moveTo(path[0], this.getY(path[1]));\r\n        this.paths.circle(path[0], this.getY(path[1]), 4);\r\n        for (let index = 2; index < path.length; index += 2) {\r\n            const x = path[index];\r\n            const y = path[index + 1];\r\n            this.paths.lineTo(x, this.getY(y));\r\n            this.paths.circle(x, y, 4);\r\n        }\r\n        this.paths.stroke();\r\n    }\r\n\r\n    /**\r\n     * \u7ED8\u5236mesh\r\n     * @param mesh \r\n     * @param graphics_com \r\n     */\r\n    drawMesh(mesh: DDLSMesh): void {\r\n        this.vertices.clear();\r\n        this.constraints.clear();\r\n        this.edges.clear();\r\n\r\n        let vertex: DDLSVertex;\r\n        let incomingEdge: DDLSEdge;\r\n        let holdingFace: DDLSFace;\r\n\r\n        let iterVertices = new IteratorFromMeshToVertices();\r\n        iterVertices.fromMesh = mesh;\r\n        //\r\n        let iterEdges = new IteratorFromVertexToIncomingEdges();\r\n        let dictVerticesDone = new Map<number, boolean>();\r\n        //\r\n        let constraintsFrist: boolean = true;\r\n        let edgesFrist: boolean = true;\r\n        while (vertex = iterVertices.next()) {\r\n            dictVerticesDone.set(vertex.id, true);\r\n            if (!this.vertexIsInsideAABB(vertex, mesh)) {\r\n                continue;\r\n            }\r\n            this.vertices.fillColor = this.colorVertices;\r\n            this.vertices.circle(vertex.pos.x, this.getY(vertex.pos.y), 0.5);\r\n\r\n            // vertices.graphics.beginFill(this.colorVertices, 1);\r\n            // vertices.graphics.drawCircle(vertex.pos.x, vertex.pos.y, 0.5);\r\n            // vertices.graphics.endFill();\r\n\r\n            // if (this.showVerticesIndices) {\r\n            //     var tf: egret.TextField = new egret.TextField();\r\n            //     tf.touchEnabled = false;\r\n            //     tf.text = String(vertex.id);\r\n            //     tf.x = vertex.pos.x + 5;\r\n            //     tf.y = vertex.pos.y + 5;\r\n            //     tf.width = tf.height = 20;\r\n            //     this.vertices.addChild(tf);\r\n            // }\r\n\r\n            constraintsFrist = edgesFrist = true;\r\n            iterEdges.fromVertex = vertex;\r\n            while (incomingEdge = iterEdges.next()) {\r\n                if (!dictVerticesDone.has(incomingEdge.originVertex.id)) {\r\n                    if (incomingEdge.isConstrained) {\r\n                        this.constraints.strokeColor = this.colorConstraints;\r\n                        this.constraints.lineWidth = 3;\r\n                        if (constraintsFrist) {\r\n                            constraintsFrist = false;\r\n                            this.constraints.moveTo(incomingEdge.destinationVertex.pos.x, this.getY(incomingEdge.destinationVertex.pos.y));\r\n                        } else {\r\n                            this.constraints.lineTo(incomingEdge.destinationVertex.pos.x, this.getY(incomingEdge.destinationVertex.pos.y));\r\n                        }\r\n                        this.constraints.lineTo(incomingEdge.originVertex.pos.x, this.getY(incomingEdge.originVertex.pos.y));\r\n                    }\r\n                    else {\r\n                        this.edges.strokeColor = this.colorEdges;\r\n                        this.edges.lineWidth = 2;\r\n                        if (edgesFrist) {\r\n                            this.edges.moveTo(incomingEdge.destinationVertex.pos.x, this.getY(incomingEdge.destinationVertex.pos.y));\r\n                            edgesFrist = false;\r\n                        } else {\r\n                            this.edges.lineTo(incomingEdge.destinationVertex.pos.x, this.getY(incomingEdge.destinationVertex.pos.y));\r\n                        }\r\n                        this.edges.lineTo(incomingEdge.originVertex.pos.x, this.getY(incomingEdge.originVertex.pos.y));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.vertices.stroke();\r\n        this.constraints.stroke();\r\n        this.edges.stroke();\r\n    }\r\n\r\n    private vertexIsInsideAABB(vertex: DDLSVertex, mesh: DDLSMesh): boolean {\r\n        if (vertex.pos.x < 0 || vertex.pos.x > mesh.width || vertex.pos.y < 0 || vertex.pos.y > mesh.height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private getY(y: number): number {\r\n        return this.yAxisFlip ? 0 - y : y;\r\n    }\r\n}", "import { GraphLink } from \"./GraphLink\";\r\n\r\n\r\nexport class GraphNode {\r\n    id: string;\r\n    links: Array<GraphLink>;\r\n    data: any;\r\n    constructor(id: string, data: any) {\r\n        this.id = id;\r\n        this.data = data;\r\n    }\r\n}", "\r\n\r\nexport class GraphLink {\r\n    fromId: string;\r\n    toId: string;\r\n    id: string;\r\n    data: any;\r\n    constructor(fromId: string, toId: string, data: any, id: string) {\r\n        this.fromId = fromId;\r\n        this.toId = toId;\r\n        this.data = data;\r\n        this.id = id;\r\n    }\r\n}", "import { GraphNode } from \"./GraphNode\";\r\nimport { GraphLink } from \"./GraphLink\";\r\nimport { GraphOptions } from \"./GraphOptions\";\r\nimport { Event, EventDispatcher } from \"dream-cc-core\";\r\n\r\n/**\r\n * \r\n */\r\nexport class Graph extends EventDispatcher {\r\n\r\n    private __options: GraphOptions;\r\n    private __nodes: Map<string, GraphNode>;\r\n    private __links: Map<string, GraphLink>;\r\n    private __multiEdges: { [key: string]: number };\r\n    private createLink: (fromId: string, toId: string, data?: any) => GraphLink;\r\n\r\n    constructor(options: GraphOptions) {\r\n        super();\r\n        this.__options = options;\r\n        this.__nodes = new Map<string, GraphNode>();\r\n        this.__links = new Map<string, GraphLink>();\r\n        this.__multiEdges = {};\r\n        if (this.__options.multigraph === undefined) {\r\n            this.__options.multigraph = false;\r\n        }\r\n        this.createLink = this.__options.multigraph ? this.__createUniqueLink : this.__createSingleLink;\r\n    }\r\n\r\n    addNode(id: string, data?: any): GraphNode {\r\n        if (id == undefined) {\r\n            throw new Error(\"Invalid node identifier.\");\r\n        }\r\n        let node = this.__nodes.get(id);\r\n        if (!node) {\r\n            node = new GraphNode(id, data);\r\n            this.emit(Event.ADD, node);\r\n        } else {\r\n            node.data = data;\r\n            this.emit(Event.UPDATE, node);\r\n        }\r\n        this.__nodes.set(id, node);\r\n        return node;\r\n    }\r\n\r\n    getNode(id: string): GraphNode {\r\n        return this.__nodes.get(id);\r\n    }\r\n\r\n    removeNode(id: string): boolean {\r\n        let node = this.getNode(id);\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        let prevLinks = node.links;\r\n        if (prevLinks) {\r\n            node.links = null;\r\n            for (let index = 0; index < prevLinks.length; index++) {\r\n                const link = prevLinks[index];\r\n                this.removeLink(link);\r\n            }\r\n        }\r\n        this.__nodes.delete(id);\r\n        this.emit(Event.REMOVE, node);\r\n        return true;\r\n    }\r\n\r\n    addLink(fromId: string, toId: string, data: any): GraphLink {\r\n        let link_id = this.__makeLinkId(fromId, toId);\r\n        if (this.__links.has(link_id)) {\r\n            return this.__links.get(link_id);\r\n        }\r\n        let fromNode = this.getNode(fromId) || this.addNode(fromId);\r\n        let toNode = this.getNode(toId) || this.addNode(toId);\r\n\r\n        let link = this.createLink(fromId, toId, data);\r\n        this.__links.set(link_id, link);\r\n\r\n        // TODO: this is not cool. On large graphs potentially would consume more memory.\r\n        this.addLinkToNode(fromNode, link);\r\n        if (fromId !== toId) {\r\n            // make sure we are not duplicating links for self-loops\r\n            this.addLinkToNode(toNode, link);\r\n        }\r\n        this.emit(Event.ADD, link);\r\n        return link;\r\n    }\r\n\r\n    getLink(fromId: string, toId: string): GraphLink {\r\n        let node = this.getNode(fromId);\r\n        if (!node || !node.links) {\r\n            return null;\r\n        }\r\n        for (let index = 0; index < node.links.length; index++) {\r\n            const link = node.links[index];\r\n            if (link.fromId === fromId && link.toId === toId) {\r\n                return link;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    removeLink(link: GraphLink): boolean {\r\n        if (!link) {\r\n            return false;\r\n        }\r\n        if (this.__links.has(link.id)) {\r\n            return false;\r\n        }\r\n        this.__links.delete(link.id);\r\n        let fromNode = this.getNode(link.fromId);\r\n        let toNode = this.getNode(link.toId);\r\n        if (fromNode) {\r\n            const idx = fromNode.links.indexOf(link);\r\n            if (idx >= 0) {\r\n                fromNode.links.splice(idx, 1);\r\n            }\r\n        }\r\n        if (toNode) {\r\n            const idx = toNode.links.indexOf(link);\r\n            if (idx >= 0) {\r\n                toNode.links.splice(idx, 1);\r\n            }\r\n        }\r\n        this.emit(Event.REMOVE, link);\r\n        return true;\r\n    }\r\n\r\n    private addLinkToNode(node: GraphNode, link: GraphLink) {\r\n        if (node.links) {\r\n            node.links.push(link);\r\n        } else {\r\n            node.links = [link];\r\n        }\r\n    }\r\n\r\n    private __createUniqueLink(fromId: string, toId: string, data?: any): GraphLink {\r\n        var linkId = this.__makeLinkId(fromId, toId);\r\n        var isMultiEdge = this.__multiEdges.hasOwnProperty(linkId);\r\n        if (isMultiEdge || this.getLink(fromId, toId)) {\r\n            if (!isMultiEdge) {\r\n                this.__multiEdges[linkId] = 0;\r\n            }\r\n            var suffix = '@' + (++this.__multiEdges[linkId]);\r\n            linkId = this.__makeLinkId(fromId + suffix, toId + suffix);\r\n        }\r\n        return new GraphLink(fromId, toId, data, linkId);\r\n    }\r\n\r\n    private __createSingleLink(fromId: string, toId: string, data?: any): GraphLink {\r\n        var linkId = this.__makeLinkId(fromId, toId);\r\n        return new GraphLink(fromId, toId, data, linkId);\r\n    }\r\n\r\n    get nodeCount(): number {\r\n        return this.__nodes.size;\r\n    }\r\n\r\n    get linkCount(): number {\r\n        return this.__links.size;\r\n    }\r\n\r\n    /**\r\n     * \u83B7\u53D6\u8282\u70B9\u94FE\u63A5\r\n     * @param id \r\n     * @returns \r\n     */\r\n    getLinks(id: string): Array<GraphLink> {\r\n        let node = this.getNode(id);\r\n        return node ? node.links : null;\r\n    }\r\n\r\n    clear(): void {\r\n        while (this.__nodes.size > 0) {\r\n            this.removeNode(this.__nodes.keys().next().value);\r\n        }\r\n        this.__nodes.clear();\r\n        this.__links.clear();\r\n        this.__multiEdges = {};\r\n    }\r\n\r\n    forEachNode(callback: (node: GraphNode) => boolean): boolean {\r\n        if (callback == null || callback == undefined) {\r\n            return;\r\n        }\r\n        let values_iterator = this.__nodes.values();\r\n        let next_value = values_iterator.next();\r\n        while (!next_value.done) {\r\n            if (callback(next_value.value)) {\r\n                return true;\r\n            }\r\n            next_value = values_iterator.next();\r\n        }\r\n    }\r\n\r\n    forEachLink(callback: (link: GraphLink) => boolean): void {\r\n        if (callback == null || callback == undefined) {\r\n            return;\r\n        }\r\n        let values_iterator = this.__links.values();\r\n        let next_value = values_iterator.next();\r\n        while (!next_value.done) {\r\n            callback(next_value.value);\r\n            next_value = values_iterator.next();\r\n        }\r\n    }\r\n\r\n    forEachLinkedNode(nodeId: string, callback: (node: GraphNode, link: GraphLink) => boolean, oriented: boolean): boolean {\r\n        let node = this.getNode(nodeId);\r\n        if (oriented) {\r\n            return this.forEachOrientedLink(node.links, nodeId, callback);\r\n        } else {\r\n            return this.forEachNonOrientedLink(node.links, nodeId, callback);\r\n        }\r\n    }\r\n\r\n    forEachNonOrientedLink(links: Array<GraphLink>, nodeId: string, callback: (node: GraphNode, link: GraphLink) => boolean): boolean {\r\n        for (let index = 0; index < links.length; index++) {\r\n            const link = links[index];\r\n            const lined_node_id = link.fromId === nodeId ? link.toId : link.fromId;\r\n            const quit_fast = callback(this.getNode(lined_node_id), link);\r\n            if (quit_fast) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    forEachOrientedLink(links: Array<GraphLink>, nodeId: string, callback: (node: GraphNode, link: GraphLink) => boolean): boolean {\r\n        for (var i = 0; i < links.length; ++i) {\r\n            const link = links[i];\r\n            if (link.fromId === nodeId) {\r\n                const quitFast = callback(this.getNode(link.toId), link)\r\n                if (quitFast) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private __makeLinkId(fromId: string, toId: string): string {\r\n        return fromId.toString() + '\uD83D\uDC49 ' + toId.toString();\r\n    }\r\n}", "\r\n\r\nexport class GraphOptions {\r\n    multigraph: boolean;\r\n}", "import { GraphNode } from \"../graphs/GraphNode\";\r\nimport { INodeSearchState } from \"./INodeSearchState\";\r\n\r\n\r\nexport class NodeSearchState implements INodeSearchState {\r\n\r\n    node: GraphNode;\r\n    parent: NodeSearchState;\r\n    closed: boolean = false;\r\n    open: number = 0;\r\n    distanceToSource: number;\r\n    fScore: number;\r\n    heapIndex: number;\r\n    constructor(node: GraphNode) {\r\n        this.node = node;\r\n\r\n        // How we came to this node?\r\n        this.parent = null;\r\n\r\n        this.closed = false;\r\n        this.open = 0;\r\n\r\n        this.distanceToSource = Number.POSITIVE_INFINITY;\r\n        // the f(n) = g(n) + h(n) value\r\n        this.fScore = Number.POSITIVE_INFINITY;\r\n\r\n        // used to reconstruct heap when fScore is updated.\r\n        this.heapIndex = -1;\r\n    }\r\n}", "import { GraphNode } from \"../graphs/GraphNode\";\r\nimport { INodeSearchState } from \"./INodeSearchState\";\r\nimport { NodeSearchState } from \"./NodeSearchState\";\r\n\r\n\r\nexport class SearchStatePool {\r\n    \r\n    currentInCache: number = 0;\r\n    nodeCache: INodeSearchState[] = [];\r\n\r\n    createNewState(node: GraphNode): NodeSearchState {\r\n        let cached = this.nodeCache[this.currentInCache];\r\n        if (cached) {\r\n            cached.node = node;\r\n            cached.parent = null;\r\n            cached.closed = false;\r\n            cached.open = 0;\r\n\r\n            cached.distanceToSource = Number.POSITIVE_INFINITY;\r\n            // the f(n) = g(n) + h(n) value\r\n            cached.fScore = Number.POSITIVE_INFINITY;\r\n            cached.heapIndex = -1;\r\n        } else {\r\n            cached = new NodeSearchState(node);\r\n            this.nodeCache[this.currentInCache] = cached;\r\n        }\r\n        this.currentInCache++;\r\n        return cached;\r\n    }\r\n\r\n    reset(): void {\r\n        this.currentInCache = 0;\r\n    }\r\n}", "import { GraphLink } from \"./graphs/GraphLink\";\r\nimport { GraphNode } from \"./graphs/GraphNode\";\r\nimport { NodeSearchState } from \"./searchs/NodeSearchState\";\r\n\r\n\r\nexport class DefaultSettings {\r\n\r\n\r\n    /**\r\n    * \u662F\u5426\u963B\u585E\r\n    */\r\n    static __blocked: (a: GraphNode, b: GraphNode, link: GraphLink) => boolean;\r\n    static get blocked(): (a: GraphNode, b: GraphNode, link: GraphLink) => boolean {\r\n        if (!this.__blocked) {\r\n            return this.defaultBlocked;\r\n        }\r\n        return this.__blocked;\r\n    }\r\n\r\n    static set blocked(value: (a: GraphNode, b: GraphNode, link: GraphLink) => boolean) {\r\n        this.__blocked = value;\r\n    }\r\n\r\n    private static defaultBlocked(a: GraphNode, b: GraphNode, link: GraphLink): boolean {\r\n        return false;\r\n    }\r\n\r\n\r\n    static __heuristic: (a: GraphNode, b: GraphNode) => number;\r\n    /**\r\n     * \u542F\u53D1\u5F0F\u4EE3\u4EF7\u51FD\u6570\r\n     */\r\n    static get heuristic(): (a: GraphNode, b: GraphNode) => number {\r\n        if (!this.__heuristic) {\r\n            return this.defaultHeuristic;\r\n        }\r\n        return this.__heuristic;\r\n    }\r\n\r\n    static set heuristic(value: (a: GraphNode, b: GraphNode) => number) {\r\n        this.__heuristic = value;\r\n    }\r\n\r\n    private static defaultHeuristic(a: GraphNode, b: GraphNode): number {\r\n        return 0;\r\n    }\r\n\r\n    static __distance: (a: GraphNode, b: GraphNode, link: GraphLink) => number;\r\n    /**\r\n     * \u8DEF\u5F84\u8DDD\u79BB\u51FD\u6570\r\n     */\r\n    static get distance(): (a: GraphNode, b: GraphNode, link: GraphLink) => number {\r\n        if (!this.__distance) {\r\n            return this.defaultDistance;\r\n        }\r\n        return this.__distance;\r\n    }\r\n\r\n    static set distance(value: (a: GraphNode, b: GraphNode, link: GraphLink) => number) {\r\n        this.__distance = value;\r\n    }\r\n\r\n    private static defaultDistance(a: GraphNode, b: GraphNode, link: GraphLink): number {\r\n        return 1;\r\n    }\r\n\r\n    static __compareFScore: (a: NodeSearchState, b: NodeSearchState) => number;\r\n    /**\r\n     * \u6BD4\u8F83fScore\r\n     */\r\n    static get compareFScore(): (a: NodeSearchState, b: NodeSearchState) => number {\r\n        if (!this.__compareFScore) {\r\n            return this.defaultCompareFScore;\r\n        }\r\n        return this.__compareFScore;\r\n    }\r\n\r\n    static set compareFScore(value: (a: NodeSearchState, b: NodeSearchState) => number) {\r\n        this.__compareFScore = value;\r\n    }\r\n\r\n    private static defaultCompareFScore(a: NodeSearchState, b: NodeSearchState): number {\r\n        return a.fScore - b.fScore;\r\n    }\r\n\r\n    static __setHeapIndex: (state: NodeSearchState, heapIndex: number) => void;\r\n\r\n    static get setHeapIndex(): (state: NodeSearchState, heapIndex: number) => void {\r\n        if (!this.__setHeapIndex) {\r\n            return this.defaultSetHeapIndex;\r\n        }\r\n        return this.__setHeapIndex;\r\n    }\r\n\r\n    static set setHeapIndex(value: (state: NodeSearchState, heapIndex: number) => void) {\r\n        this.__setHeapIndex = value;\r\n    }\r\n\r\n    private static defaultSetHeapIndex(state: NodeSearchState, heapIndex: number): void {\r\n        state.heapIndex = heapIndex;\r\n    }\r\n}", "import { INodeSearchState } from \"./searchs/INodeSearchState\";\r\n\r\n\r\nexport interface INodeHeapOptions {\r\n    setNodeId: (item: INodeSearchState, index: number) => void;\r\n    compare?: (a: INodeSearchState, b: INodeSearchState) => number;\r\n}\r\n\r\nexport class NodeHeap {\r\n\r\n    private __data: INodeSearchState[] = [];\r\n\r\n    private __length: number = 0;\r\n\r\n    compare: (a: INodeSearchState, b: INodeSearchState) => number;\r\n\r\n    setNodeId: (item: INodeSearchState, index: number) => void;\r\n\r\n    constructor(options?: INodeHeapOptions) {\r\n        this.__data = [];\r\n        this.__length = this.__data.length;\r\n        this.compare = options.compare || this.__defaultCompare;\r\n        this.setNodeId = options.setNodeId;\r\n\r\n        if (this.__length > 0) {\r\n            for (let index = (this.__length >> 1); index >= 0; index--) {\r\n                this._down(index)\r\n            }\r\n        }\r\n        if (options.setNodeId) {\r\n            for (let index = 0; index < this.__length; index++) {\r\n                this.setNodeId(this.__data[index], index);\r\n            }\r\n        }\r\n    }\r\n\r\n    push(item: INodeSearchState): void {\r\n        this.__data.push(item);\r\n        this.setNodeId(item, this.__length);\r\n        this.__length++;\r\n        this._up(this.__length - 1);\r\n    }\r\n\r\n    pop(): INodeSearchState | undefined {\r\n        if (this.__length == 0) return undefined;\r\n        let top = this.__data[0];\r\n        this.__length--;\r\n        if (this.__length > 0) {\r\n            this.__data[0] = this.__data[this.__length];\r\n            this.setNodeId(this.__data[0], 0);\r\n            this._down(0);\r\n        }\r\n        this.__data.pop();\r\n        return top;\r\n    }\r\n\r\n    updateItem(pos: number): void {\r\n        this._down(pos);\r\n        this._up(pos);\r\n    }\r\n\r\n    peek(): INodeSearchState | undefined {\r\n        return this.__data[0];\r\n    }\r\n\r\n    _up(pos: number): void {\r\n        let item = this.__data[pos];\r\n        while (pos > 0) {\r\n            let parent = (pos - 1) >> 1;\r\n            let current = this.__data[parent];\r\n            if (this.compare(item, current) >= 0) {\r\n                break;\r\n            }\r\n            this.__data[pos] = current;\r\n            this.setNodeId(current, pos);\r\n            pos = parent;\r\n        }\r\n        this.__data[pos] = item;\r\n        this.setNodeId(item, pos);\r\n    }\r\n\r\n    _down(pos: number): void {\r\n        let item = this.__data[pos];\r\n        let halfLength = this.__length >> 1;\r\n\r\n        while (pos < halfLength) {\r\n            let left = (pos << 1) + 1;\r\n            let right = left + 1;\r\n            let best = this.__data[left];\r\n\r\n            if (right < this.__length && this.compare(this.__data[right], best) < 0) {\r\n                left = right;\r\n                best = this.__data[right];\r\n            }\r\n            if (this.compare(best, item) > 0) {\r\n                break;\r\n            }\r\n            this.__data[pos] = best;\r\n            this.setNodeId(best, pos);\r\n            pos = left;\r\n        }\r\n\r\n        this.__data[pos] = item;\r\n        this.setNodeId(item, pos);\r\n    }\r\n\r\n    get length():number{\r\n        return this.__length;\r\n    }\r\n\r\n    private __defaultCompare(a: INodeSearchState, b: INodeSearchState): number {\r\n        return a.fScore - b.fScore;\r\n    }\r\n}", "import { DefaultSettings } from \"./DefaultSettings\";\r\nimport { Graph } from \"./graphs/Graph\";\r\nimport { GraphLink } from \"./graphs/GraphLink\";\r\nimport { GraphNode } from \"./graphs/GraphNode\";\r\nimport { NodeHeap } from \"./NodeHeap\";\r\nimport { INodeSearchState } from \"./searchs/INodeSearchState\";\r\nimport { ISearchStatePool } from \"./searchs/ISearchStatePool\";\r\nimport { SearchStatePool } from \"./searchs/SearchStatePool\";\r\n\r\n\r\nexport class IAStarOptions {\r\n    oriented?: boolean;\r\n    blocked?: (a: GraphNode, b: GraphNode, link: GraphLink) => boolean;\r\n    heuristic?: (a: GraphNode, b: GraphNode) => number;\r\n    distance?: (a: GraphNode, b: GraphNode, link: GraphLink) => number;\r\n}\r\n\r\n/**\r\n * A* \u7B97\u6CD5\r\n */\r\nexport class AStar {\r\n\r\n    private __graph: Graph;\r\n\r\n    private __searchPool: ISearchStatePool;\r\n\r\n    private __nodeState: Map<string, INodeSearchState>;\r\n\r\n    private __openSet: NodeHeap;\r\n\r\n    private __oriented: boolean = false;\r\n\r\n    private __blocked: (a: GraphNode, b: GraphNode, link: GraphLink) => boolean;\r\n    private __heuristic: (a: GraphNode, b: GraphNode) => number;\r\n    private __distance: (a: GraphNode, b: GraphNode, link: GraphLink) => number;\r\n\r\n    constructor(graph: Graph, options: IAStarOptions) {\r\n        this.__oriented = options.oriented || false;\r\n        this.__blocked = options.blocked || DefaultSettings.blocked;\r\n        this.__heuristic = options.heuristic || DefaultSettings.heuristic;\r\n        this.__distance = options.distance || DefaultSettings.distance;\r\n        this.__graph = graph;\r\n\r\n        this.__searchPool = new SearchStatePool();\r\n\r\n        this.__nodeState = new Map<string, INodeSearchState>();\r\n\r\n        this.__openSet = new NodeHeap({\r\n            setNodeId: DefaultSettings.setHeapIndex,\r\n            compare: DefaultSettings.compareFScore\r\n        });\r\n    }\r\n    \r\n    find(fromId: string, toId: string): Array<GraphNode> | null {\r\n        let from = this.__graph.getNode(fromId);\r\n        if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\r\n        let to = this.__graph.getNode(toId);\r\n        if (!to) throw new Error('toId is not defined in this graph: ' + toId);\r\n        this.__searchPool.reset();\r\n\r\n        let startNode = this.__searchPool.createNewState(from);\r\n        this.__nodeState.set(from.id, startNode);\r\n\r\n        startNode.fScore = this.__heuristic(from, to);\r\n\r\n        startNode.distanceToSource = 0;\r\n\r\n        this.__openSet.push(startNode);\r\n        startNode.open = 1;\r\n\r\n        let cameFrom: INodeSearchState;\r\n\r\n        let self = this;\r\n        let visitNeighbour = function (otherNode: GraphNode, link: GraphLink): boolean {\r\n            let other_search_state = self.__nodeState.get(otherNode.id);\r\n            if (!other_search_state) {\r\n                other_search_state = self.__searchPool.createNewState(otherNode);\r\n                self.__nodeState.set(otherNode.id, other_search_state);\r\n            }\r\n\r\n            if (other_search_state.closed) {\r\n                return false;\r\n            }\r\n\r\n            if (other_search_state.open == 0) {\r\n                self.__openSet.push(other_search_state);\r\n                other_search_state.open = 1;\r\n            }\r\n\r\n            if (self.__blocked(otherNode, cameFrom.node, link)) {\r\n                return false;\r\n            }\r\n\r\n            let tentativeDistance = cameFrom.distanceToSource + self.__distance(otherNode, cameFrom.node, link);\r\n            if (tentativeDistance >= other_search_state.distanceToSource) {\r\n                return false;\r\n            }\r\n\r\n            other_search_state.parent = cameFrom;\r\n            other_search_state.distanceToSource = tentativeDistance;\r\n            other_search_state.fScore = tentativeDistance + self.__heuristic(other_search_state.node, to);\r\n\r\n            self.__openSet.updateItem(other_search_state.heapIndex);\r\n        }\r\n        while (this.__openSet.length > 0) {\r\n            cameFrom = this.__openSet.pop();\r\n            if (this.goalReached(cameFrom, to)) {\r\n                return this.reconstructPath(cameFrom);\r\n            }\r\n            cameFrom.closed = true;\r\n            this.__graph.forEachLinkedNode(cameFrom.node.id, visitNeighbour, this.__oriented);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private goalReached(searchState: INodeSearchState, targetNode: GraphNode): boolean {\r\n        return searchState.node === targetNode;\r\n    }\r\n\r\n    private reconstructPath(searchState: INodeSearchState): Array<GraphNode> {\r\n        let path = [searchState.node];\r\n        let parent = searchState.parent;\r\n        while (parent) {\r\n            path.push(parent.node);\r\n            parent = parent.parent;\r\n        }\r\n        return path;\r\n    }\r\n}"],
  "mappings": "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",
  "names": ["Vec2"]
}
